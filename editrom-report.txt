
; ******** Source: editrom.asm
     1                          ; PET/CBM EDIT ROM - Steve J. Gray - Started: Nov 29/2013
     2                          ; ================
     3                          ; This is the main Assembler file. It brings in the USER-DEFINED variables and acts on them to build a
     4                          ; functional EDITOR ROM.
     5                          ;
     6                          ;---------------------- Get User Variables and validate some settings, and set output file
     7                          

; ******** Source: edit.asm
     1                          ; PET/CBM EDIT ROM - Steve J. Gray - Started: Nov 29/2013
     2                          ; ================
     3                          ; A Project to create replacement EDIT ROMs for the PET/CBM line of computers.
     4                          ; Use MAKE.BAT to assemble (ACME.EXE must be in same folder or in search path).
     5                          ; For complete documentation see:
     6                          ;      http://www.cbmsteve.ca/editrom/index.html
     7                          ;
     8                          ; Edit these settings to choose which features are included.
     9                          ;
    10                          ; The most important is the CODEBASE setting. It determines which main code to use, which will determine
    11                          ; how many features are available:
    12                          ;
    13                          ;   CODEBASE=0 for 40-column (30xx/40xx) machines with Universal Dynamic Motherboard. Line Linking.
    14                          ;   CODEBASE=1 for 80-column (80xx/82xx/9000) machines with Universal Dynamic Motherboard. No Line Linking.
    15                          ;   CODEBASE=2 for 80-column (8296/8296D) machines (mostly DIN keyboard versions). No Line Linking.
    16                          ;
    17                          ; If there are no options listed it means that support has not been added yet!
    18                          ;
    19                          ; NOTE!: Not all combinations may be valid!!
    20                          ; NOTE!: SuperPET's require a special adapter to use EPROMS and have compatibility issues with 4K edit roms (see web page)
    21                          ;
    22                          ;----------------------------------------------------------------------------------------------------------------------------
    23                          ; The following DATE and COMMENT strings will be placed in the IO area (if used).
    24                          ; Take care that comments do not overflow into code space!
    25                          
    26                          !macro DATE      { !pet "2025-08-14" }
    27                          !macro COMMENT   { !pet "sjg-editrom" }
    28                          
    29                          ;----------------------------------------------------------------------------------------------------------------------------
    30                          
    31                          ; NAME		FEATURE				VALID OPTIONS			NOTES / FUTURE OPTIONS
    32                          ;---------	-------				-------------			----------------------
    33                          CODEBASE  = 1   ; Code Base			0=4000, 1=8000, 2=8296		Important!!! Read Webpage for details
    34                          OPTROM    = 0   ; Location of EXT code		0=$E800-EFFF, 1=$9000, 2=$A000  Normal is 0.
    35                          
    36                          ;-- Keyboard
    37                          KEYSCAN   = 1   ; Keyboard Scanner		0=Normal,1=Business,2=DIN
    38                          KEYBOARD  = 1	; Keyboard type:		0=N-QWERTY,1=B-QWERTY,2=DIN,3=C64,4=B-SJG,5=N-SJG,6=B-QWERTZ,7=B-AZERTY,8=CBM-II (req hw mod)
    39                          REPEATOPT = 0	; Key Repeat Option		0=No (Always ON), 1=Yes
    40                          FONTSET   = 0	; Initial Screen Font		0=Text/Lower, 1=Upper/Graphics	Generally: 40xx machines=1, 8xxx machines=0
    41                          
    42                          ;-- Screen
    43                          REFRESH   = 1	; Screen refresh:		0=Euro,1=N.America,2=PAL,3=NTSC,4=9",82=8296D#1,83=8296D#2,90=32-line,91=35-line,92=90x35,99=Custom
    44                          COLUMNS   = 80	; Screen Width			40,80,90,32 columns		Special cases 32 or 90.
    45                          ROWS      = 25  ; Screen Height			25,35,16 rows			Special cases 16 or 35.
    46                          
    47                          ;-- Line Frequency (50/60)
    48                          HERTZ     = 60	; Line Frequency (Clock):	50=Euro,60=N.America
    49                          IRQFIX    = 0   ; Fix Jiffy Clock?		0=No, 1=Yes			Still needs investigating.
    50                          
    51                          ;-- ESC Codes
    52                          ESCCODES  = 0	; Add ESC codes? 		0=No, 1=Yes			Enable when using COLOURPET or SS40.
    53                          VIDSWITCH = 0   ; Video Mode Select ESC codes?  0=No, 1=Yes			Requires ESC Codes! ESC+0 to ESC+9 to Switch CRTC parameters.
    54                          
    55                          ;-- EXTended Features
    56                          EXECUDESK = 0	; Add Execudesk Menu?		0=No, 1=Yes, 2=Yes/OPTROM	Note: Requires BOOT to TEXT mode!
    57                          COLOURPET = 0	; ColourPET additions?		0=No, 1=Yes			Requires ESC Codes! ESC+0 to ESC+? to set Colour (unless VIDSWITCH=1).
    58                          UPET      = 0   ; Is a Ultra-PET/Micro-PET?     0=No, 1=Yes                     For special Reboot - Andre Fachat's project
    59                          
    60                          ;-- AutoRUN Features
    61                          AUTORUN   = 0   ; Set for BANNER and/or WEDGE	0=No, 1=Yes			Enable if you use any AUTOBOOT feature below
    62                          BYPASS    = 0   ; Check for key to bypass? 	0=No, 1=Yes			Valid when AUTORUN=1. Hold key on ROW9 to bypass.
    63                          BANNER    = 0  	; Custom Banner (power on msg)?	0=No, N=Banner# (1-21,98,99)    Valid when AUTORUN=1. Refer to docs or source. 99=custom message
    64                          WEDGE     = 0	; DOS Wedge?			0=No, 1=Yes			Valid when AUTORUN=1.
    65                          WEDGEMSG  = 0	; Show wedge message?		0=No, 1=Yes			Valid when AUTORUN=1 and WEDGE>0.
    66                          DISKBOOT  = 0	; Boot first file on disk?	0=No, 1=Yes			Valid when AUTORUN=1.
    67                          
    68                          ;-- 40/80 Switching
    69                          SOFT40    = 0	; 40 columns on 8032s?		0=No, 1=Yes			Do NOT enable SOFT40 and SS40 at the same time!
    70                          SS40      = 0	; Software Switchable Soft-40	0=No, 1=Yes			Also set ESCCODES=1. Also if BACKARROW>0 and BACKACTION=1.
    71                          SS40MODE  = 80  ; Initial SS40 Mode		40 or 80 columns		Valid when SS40=1.
    72                          HARD4080  = 0   ; Hardware 40/80 Board?         0=No, 1=Yes			Valid when SS40=1.
    73                          
    74                          ;-- Misc Options
    75                          GRKMODE   = 1   ; REPEAT generates Graphic Chr	0=No, 1=Yes			For B keyboard to generate graphics symbols like N keyboard
    76                          KEYRESET  = 0	; Add keyboard reset? 		0=No, 1=Yes			Reboot machine when combination of keys are pressed
    77                          SILENT    = 0	; Disable BELL/CHIME		0=Normal, 1=Disabled		Disables BELL
    78                          BACKARROW = 0   ; SHIFT-Backarrow Hack code?	0=NO, 1=Yes, 2=Yes EXT		Enable Shift-Backarrow, and where to put the code.
    79                          BACKACTION= 0   ; Backarrow Action		0=Text/Graphic, 1=40/80		Which Backarrow Action? NOTE: 40/80 requires ESC Codes!
    80                          
    81                          MOT6845   = 0   ; Is CRTC a Motorola6845?       0=No, 1=Yes			Probably 0=No for compatibility.
    82                          INFO      = 0   ; Add proj info to code area?	0=NO, 1=Yes,2=Yes+FONT		INFO=2 shows character set at top of screen
    83                          
    84                          CRUNCH    = 0   ; Remove unneeded code?		0=No, 1=Yes			Removes NOPs, filler, and unreachable code.
    85                          BUGFIX    = 1   ; Correct Known bugs?		0=No, 1=Yes			Fix known bugs
    86                          DEBUG 	  = 0	; Add debugging?		0=No, 1=Yes			Add code to display debug info on screen
    87                          NOFILL    = 0   ; Disable FILL?			0=No, 1=Yes			Lets you test assemble but will NOT generate usable code!!!!!
    88                          
    89                          ;-- ColourPET Options
    90                          COLOURVER = 0	; ColourPET Hardware Version	0=Beta,1=Normal/uPET		0=ColourRAM at $8400, 1=$8800 (use for VICE).
    91                          COLOURMODE= 0	; ColourPET Hardware Type	0=Digital, 1=Analog
    92                          DEFAULTFG = 2	; ColourPET Foreground colour   0 to 15 RGBI 			0=black,1=DkGry,2=DkBlu ,3=LtBlu, 4=DkGrn, 5=Grn,   6=DkCyan,7=LtCyan
    93                          DEFAULTBG = 2	; ColourPET Background colour   0 to 15 RGBI 			8=DKred,9=LTred,10=DKpur,11=LTpur,12=DkYel,13=LtYel,14=LtGry,15=White
    94                          DEFAULTBO = 2   ; ColourPET Border colour       0 to 15 RGBI
    95                          BYPASSFG  = 5   ; ColourPET Bypass FG     	0 to 15 RGBI			Colours when AUTOSTART is bypassed.
    96                          BYPASSBG  = 0   ; ColourPET Bypass BG     	0 to 15 RGBI

; ******** Source: editrom.asm
     8                          					; Include USER-DEFINED variables
     9                          	!IF COLOURPET>0 { ESCCODES=1 }					; Make sure ESC Codes is ON if SS40 or COLOURPET is enabled
    10                          	!IF SS40=1      { SOFT40=0 }                         		; Make sure SOFT40 is OFF if SS40 is enabled
    11                          
    12                          	!IF COLOURPET=0 { !TO "editrom.bin",plain }			; Generic output file with no load address
    13                          	!IF COLOURPET>0 { !TO "cpetrom.bin",plain }			; ColourPET output file with no load address
    14                          
    15                          ;---------------------- These are the symbol definitions for PET/CBM memory and IO chips
    16                          

; ******** Source: memzeropage.asm
     1                          ; PET/CBM EDIT ROM - Standard Zero Page locations/variables/storage
     2                          ; ================
     3                          ; Descriptions are from Butterfield's memory maps from Transactor
     4                          
     5                          ;		--------------- Common Usage (All Codebases)
     6                          
     7                          Basic_USR 	= $00		; USR Jump
     8                          USRADD 		= $01		; USR Jump
     9                          CHARAC 		= $03		; Search Character
    10                          ENDCHR 		= $04		; Scan between Quotes Flag
    11                          COUNT 		= $05		; Input buffer pointer. # of subscripts
    12                          DIMFLG 		= $06		; Default DIM flag
    13                          VALTYP 		= $07		; Type: FF=string, 00=numeric
    14                          INTFLG 		= $08		; Type: 80=integer, 00=floating point
    15                          GARBFL 		= $09		; Flag: DATA scan; List quote; memory
    16                          SUBFLG 		= $0a		; Flag: Subscript; FNX flag
    17                          INPFLG 		= $0b		; 0=input; $40=GET; $98=READ
    18                          TANSGN 		= $0c		; ATN sign/Comparison Evaluation Flag
    19                          DS_1 		= $0d		; Disk Status DS$ descriptor
    20                          DS_2 		= $0e		; Disk Status DS$ descriptor
    21                          DS_3 		= $0f		; Disk Status DS$ descriptor
    22                          IOPMPT 		= $10		; Current i/o device for prompt suppress
    23                          LINNUM 		= $11		; Integer value (for SYS, GOTO etc)
    24                          TEMPPT 		= $13		; Pointers for descriptor stack
    25                          LASTPT 		= $14	 	
    26                          TEMPST 		= $16		; Descriptor stack (temp strings)
    27                          INDEXA 		= $1f		; Utility pointer area
    28                          INDEXB 		= $21
    29                          FAC3EX 		= $23		; Product area for multiplication
    30                          FAC3M1 		= $24		
    31                          FAC3M2 		= $25
    32                          FAC3M3 		= $26
    33                          FAC3M4 		= $27
    34                          TXTTAB 		= $28		; Pointer: Start of BASIC
    35                          VARTAB 		= $2a		; Pointer: Start of Variables
    36                          ARYTAB 		= $2c		; Pointer: Start of Arrays
    37                          STREND 		= $2e		; Pointer: End of Arrays
    38                          FRETOP 		= $30		; Pointer: String Storage (moving down)
    39                          FRESPC 		= $32		; Pointer: Utility string
    40                          MEMSIZ 		= $34		; Pointer: Limit of Memory
    41                          CURLIN 		= $36		; Current BASIC line number
    42                          OLDLIN 		= $38		; Previous BASIC line number
    43                          OLDTXT 		= $3a		; Pointer: BASIC statement for CONT
    44                          DATLIN 		= $3c		; Current DATA line number
    45                          DATPTR 		= $3e		; Current DATA address
    46                          INPPTR 		= $40		; Input Vector
    47                          VARNAM 		= $42		; Current variable name
    48                          VARPTR 		= $44		; Current variable address
    49                          FORPNT 		= $46		; Variable pointer for FOR/NEXT
    50                          YSAVE 		= $48		; Y-Save; op-save; BASIC pointer save
    51                          ACCSYM 		= $4a		; Comparison symbol accumulator
    52                          FUNCPT 		= $4b		; Misc work area/pointers
    53                          DESCPT 		= $4d
    54                          GARBSS 		= $50
    55                          JUMPER 		= $51		; Jump vector for functions
    56                          FUNJMP 		= $52		
    57                          FACTPA 		= $54		; Misc numeric work area
    58                          TMPPTA 		= $55
    59                          TMPPTB 		= $57
    60                          FACTPB 		= $59
    61                          TMPVA2 		= $5a
    62                          TMPPTC 		= $5c
    63                          FAC1EX 		= $5e		; Accum#1: Exponent
    64                          FAC1M1 		= $5f		; Accum#1: Mantissa
    65                          FAC1M2 		= $60
    66                          FAC1M3 		= $61
    67                          FAC1M4 		= $62
    68                          FAC1SI 		= $63		; Accum#1: Sign
    69                          SGNFLG 		= $64		; Series evaluation constant pointer
    70                          BITS 		= $65		; Accum#1: hi-order (overflow)
    71                          FAC2EX 		= $66	
    72                          FAC2M1 		= $67
    73                          FAC2M2 		= $68
    74                          FAC2M3 		= $69
    75                          FAC2M4 		= $6a
    76                          FAC2SI 		= $6b
    77                          STRPTR		= $6c
    78                          FAC1M5 		= $6d
    79                          TMPPTD 		= $6e
    80                          CHRGET 		= $70
    81                          CHRGETX		= $73		; UNUSED
    82                          CHRGOT 		= $76
    83                          TXTPTR 		= $77
    84                          ISNUM 		= $7d
    85                          RNDX 		= $88
    86                          JIFFY_CLOCK 	= $8d
    87                          CINV 		= $90
    88                          CBINV 		= $92
    89                          NMINV 		= $94
    90                          STATUS		= $96
    91                          KEYPRESSED	= $97		; Which KEY down - $FF = no key
    92                          KEYFLAGS	= $98		; SHIFT KEY - $01 = Pressed
    93                          JIFFY_CORR	= $99		; Correction for JIFFY clock
    94                          STKEY		= $9b		; Keyswitch PIA - Stop and Reverse Flag
    95                          SVXT		= $9c		; Timing Constant for TAPE
    96                          VERCK		= $9d		; Tape mode: 0=Load, 1=Verify
    97                          CharsInBuffer 	= $9e		; Number of characters in keyboard buffer
    98                          ReverseFlag 	= $9f		; Screen Reverse Flag
    99                          C3PO 		= $a0		; IEEE Output - $FF=character pending
   100                          LastInputCol	= $a1		; End of Line for input pointer
   101                          InputRow 	= $a3		; Cursor Log: Row
   102                          InputCol 	= $a4		; Cursor Log: Column
   103                          BSOUR 		= $a5		; IEEE output buffer
   104                          Key_Image	= $a6		; Key Image
   105                          Blink		= $a7		; Cursor Flag: 0=Flash Cursor
   106                          BLNCT		= $a8		; Cursor Timing Countdown
   107                          CursorChar	= $a9		; Character Under Cursor
   108                          BlinkPhase	= $aa		; Cursor in Blink phase
   109                          SYNO		= $ab		; EOT (End of Tape) received from Tape
   110                          CRSW		= $ac		; Input from Screen or Keyboard
   111                          TEMPX		= $ad		; Save X
   112                          LDTND		= $ae		; How many open files?
   113                          DFLTN		= $af		; Input Device - Normally 0
   114                          DFLTO		= $b0		; Output CMD Device - Normally 3
   115                          PRTY		= $b1		; TAPE character parity
   116                          DPSW		= $b2		; Byte Received FLAG
   117                          SAVELA		= $b3		; Logical Address temporary save
   118                          TIMCMD		= $b4		; Tape buffer character / MLM command
   119                          MONCNT		= $b5		; Filename pointer / MLM Flag, counter
   120                          TMPZB7		= $b7
   121                          TMPZB9		= $b9
   122                          TMPZBA		= $ba
   123                          BUFPNT		= $bb
   124                          INBIT		= $bd
   125                          BITCI		= $be
   126                          RINONE		= $bf
   127                          PTR1		= $c0
   128                          PTR2		= $c1
   129                          RIDATA		= $c2
   130                          RIPRTY		= $c3
   131                          ScrPtr		= $c4		; Pointer to character screen line
   132                          CursorCol	= $c6		; Position of cursor on above line
   133                          SAL		= $c7		; Utility Pointer - Tape or Scrolling
   134                          EAL		= $c9		; Tape end address / End of current program
   135                          CMP0		= $cb		; Tape Timing Constants (ColourPET pointer to colour line)
   136                          BLNSW		= $cc		; Tape Timing Constants (ColourPET pointer to colour line)
   137                          QuoteMode	= $cd		; 0=Direct Cursor, else programmed
   138                          BITTS		= $ce		; Tape read timer 1 enabled
   139                          EOT		= $cf		; EOT recieved from TAPE
   140                          READERR		= $d0		; Read Character error
   141                          FNLEN		= $d1		; Number of characters in filename
   142                          LA		= $d2		; Current file Logical Address
   143                          SA		= $d3		; Current file Secondary Address
   144                          FA		= $d4		; Current file Device number
   145                          RightMargin	= $d5		; Window RIGHT margin
   146                          TAPE1		= $d6		; Pointer: Start of Tape Buffer
   147                          CursorRow	= $d8		; Line where cursor lives
   148                          DATAX		= $d9		; Last Key / Checksum / Misc
   149                          FNADR		= $da		; Filename pointer
   150                          INSRT		= $dc		; Number of inserts outstanding
   151                          ROPRTY		= $dd		; Write shift word / read character in
   152                          FSBLK		= $de		; Tape blocks remaining to write
   153                          MYCH		= $df		; Serial word buffer
   154                          CAS1		= $f9		; Cassette #1 status
   155                          CAS2		= $fa		; Cassette #2 status
   156                          STAL		= $fb		; Tape start address/ MLM
   157                          MEMUSS		= $fd		; MLM / DOS pointer / Misc
   158                          
   159                          ;		---------------- 40-Column Only Usage (Codebase 0)
   160                          ;		*** Currently, We cannot use ESC codes with CODEBASE 0 because this area is used for line linking!
   161                          ;		*** The line link table uses 24 bytes, 1 for each line (line 25 can never be linked)
   162                          ;		*** The line link table also holds the HI byte for the 40-col screen line table. It may be possible to
   163                          ;		*** Move the HI byte back into ROM like in the 80 column code, then pack the 24 bytes down to 3 using
   164                          ;		*** BITS instead. This would free 21 bytes that could be used for 80-column plus enhanced features.
   165                          ;		*** However, the code to handle BIT-based line linking would be more complicated and take more code.
   166                          
   167                          !IF CODEBASE=0 {
   168                          LineLinkTable   = $e0		; 40-Col Line Link Table (to $F8)
   169                          
   170                          } ELSE {
   171                          
   172                          ;		---------------- 80-Column Only Usage (Codebase 1 or 2)
   173                          ;		*** These are the normal 80-column screen editor locations. Since we have 80 columns there is no need
   174                          ;		*** for a line-link table, therefor we can use this for enhanced 80-column functions (windowing).
   175                          
   176                          TopMargin	= $e0		; Window TOP line
   177                          BotMargin	= $e1		; Window BOTTOM line
   178                          LeftMargin	= $e2		; Window LEFT margin
   179                          XMAX		= $e3		; Maximum characters in input buffer
   180                          RPTFLG		= $e4		; Key REPEAT flag
   181                          KOUNT		= $e5		; Repeat countdown
   182                          DELAY		= $e6		; New key marker
   183                          CHIME		= $e7		; Chime Time
   184                          HOMECT		= $e8		; Home count
   185                          SCRIV		= $e9		; Screen Input Vector  (E9/EA)
   186                          SCROV		= $eb		; Screen Output Vector (EB/EC)
   187                          ; $ED-F7 			; UNUSED
   188                          JIFFY6DIV5	= $f8		; TI clock adjust (speed by 6/5)
   189                          }
   190                          
   191                          ;		---------------- These are Customized Locations
   192                          ;      		*** With Codebase 1 the area from $ED-$F7 are unused
   193                          ;      		*** With Codebase 0 the area is part of the LineWrap Table
   194                          ;		***  ( can these move to TAPE BUFFER#1? - will conflict with tape and some ML programs)
   195                          
   196                          ; If ESC codes are not active but Backarrow Hack is set to Toggle 40/80
   197                          ; then define Screen Width Location
   198                          !IF (ESCCODES = 0) AND (BACKARROW>0) AND (BACKACTION=1) {
   199                          SCNWIDTH	= $0381		; Screen Mode (40 or 80) for SS40
   200                          }
   201                          
   202                          !IF ESCCODES = 1 {
   203                            !IF CODEBASE = 0 {
   204                          
   205                          ;               *** CODEBASE 0 must avoid line-link table! We will use TAPE#2 buffer (which DOS uses)
   206                          
   207                          SCNWIDTH	= $0381		; Screen Mode (40 or 80) for SS40
   208                          LASTCHAR	= $0382		; Last Key Pressed - used to remember ESC key
   209                          BELLMODE	= $0383		; 0=Disable, 1=Enable BELL/CHIME
   210                          EUROFLAG        = $0384		; 0=ASCII, 1=DIN
   211                          SCN4080BOARD    = $0385		; Flag for Hardware 40/80 Column Switcher board
   212                          
   213                          MYZP            = $00           ; LO General ZP pointer (we don't have a good location for this!)
   214                          ;                 $01           ; HI                    (we will take over the USR jump vector which is rarely used)
   215                          
   216                            } ELSE {
   217                          ;               *** CODEBASE 1/2 can safely go where line-link table would be
   218                          
   219                          SCNWIDTH	= $f0		; Screen Mode (40 or 80) for SS40
   220                          LASTCHAR	= $f1		; Last Key Pressed - used to remember ESC key
   221                          BELLMODE	= $f2		; 0=Disable, 1=Enable BELL/CHIME
   222                          EUROFLAG        = $f3		; 0=ASCII, 1=DIN
   223                          SCN4080BOARD    = $f4		; Flag for Hardware 40/80 Column Switcher board
   224                          MYZP            = $f5           ; LO General ZP pointer
   225                          ;                 $f6           ; HI
   226                          ;                 $f7		; not used
   227                          
   228                            }
   229                          }

; ******** Source: editrom.asm
    17                          				; $0000-00FF	Zero Page 

; ******** Source: memlow.asm
     1                          ; PET/CBM EDIT ROM - Standard Low Mem locations/variables/storage
     2                          ; ================
     3                          
     4                          ;------------------------ Common Usage
     5                          
     6                          STACK 			= $0100	;Processor Stack
     7                          BUF 			= $0200	;MLM work area; Input buffer
     8                          LAT 			= $0251	;File Logical Address Table
     9                          FAT 			= $025b	;File Device Number Table
    10                          SAT 			= $0265	;File Secondary Address Table
    11                          KEYD 			= $026f	;Keyboard input buffer
    12                          TAPEB1 			= $027a	;TAPE#1 input buffer
    13                          TAPEB2                  = $033a ;TAPE#2 input buffer (to $03F9)
    14                          
    15                          ;------------------------ Shared with TAPE#2 buffer
    16                          
    17                          NextTab 		= $033a	;DOS character pointer
    18                          DOS_Drive_1 		= $033b	;DOS drive 1 flag
    19                          DOS_Drive_2 		= $033c	;DOS drive 2 flag
    20                          DOS_Length 		= $033d	;DOS length/write flag
    21                          DOS_Syntax 		= $033e	;DOS syntax flags
    22                          DOS_Id 			= $033f	;DOS disk ID
    23                          DOS_Command_Length 	= $0341	;DOS command string count
    24                          DOS_Filename 		= $0342	;DOS filename buffer
    25                          DOS_Command_Buffer 	= $0353	;DOS command string buffer (to $0380)
    26                          ;			  $0381-03e8 ???
    27                          
    28                          ;------------------------ 40-Column Usage
    29                          
    30                          !IF CODEBASE=0 {
    31                          DELAY			= $03e9 ;Repeat Key countdown delay 	(40 col)
    32                          KOUNT			= $03ea ;Delay between repeats 		(40 col)
    33                          XMAX			= $03eb ;Max keyboard buffer size 	(40 col)
    34                          CHIME			= $03ec ;Chime Time 0=off 		(40 col)
    35                          JIFFY6DIV5		= $03ed ;TI clock adjust (speed by 6/5) (40 col) Was: TIADJ
    36                          RPTFLG			= $03ee ;Repeat Flag                    (40 col)
    37                          TABS			= $03ef ;TAB-STOP table			(40 col)
    38                          }
    39                          
    40                          ;------------------------ Common Usage
    41                          
    42                          TABS_SET 		= $03ee	;80 column TAB stop table ($03ee-03f7) ** Should this be $03ef ???? **
    43                          ;			  $03f8 ???
    44                          ; 			  $03f9 ???
    45                          
    46                          ;------------------------ End of TAPE#2 bufer
    47                          
    48                          Reset_Vector 		= $03fa	;Monitor extension vector
    49                          Reset_Param 		= $03fc	;IEEE timeout defeat; $FF=disable
    50                          ;			  $03fd ???
    51                          ;			  $03fe ???
    52                          ;			  $03ff ???
    53                          
    54                          ;------------------------ BASIC Program Area
    55                          

; ******** Source: editrom.asm
    18                          					; $0100-03FC	Low Memory

; ******** Source: memchips.asm
     1                          ; PET/CBM EDIT ROM - Standard Chip Registers and Screen Ram
     2                          ; ================
     3                          
     4                          ;--------------------------- Screen RAM $8000-$8FFF
     5                          
     6                          SCREEN_RAM = $8000					; 40 Col = $8000-83FF, 80 Col = $8000-87FF
     7                          
     8                          !IF COLUMNS = 80 { KBD_MATRIX = $87d0 }			; Used with Extended DIN ROM keyboard scanning routine
     9                          !IF COLUMNS = 40 { KBD_MATRIX = $83e8 }			; First unused byte in SCREEN_RAM
    10                          
    11                          
    12                          ;--------------------------- PIA #1 - 6520 Chip
    13                          
    14                          PIA1_Port_A = $e810					; Keyboard ROW select
    15                          PIA1_Cont_A = $e811
    16                          PIA1_Port_B = $e812					; Keyboard COLUMN read
    17                          PIA1_Cont_B = $e813
    18                          
    19                          ;--------------------------- PIA #2 - 6520 Chip
    20                          
    21                          PIA2_Port_A = $e820
    22                          PIA2_Cont_A = $e821
    23                          PIA2_Port_B = $e822
    24                          PIA2_Cont_B = $e823
    25                          
    26                          ;--------------------------- VIA - 6522 Chip
    27                          
    28                          VIA_Port_B = $e840					; IEEE, Screen Retrace, Cassette motor
    29                          VIA_Port_A = $e841					; Parallel Port (User Port) with handshaking
    30                          VIA_DDR_B = $e842					; Data Direction Register for PORT B
    31                          VIA_DDR_A = $e843					; Data Direction Register for PORT A
    32                          VIA_Timer_1_Lo = $e844				; Timer 1
    33                          VIA_Timer_1_Hi = $e845
    34                          VIA_Timer_1_Latch_Lo = $e846			; Timer 1 Latch
    35                          VIA_Timer_1_Latch_Hi = $e847
    36                          VIA_Timer_2_Lo = $e848				; Timer 2
    37                          VIA_Timer_2_Hi = $e849
    38                          VIA_Shift = $e84a					; Shift Register
    39                          VIA_ACR = $e84b						; Shift Register Control
    40                          VIA_PCR = $e84c
    41                          VIA_IFR = $e84d
    42                          VIA_IER = $e84e
    43                          VIA_Port_A_no_HS = $e84f				; Parallel Port, no handshaking
    44                          
    45                          ;--------------------------- CTRC - 6545 CRT Controller
    46                          
    47                          CRT_Address = $e880					; Register Select Port
    48                          CRT_Status = $e881					; Register DATA port

; ******** Source: editrom.asm
    19                          					; $E800-E8FF	Chips

; ******** Source: memkernal.asm
     1                          ; PET/CBM EDIT ROM - Standard Kernal calls
     2                          ; ================
     3                          ; These are calls from the EDIT ROM to KERNAL entry points
     4                          ;---------------------------------------------------------
     5                          ; Non-vectored calls (direct - caution: could change if KERNAL is changed)
     6                          
     7                          CHKSTOP 	= $F335 ; Check for STOP key
     8                          
     9                          ;----------------- Standard KERNAL Entry Points
    10                          
    11                          BASIN		= $ffcf ; read char from input channel -> A
    12                          BSOUT		= $ffd2	; Write A to stdout
    13                          GETIN		= $ffe4	; read char from keyboard buffer -> A
    14                          UDTIME		= $FFEA	; Update Time
    15                          
    16                          ACPTR		= $f1c0	; input IEEE -> A
    17                          CHKIN		= $ffc6	; stdin from logical file # in X
    18                          CIOUT		= $f19e	; output A -> IEEE
    19                          CKOUT		= $ffc9	; stdout to logical file # in X
    20                          CLOSE		= $f2e0	; close file
    21                          CLSEI		= $f72f	; close and unlisten
    22                          CLRCH		= $ffcc	; reset stdio to defaults
    23                          LISTN		= $f0d5	; send LISTEN
    24                          LOAD		= $f408	; LOAD
    25                          LOADOP		= $f356	; LOAD without pointer change
    26                          FILENOTFOUND	= $f425	; FILE NOT FOUND, return to BASIC
    27                          OPEN		= $f563	; open file
    28                          OPENI		= $f4a5	; open file on IEEE device
    29                          SCNT		= $f2c1	; prepare SETT for logical file A
    30                          SECND		= $f143	; send secondary address A
    31                          SETT		= $f2cd	; set LF,DN,SA from table
    32                          TALK		= $f0d2	; send TALK
    33                          TWAIT		= $f92b	; 
    34                          UNLSN		= $f1b9	; send UNLISTEN
    35                          UNTLK		= $f1ae	; send UNTALK
    36                          RESET		= $fd16	; basic cold start
    37                          STOPEQ		= $f335	; set Z flag if stop key pressed
    38                          STOPR		= $ffe1	; return to basic if stop key pressed

; ******** Source: editrom.asm
    20                          					; $F000-FFFF	Kernal

; ******** Source: membasic4.asm
     1                          ; --------- BASIC 4 ROM ROUTINES
     2                          
     3                          SCROUT	= $e202	; output A to screen
     4                          RDOA	= $d754	; read hex address -> $FB,$FC
     5                          RDOB	= $d763	; read hex byte -> A
     6                          CLRSCR	= $e015	; clear screen
     7                          CRLF	= $d534	; move cursor to next line
     8                          FPOUT	= $cf8d	; write floating point
     9                          INTOUT	= $cf83	; write integer 0-65535 X=LSB,A=MSB
    10                          SCROLD	= $e021	; scroll down
    11                          SCROLU	= $e024	; scroll up
    12                          SPAC2	= $d52e	; write 2 spaces
    13                          SPACE	= $d531	; write space
    14                          STROUTZ	= $bb1d	; A=LSB, Y=MSB			; BASIC4 STROUTZ is broken!
    15                          STROUT	= $bb24	; X=len, STRADR=ptr
    16                          WROA	= $d717	; write hex address
    17                          HEXOUT	= $d722	; write A as hex
    18                          WROB	= $d731	; write hex byte
    19                          WRTWO	= $d731	; write XA to screen
    20                          
    21                          ADRFP	= $cd7f	; uint LSB=$5f, MSB=$60 -> FAC1
    22                          ASCII	= $d73a	; hex digit -> ascii hex digit
    23                          FPINT	= $cdd1	; FAC1 -> uint $61=MSB, $62=LSB
    24                          FPSTR	= $cf93	; fp -> str $0100..NUL
    25                          HEXIT	= $d78d	; hex ascii digit A -> hex digit A
    26                          INTFP	= $c4bc	; int Y=LSB, A=MSB -> FAC1
    27                          STRFP	= $c8eb	; string -> fp
    28                          RDINT	= $b8f6	; read basic text -> LINNUM
    29                          
    30                          ABS	= $cd8e	; FAC1 = ABS(FAC1)
    31                          ADD	= $c9a0	; FAC1 = FAC1 + FAC2
    32                          ATN	= $d32C	; FAC1 = ATN(FAC1)
    33                          COS	= $d282	; FAC1 = COS(FAC1)
    34                          DIV	= $cc48	; FAC1 = FAC2 / FAC1
    35                          EXP	= $d184	; FAC1 = EXP(FAC1)
    36                          FAC12	= $cd45	; FAC2 := FAC1
    37                          
    38                          READY	= $b3ff	; basic warm start
    39                          NEWSTT	= $b74a	; set up next statement for execution
    40                          MOVBLK	= $b357	; move block
    41                          
    42                          LINKPRG	= $b4b6	; rechain lines
    43                          RSTXCLR	= $b5e9	; reset TXTPTR and perform CLR
    44                          STXTPT	= $b622	; reset TXTPTR
    45                          CLR	= $b5f0	; perform CLR
    46                          SCRTCH	= $b5d4	; perform NEW
    47                          
    48                          MAINS	= $b40f	; MAIN's return addr on stack for CHRGET routine

; ******** Source: editrom.asm
    21                          					; BASIC
    22                          
    23                          	!IF COLOURPET=1 { !SOURCE "memcpet.asm" }			; Non-standard memory usage (may change without notice)
    24                          
    25                          ;---------------------- Debug stuff
    26                          
    27                          	DBLINE = SCREEN_RAM + 24 * COLUMNS				; Calculate bottom line of screen for debug
    28                          
    29                          ;=======================================================================
    30                          ; Standard 2K Edit ROM code starts here
    31                          ;=======================================================================
    32                          ; $E000-E7FF are for normal Edit ROMS.
    33                          ; The CODEBASE setting determines which BASE features are included,
    34                          ; which roughly determines which machine they were targetted to.
    35                          ; This area MAY include NEW code depending on SETTINGS. Some new code may
    36                          ; require standard code to be relocated to EXT code area.
    37                          
    38                          	!IF CODEBASE=0 {!SOURCE "editrom40.asm"}			; 40-column CODEBASE

; ******** Source: editrom80.asm
     1                          ; PET/CBM EDIT ROM  - Commented and Adapted by Steve J. Gray, Dec 14, 2015
     2                          ; ================    sjgray@rogers.com
     3                          ;
     4                          ; ***** THIS IS 80-COLUMN CODEBASE *****
     5                          ; 
     6                          ; This is reverse engineered source code for the EDIT ROMs of the Commodore PET/CBM computers.
     7                          ; The "324243-04" ROM was used as a base as it was (AFAIK) the LAST EDIT ROM that Commodore made
     8                          ; for the PET/CBM line; 8296 computer, 50HZ, 80 column, DIN keyboard, 4K size. Addresses inside
     9                          ; [brackets] are original code addresses. This disassembly is a combination of my own disassembly
    10                          ; plus a disassembly from Edilbert Kirk. Both were adapted by me for use with the ACME assembler.
    11                          ;
    12                          ; The EDIT ROM is mapped from $E000 to EFFF (4K). Many Early versions used only $E000-E7FF (2K).
    13                          ; Note that the area from $E800 to $E8FF (256 bytes) is not available due to the I/O chips in this range.
    14                          ;
    15                          ; PET/CBM machines come in several flavours:
    16                          ;    * 40 or 80 column screens
    17                          ;    * Normal, Business, or DIN keyboards
    18                          ;    * 50 or 60 Hz power frequency
    19                          ;    * Specialized options, ie: Execudesk
    20                          ;
    21                          ; In addition I am adapting the EDIT roms to these additional options:
    22                          ;    * ColourPET - My own project to add colour capabilities
    23                          ;    * Alternate Keyboards - Such as the VIC/C64 keyboard
    24                          ;    * Soft40 - Simulate a 40 column screen on 80 column hardware
    25                          ;    * Soft-switchable SOFT40
    26                          ;    * Soft-switchable real 40/80 columns (requires hardware mod)
    27                          ;    * Extended screen editor - C128 or CBM-II compatible ESC sequences
    28                          ;    * Keyboard soft-reset (like CTRL-ALT-DEL on PC's)
    29                          ;    * Autoboot from default drive
    30                          ;    * DOS Wedge
    31                          ;
    32                          ; See EDIT.ASM for assemble OPTIONS!
    33                          ; Use MAKE.BAT to assemble a binary file with the current options.
    34                          ;
    35                          ;-----------------------------------------------------------------------------------------------
    36                          ; BUG!: the 80-column screen editor does not support line-linking. This means that you are
    37                          ;       limited to entering BASIC lines to the maximum width of one screen line.
    38                          ;       This ALSO applies when you have defined a window... you will be limited to the width
    39                          ;       of the window. Take caution when editing BASIC lines inside a window; any line that
    40                          ;       wraps around to the next line will be TRUNCATED if you edit it inside a window!!!!!
    41                          
    42                          ;-----------------------------------------------------------------------------------------------
    43                          * = $e000	; Normal start address for EDIT ROM is $E000
    44                          
    45                          ;*********************************************************************************************************
    46                          ;** Edit ROM Jump Table  [E000]
    47                          ;** Note: Not all KERNAL and BASIC calls go through this table.
    48                          ;** There are FIVE hard-coded entry points: $E0A7, $E116, $E202, $E442, $E600
    49                          ;*********************************************************************************************************
    50                          
    51  e000 4c4be0             EDITOR		JMP RESET_EDITOR	; [E000] Main Initialization (called from Kernal power up reset at $FD16) 
    52  e003 4ca7e0             		JMP GETKEY		; [E003] Get Character From Keyboard Buffer	(FIXED ENTRY POINT. Must not move!)
    53  e006 4c16e1             		JMP INPUT_CHARACTER	; [E006] Input From Screen or Keyboard		(FIXED ENTRY POINT. Must not move!)
    54  e009 4c02e2             		JMP CHROUT_SCREEN	; [E009] Output to Screen			(FIXED ENTRY POINT. Must not move!)
    55  e00c 4c42e4             		JMP IRQ_MAIN		; [E00C] Main IRQ Handler			(FIXED ENTRY POINT. Must not move!)
    56  e00f 4c55e4             		JMP IRQ_NORMAL		; [E00F] Actual IRQ (clock, keyboard scan)
    57  e012 4c00e6             		JMP IRQ_END		; [E012] Return From Interrupt			(FIXED ENTRY POINT. Must not move!)
    58  e015 4c51e0             		JMP WIN_CLEAR		; [E015] Clear Window
    59  e018 4c7ae0             		JMP CRT_SET_TEXT	; [E018] Set CRTC to TEXT mode
    60  e01b 4c82e0             		JMP CRT_SET_GRAPHICS	; [E01B] Set CRTC to GRAPHICS mode
    61  e01e 4c88e0             		JMP CRT_PROGRAM		; [E01E] Program CRTC (Table pointer in A/X, chr set in Y)
    62  e021 4cc8e3             		JMP WIN_SCROLL_DN	; [E021] Scroll Window DOWN
    63  e024 4ce8e3             		JMP WIN_SCROLL_UP	; [E024] Scroll Window UP
    64  e027 4cb8e4             		JMP SCAN_KEYBOARD	; [E027] Scan Keyboard
    65  e02a 4ca7e6             		JMP BEEP		; [E02A] Ring BELL/CHIME
    66  e02d 4c36e0             		JMP SET_REPEAT_MODE	; [E02D] Set REPEAT MODE
    67  e030 4ce1e1             		JMP WIN_SET_TOP		; [E030] Set Window Top
    68  e033 4cdce1             		JMP WIN_SET_BOT		; [E033] Set Window Bottom
    69                          
    70                          ;*********************************************************************************************************
    71                          ;** SET_REPEAT_MODE  [E036]  (Called from Jump Table)
    72                          ;** Sets Repeat mode to 'A'. Flag: $80 = Repeat, $40 = disable
    73                          ;*********************************************************************************************************
    74                          
    75                          SET_REPEAT_MODE
    76                          		!IF REPEATOPT = 1 {
    77                          			STA RPTFLG				;$E4
    78                          		} else {
    79                          			!IF CRUNCH=0 {
    80  e036 ea                 				NOP
    81  e037 ea                 				NOP
    82                          			}
    83                          		}
    84  e038 60                 		RTS
    85                          
    86  e039 aaaaaaaaaaaaaaaa...!IF CRUNCH=0 {	!FILL $e04b-*,$aa }			;#################################################
    87                          
    88                          ;*********************************************************************************************************
    89                          ;** RESET_EDITOR  [E04B]  (Called from Jump Table)
    90                          ;** Initializes Editor, then sets the screen to TEXT or GRAPHICS mode.
    91                          ;*********************************************************************************************************
    92                          
    93                          RESET_EDITOR
    94                          
    95                          !IF COLOURPET=0 {
    96  e04b 200fe6             		JSR INIT_EDITOR				; Initialize Editor
    97                          } ELSE {
    98                          		JSR ColourPET_Init			; Initialize ColourPET settings, then INIT_EDITOR
    99                          }
   100                          
   101  e04e 207ae0             !IF FONTSET=0	{ JSR CRT_SET_TEXT }			; Set Screen to TEXT mode
   102                          !IF FONTSET=1	{ JSR CRT_SET_GRAPHICS }			; Set Screen to GRAPHICS mode
   103                          
   104                          ;*********************************************************************************************************
   105                          ;** WIN_CLEAR  [E051]  (Called from Jump Table)
   106                          ;** This routine Clears the current window. It clears ONLY the screen memory specified.
   107                          ;** Since this is the 80-column codebase there is no line-linking code. Both LO and HI
   108                          ;** screen address tables are in ROM.
   109                          ;*********************************************************************************************************
   110                          
   111  e051 a6e0               WIN_CLEAR	LDX TopMargin				; Window Top line
   112  e053 ca                 		DEX					; prep for loop
   113  e054 e8                 WC_LOOP		INX					; LOOP[  Next line
   114  e055 206ce0             		JSR UPDATE_CURSOR_R2			;   was: CURSOR_LM  ; Was: Cursor_BOL
   115  e058 20c1e1             		JSR ERASE_TO_EOL			;   Erase the line
   116  e05b e4e1               		CPX BotMargin				;   Check if at the last line
   117  e05d 90f5               		BCC WC_LOOP				; ] No, go do next line
   118                          
   119                          ;*********************************************************************************************************
   120                          ;** CURSOR_HOME  [E05F]
   121                          ;** Moves the cursor to the HOME position of the current WINDOW.
   122                          ;*********************************************************************************************************
   123                          
   124  e05f a6e0               CURSOR_HOME	LDX TopMargin				; Go to TOP of window
   125  e061 86d8               		STX CursorRow				; put cursor there too
   126                          
   127                          ;*********************************************************************************************************
   128                          ;** CURSOR_LM  [E063]
   129                          ;** Moves cursor to LEFT MARGIN of the current WINDOW.
   130                          ;*********************************************************************************************************
   131                          
   132  e063 a4e2               CURSOR_LM	LDY LeftMargin				; Get Left margin
   133  e065 84c6               		STY CursorCol				; Set cursor there
   134                          
   135                          ;*********************************************************************************************************
   136                          ;** Update Cursor ROW [E067] - Get pointer from Screen Line Address Tables (and Colour)
   137                          ;*********************************************************************************************************
   138                          
   139                          UPDATE_CURSOR_ROW
   140  e067 a6d8               		LDX CursorRow				; Current Cursor Physical Line Number
   141  e069 4c6fe0             		JMP UPDATE_CURSOR_R3			;
   142                          UPDATE_CURSOR_R2
   143  e06c a4e2               		LDY LeftMargin				; First column of window
   144  e06e 88                 		DEY
   145                          UPDATE_CURSOR_R3
   146  e06f bd55e7             		LDA Line_Addr_Lo,X			; Screen Line Addresses LO
   147                          
   148                          ;*********************************************************************************************************
   149                          ;** Update Screen Pointers
   150                          ;*********************************************************************************************************
   151                          
   152                          UPDATE_SCREEN_PTR
   153                          	!IF COLOURPET=1 {
   154                          		JSR ColourPET_SyncPointersX		; Sync Pointers to Current Line
   155                          	} ELSE {
   156                          		!IF SS40=1 {
   157                          			JSR SS40_SyncPointersX		; Update screen pointers based on current screen width
   158                          		} ELSE {
   159  e072 85c4               			STA ScrPtr			; Pointer: Current Screen Line Address LO
   160  e074 bd6ee7             			LDA Line_Addr_Hi,X		; Screen Line Addresses HI
   161  e077 85c5               			STA ScrPtr+1         		; Pointer: Current Screen Line Address HI
   162                          		}
   163                          	}
   164  e079 60                 		RTS
   165                          
   166                          ;*********************************************************************************************************
   167                          ;** CRTC Programming and Screen Modes  [E07A]
   168                          ;*********************************************************************************************************
   169                          

; ******** Source: crtc.asm
     1                          ; PET/CBM EDIT ROM - CRTC Programming for Text/Graphics Screen Modes
     2                          ; ================
     3                          ; Programms the CRTC controller chip for various screen timings and Text/Graphic modes.
     4                          ; This code requires two CRTC Register tables - One for Text and one for Graphics modes.
     5                          
     6                          
     7                          ;************** Set Screen to TEXT or GRAPHICS MODE
     8                          ;
     9                          ; TEXT/GRAPHICS mode determines which font is displayed.
    10                          ; - GRAPHICS mode has uppercase and full graphics. Characters take 8 scanlines
    11                          ; - TEXT mode has lower case, upper case and limited graphics. Characters take 10 scanlines (normally)
    12                          ; 
    13                          ; OPTIONS: 'EXTENDED' and 'SS40'
    14                          
    15                          ;-------------- Initialize CRTC to TEXT Mode (Called from Jump Table)
    16                          
    17                          CRT_SET_TEXT
    18                          
    19                          !if CODEBASE<2 {
    20                          	!IF SS40=0 {
    21  e07a a92a               		LDA #<CRT_CONFIG_TEXT			; Point to CRTC Table
    22  e07c a2e7               		LDX #>CRT_CONFIG_TEXT			; Point to CRTC Table
    23  e07e a00e               		LDY #$0E				; Character Set = TEXT
    24  e080 d006               		BNE CRT_PROGRAM
    25                          	} ELSE {
    26                          		JMP CRT_SET_TEXT_SS40			; Jump to SS40 version (upper rom)
    27                          	}
    28                          }
    29                          
    30                          !IF CODEBASE=2 {
    31                          	JMP CRT_SET_TEXT_EXT				; Jump to EXTENDED version (upper rom)
    32                          
    33                          	!if CRUNCH=0 {	
    34                          		NOP
    35                          		NOP
    36                          		NOP
    37                          		NOP
    38                          		NOP
    39                          	}
    40                          }
    41                          
    42                          ;-------------- Initialize CRTC to GRAPHICS Mode (Called from Jump Table)
    43                          
    44                          CRT_SET_GRAPHICS
    45                          
    46                          !if CODEBASE<2 {
    47                          	!IF SS40=0 {
    48  e082 a93c               		LDA #<CRT_CONFIG_GRAPHICS       	; Point to CRTC Table
    49  e084 a2e7               		LDX #>CRT_CONFIG_GRAPHICS       	; Point to CRTC Table
    50  e086 a00c               		LDY #$0C				; Character Set = GRAPHICS
    51                          	} ELSE {
    52                          		JMP CRT_SET_GRAPHICS_SS40		; Jump to SS40 version (upper rom)
    53                          	}
    54                          }
    55                          !IF CODEBASE=2 {
    56                          	JMP CRT_SET_GRAPHICS_EXT		; Jump to EXTENDED version (upper rom)
    57                          
    58                          	!if CRUNCH=0 {
    59                          		NOP
    60                          		NOP
    61                          		NOP
    62                          	}
    63                          }
    64                          
    65                          ;************** Program CRTC chip for selected screen MODE (Called from Jump Table)
    66                          ;
    67                          ; The CRTC controller controls the parameters for generating the display on the monitor. The CRTC chip has
    68                          ; several registers that must be set properly according to the type of connected display. These set characters on the line,
    69                          ; left and right margins, lines on the screen, height of each line and positioning of the top of the screen.
    70                          ; The parameters are read from a table and written to the CRTC controller chip. The VIA chip is used to select which of the
    71                          ; two fonts from the CHARACTER ROM is used.
    72                          ;
    73                          ; Parameters: Table pointer in A/X, CHRSET in Y
    74                          ; OPTIONS: 'SS40' uses new routine in upper rom
    75                          
    76                          CRT_PROGRAM
    77                          
    78                          !IF SS40=0 {
    79                          ;		--------------------- Set 'Character Set'
    80                          
    81  e088 85c7               		STA SAL					; Pointer LO: Tape Buffer/ Screen Scrolling
    82  e08a 86c8               		STX SAL+1				; Pointer HI
    83  e08c ad4ce8             		LDA VIA_PCR				; Get current register byte VIA Register C - CA2	CHIP 
    84  e08f 29f0               		AND #$f0				; mask out lower nibble
    85  e091 85d1               		STA FNLEN				; save it to Temp Variable
    86  e093 98                 		TYA					; Move 'Character Set' byte to A
    87  e094 05d1               		ORA FNLEN				; update lower nibble in Temp Variable
    88  e096 8d4ce8             		STA VIA_PCR				; write it back to VIA Register C - CA2			CHIP
    89                          
    90                          ;		--------------------- Write to the CRTC controller
    91                          
    92  e099 a011               		LDY #$11				; Number of bytes to copy = 17
    93                          
    94  e09b b1c7               CRT_LOOP	LDA (SAL),Y				; Pointer: Tape Buffer/ Screen Scrolling
    95  e09d 8c80e8             		STY CRT_Address				; Select the register to update 6545/6845 CRT		CHIP
    96  e0a0 8d81e8             		STA CRT_Status				; Write to the register
    97  e0a3 88                 		DEY
    98  e0a4 10f5               		BPL CRT_LOOP				; loop for more
    99  e0a6 60                 		RTS
   100                          } ELSE {
   101                          		JMP CRT_PROGRAM_SS40			; Jump to Switchable Soft-40 version (upper rom)
   102                          }

; ******** Source: editrom80.asm
   170                          
   171                          
   172                          ;*********************************************************************************************************
   173                          ;** GETKEY  [E0A7]  (Called from Jump Table)
   174                          ;** Get a KEY from keyboard buffer. Reads a character from 'KEYD' then shifts remaining buffer characters
   175                          ;** If there is NO key it will return $FF.
   176                          ;*********************************************************************************************************
   177                          
   178                          	!IF NOFILL=0 { !FILL $e0a7-*,$aa }		; FIXED ENTRY POINT! This must not move!
   179                          
   180                          ;#########################################################################################################
   181                          
   182                          GETKEY
   183                          !IF DEBUG=1 { INC DBLINE+2,X }			; DEBUG
   184  e0a7 ac6f02             		LDY KEYD				; Get key at start of buffer
   185  e0aa a200               		LDX #0 					; Start at 0
   186                          
   187  e0ac bd7002             GK_LOOP		LDA KEYD+1,X				; LOOP[ START - Now shift the next keys in line
   188  e0af 9d6f02             		STA KEYD,X				;   to the front of the buffer
   189                          !IF DEBUG=1 { STA DBLINE+10,X }				;   DEBUG - update screen
   190  e0b2 e8                 		INX
   191  e0b3 e49e               		CPX CharsInBuffer			;   Num Chars in Keyboard Buffer
   192  e0b5 d0f5               		BNE GK_LOOP				; ] Done? No, loop for another
   193                          
   194  e0b7 c69e               		DEC CharsInBuffer			; Reduce Num Chars in Keyboard Buffer
   195                          
   196  e0b9 98                 		TYA					; Put the character in Accumulator
   197                          !IF DEBUG=1 { STA DBLINE+3 }				; DEBUG - 4th chr on bottom line
   198  e0ba 58                 		CLI
   199  e0bb 60                 		RTS
   200                          
   201                          ;*********************************************************************************************************
   202                          ;** GETLINE  [E0BC]
   203                          ;** The PET is usually in this routine, waiting for keypresses and printing them or acting on them.
   204                          ;** This routine continually loops until a <RETURN> is pressed. When <RETURN> is pressed then the line
   205                          ;** where the cursor is, is processed. If the <RUN> key is pressed then the string is stuffed into
   206                          ;** the keyboard buffer (overwriting whatever might be there)
   207                          ;*********************************************************************************************************
   208                          
   209  e0bc 208ce6             GETLINE		JSR ChrOutMarginBeep			; 
   210                          GETLINE2	!IF DEBUG=1 { INC DBLINE+5 }		; DEBUG - 6th chr on bottom line
   211  e0bf a59e               		LDA CharsInBuffer			; Are there any keys waiting?
   212  e0c1 85a7               		STA Blink 				; 0 chars -> blink cursor
   213  e0c3 f0fa               		BEQ GETLINE2 				; loop until char in buffer
   214                          
   215                          !IF DEBUG=1 { INC DBLINE+6 }				; DEBUG - 7th chr on bottom line
   216                          
   217                          ;[E0C5]		--------------- Got a character, so process it
   218                          
   219  e0c5 78                 		SEI
   220  e0c6 a5aa               		LDA BlinkPhase				; Check if cursor in blink phase
   221  e0c8 f009               		BEQ GL_1				; no, so no need to restore original character
   222  e0ca a5a9               		LDA CursorChar				; yes, get character under Cursor
   223  e0cc a000               		LDY #0					; 
   224  e0ce 84aa               		STY BlinkPhase				; Reset blinkphase
   225  e0d0 2006e6             		JSR RESTORE_CHR_AT_CRSR		; Restore OLD character under cursor before processing new one
   226  e0d3 20a7e0             GL_1		JSR GETKEY				; Get Character From Keyboard Buffer
   227  e0d6 c983               		CMP #$83				; Is it the <RUN> key?
   228  e0d8 d010               		BNE GL_3				; No, skip ahead
   229                          
   230                          ;[E0DA]		---------------- Stuff the <RUN> string to the keyboard buffer
   231                          
   232  e0da 78                 		SEI
   233  e0db a209               		LDX #9					; Length of string
   234  e0dd 869e               		STX CharsInBuffer			; Set number of characters in buffer
   235  e0df bd20e7             GL_2		LDA RUN_STRING-1,X			; Normally:  dL"*<RETURN>run<RETURN>
   236  e0e2 9d6e02             		STA KEYD-1,X				; stuff it into the buffer
   237  e0e5 ca                 		DEX
   238  e0e6 d0f7               		BNE GL_2				; loop back for more
   239  e0e8 f0d5               		BEQ GETLINE2
   240                          
   241                          ;[E0EA]		--------------- Check for RETURN key
   242                          
   243  e0ea c90d               GL_3		CMP #$0D 				; Check if <RETURN> pressed
   244  e0ec d0ce               		BNE GETLINE				; if not go get more keys
   245                          
   246                          ;*********************************************************************************************************
   247                          ;** PARSE_LINE  [E0EE]
   248                          ;** When the <RETURN> key is pressed the line where the cursor lives is executed
   249                          ;*********************************************************************************************************
   250                          
   251                          PARSE_LINE
   252                          		!IF DEBUG=1 { INC DBLINE+7 }		; DEBUG - 8th chr on bottom line
   253                          
   254  e0ee a4d5               		LDY RightMargin				; Physical Screen Line Length
   255  e0f0 84ac               		STY CRSW 				; # 0 -> Screen Input
   256                          
   257  e0f2 b1c4               PL_LOOP		LDA (ScrPtr),Y				; LOOP[  Read Character from Screen RAM
   258  e0f4 c920               		CMP #$20 				;   Is it <SPACE> Ignore trailing blanks
   259  e0f6 d003               		BNE PL_SKIP				; 	No, exit out
   260  e0f8 88                 		DEY					; 	Yes, move to previous position
   261  e0f9 d0f7               		BNE PL_LOOP				; ] At start of line? No, loop back for more
   262                          
   263                          ;[E0FB]		------------------------ Process line
   264                          
   265  e0fb c8                 PL_SKIP 	INY					; last was not <SPACE> so move ahead one
   266  e0fc 84a1               		STY LastInputCol			; record the position
   267  e0fe 20cbe1             		JSR CURSOR_TO_LM			; Move to the start of the line [80] 
   268  e101 ea                 !IF CRUNCH=0 {	NOP }					; (this is a patch)		[80] 
   269  e102 84cd               		STY QuoteMode 				; Turn off quote mode
   270  e104 a5a3               		LDA InputRow				; Cursor Y-X Pos. at Start of INPUT
   271  e106 3019               		BMI Screen_Input
   272  e108 c5d8               		CMP CursorRow				; Current Cursor Physical Line Number
   273  e10a d015               		BNE Screen_Input
   274  e10c a5a4               		LDA InputCol
   275  e10e 85c6               		STA CursorCol				; Cursor Column on Current Line
   276  e110 c5a1               		CMP LastInputCol			; Pointer: End of Logical Line for INPUT
   277  e112 900d               		BCC Screen_Input
   278  e114 b02e               		BCS Screen_Input2
   279                          
   280                          ;*********************************************************************************************************
   281                          ;** INPUT_CHARACTER  [E116]  (Called from Jump Table) - FIXED ENTRY POINT!!!!!
   282                          ;** Push X and Y to stack then call Input a Character routine via pointer
   283                          ;*********************************************************************************************************
   284                          
   285                          		!IF NOFILL=0 { !FILL $e116-*,$aa }	; FIXED ENTRY POINT! This must not move!
   286                          
   287                          ;#########################################################################################################
   288                          
   289  e116 98                 INPUT_CHARACTER	TYA
   290  e117 48                 		PHA
   291  e118 8a                 		TXA
   292  e119 48                 		PHA
   293  e11a 6ce900             		JMP (SCRIV)	; Jump to Input from Screen routine (Vector normally points to DEFAULT_SCREEN_VECTOR)
   294                          
   295                          ;*********************************************************************************************************
   296                          ;** DEFAULT_SCREEN_VECTOR  [E11D]
   297                          ;** Input from Screen Routine
   298                          ;*********************************************************************************************************
   299                          
   300                          DEFAULT_SCREEN_VECTOR
   301  e11d a5ac               		LDA CRSW				; Flag: INPUT or GET from Keyboard
   302  e11f f09e               		BEQ GETLINE2
   303                          
   304                          ;		--------------------------------------- Screen Input
   305                          
   306  e121 a4c6               Screen_Input	LDY CursorCol				; Cursor Column on Current Line
   307  e123 b1c4               		LDA (ScrPtr),Y				; Pointer: Current Screen Line Address
   308  e125 85d9               		STA DATAX				; Current Character to Print
   309  e127 293f               		AND #$3f 				; '?'
   310  e129 06d9               		ASL DATAX				; Current Character to Print
   311  e12b 24d9               		BIT DATAX				; Current Character to Print
   312  e12d 1002               		BPL SI_SKIP1
   313  e12f 0980               		ORA #$80
   314  e131 9004               SI_SKIP1	BCC SI_SKIP2
   315  e133 a6cd               		LDX QuoteMode				; Flag: Editor in Quote Mode, $00 = NO
   316  e135 d004               		BNE SI_SKIP3
   317  e137 7002               SI_SKIP2	BVS SI_SKIP3
   318  e139 0940               		ORA #$40 				; '@'
   319  e13b e6c6               SI_SKIP3	INC CursorCol				; Cursor Column on Current Line
   320  e13d 206ae1             		JSR CheckQuote				; ?? Was: INCREASE_COL ??
   321  e140 c4a1               		CPY LastInputCol			; Pointer: End of Logical Line for INPUT
   322  e142 d017               		BNE SI_SKIP6
   323                          
   324                          ;		--------------------------------------- Screen Input 2
   325                          
   326  e144 a900               Screen_Input2	LDA #0
   327  e146 85ac               		STA CRSW				; Flag: INPUT or GET from Keyboard
   328  e148 a90d               		LDA #13
   329  e14a a6af               		LDX DFLTN				; Default Input Device (0)
   330  e14c e003               		CPX #3
   331  e14e f006               		BEQ SI_SKIP4
   332  e150 a6b0               		LDX DFLTO				; Default Output (CMD) Device (3)
   333  e152 e003               		CPX #3
   334  e154 f003               		BEQ SI_SKIP5
   335  e156 2002e2             SI_SKIP4	JSR CHROUT_SCREEN			; Output to Screen
   336  e159 a90d               SI_SKIP5	LDA #13
   337  e15b 85d9               SI_SKIP6	STA DATAX				; Current Character to Print
   338  e15d 68                 		PLA
   339  e15e aa                 		TAX
   340  e15f 68                 		PLA
   341  e160 a8                 		TAY
   342  e161 a5d9               		LDA DATAX				; Current Character to Print
   343  e163 c9de               		CMP #$de				; PI symbol
   344  e165 d002               		BNE SI_DONE
   345  e167 a9ff               		LDA #$ff				; replace with $FF (PI in alt set)
   346  e169 60                 SI_DONE 	RTS
   347                          
   348                          ;[E16A]		--------------------------------------- Check Quote Mode
   349                          
   350  e16a c922               CheckQuote	CMP #$22 				; Is it <QUOTE>?
   351  e16c d008               		BNE CQ_DONE				; No, we're done
   352  e16e a5cd               		LDA QuoteMode				; Flag: Editor in Quote Mode, $00 = NO
   353  e170 4901               		EOR #1					; toggle the BIT
   354  e172 85cd               		STA QuoteMode				; Flag: Editor in Quote Mode, $00 = NO
   355  e174 a922               		LDA #$22 				; reload the <QUOTE>
   356  e176 60                 CQ_DONE		RTS
   357                          
   358                          ;*********************************************************************************************************
   359                          ;** CHAR_TO_SCREEN  [E177]
   360                          ;** This puts a character in 'A' to screen. The character is handled differently according to the entry
   361                          ;** point. For example, when QUOTE mode is ON special characters are printed in RVS using CHAR_TO_SCREEN3
   362                          ;*********************************************************************************************************
   363                          
   364  e177 0940               CHAR_TO_SCREEN	ORA #$40 				; '@'
   365  e179 a69f               CHAR_TO_SCREEN2 LDX ReverseFlag				; Flag: Print Reverse Chars. -1=Yes
   366  e17b f002               		BEQ CTS_SKIP1
   367                          
   368  e17d 0980               CHAR_TO_SCREEN3	ORA #$80				; Toggle the upper bit (reverse characters)
   369                          
   370  e17f a6dc               CTS_SKIP1	LDX INSRT				; Flag: Insert Mode, >0 = # INSTs
   371  e181 f002               		BEQ CTS_SKIP2
   372  e183 c6dc               		DEC INSRT				; Flag: Insert Mode, >0 = # INSTs
   373                          CTS_SKIP2
   374                          
   375                          !IF COLOURPET=0 {
   376  e185 2006e6             		JSR RESTORE_CHR_AT_CRSR			; Put character on screen
   377                          } ELSE {
   378                          		JSR Put_ColourChar_at_Cursor		; Put character AND Colour on screen
   379                          }
   380                          ;		--------------------------------------- Handle screen wrap
   381                          
   382  e188 e6c6               		INC CursorCol				; Cursor Column on Current Line
   383  e18a a4d5               		LDY RightMargin				; Physical Screen Line Length
   384  e18c c4c6               		CPY CursorCol				; Is it at RIGHT margin?
   385  e18e b009               		BCS IRQ_EPILOG				; No, we're done
   386  e190 a6d8               		LDX CursorRow				; Yes, prepare to wrap to next line
   387  e192 20a3e3             CHAR_TO_SCREEN4	JSR CURSOR_DOWN				; Go to next line
   388  e195 a4e2               		LDY LeftMargin				; Get column for Left Margin of window
   389  e197 84c6               		STY CursorCol				; Set Cursor Column on Current Line
   390                          
   391                          ;*********************************************************************************************************
   392                          ;** IRQ_EPILOG  [E199]
   393                          ;** IRQ Completion. We jump here when printing is complete.
   394                          ;*********************************************************************************************************
   395                          
   396  e199 a900               IRQ_EPILOG	LDA #0
   397  e19b 85e8               		STA HOMECT				; Home Count
   398  e19d 68                 IRQ_EPILOG2 	PLA
   399  e19e a8                 		TAY
   400  e19f a5dc               		LDA INSRT				; Flag: Insert Mode, >0 = # INSTs
   401  e1a1 f002               		BEQ IRQE_SKIP
   402  e1a3 46cd               		LSR QuoteMode				; Flag: Editor in Quote Mode, $00 = NO
   403  e1a5 68                 IRQE_SKIP	PLA
   404  e1a6 aa                 		TAX
   405  e1a7 68                 		PLA
   406  e1a8 58                 		CLI					; Allow interrupts again
   407  e1a9 60                 		RTS
   408                          
   409                          ;*********************************************************************************************************
   410                          ;** CURSOR_TO_EOPL  [E1AA]
   411                          ;** Move Cursor to End of Previous Line
   412                          ;*********************************************************************************************************
   413                          
   414  e1aa a4d5               CURSOR_TO_EOPL	LDY RightMargin				; Physical Screen Line Length
   415  e1ac a6e0               		LDX TopMargin
   416  e1ae e4d8               		CPX CursorRow				; Current Cursor Physical Line Number
   417  e1b0 9008               		BCC CEPL_SKIP
   418  e1b2 a4e2               		LDY LeftMargin				; First column of window
   419  e1b4 84c6               		STY CursorCol				; Cursor Column on Current Line
   420  e1b6 68                 		PLA
   421  e1b7 68                 		PLA
   422  e1b8 d0df               		BNE IRQ_EPILOG
   423  e1ba c6d8               CEPL_SKIP	DEC CursorRow				; Current Cursor Physical Line Number
   424  e1bc 84c6               		STY CursorCol				; Cursor Column on Current Line
   425  e1be 4c67e0             		JMP UPDATE_CURSOR_ROW			; Set Screen Pointers
   426                          
   427                          ;*********************************************************************************************************
   428                          ;** ERASE_TO_ELO  [E1C1] 
   429                          ;** Erases from cursor to end of line
   430                          ;** Called from WIN_CLEAR. This routine is relocated/updated for COLOURPET
   431                          ;*********************************************************************************************************
   432                          
   433                          !IF COLOURPET=0 {
   434                          ERASE_TO_EOL
   435  e1c1 a920               		LDA #$20 				; <SPACE>
   436  e1c3 c8                 EEOL_LOOP	INY
   437  e1c4 91c4               		STA (ScrPtr),Y				; Pointer: Current Screen Line Address
   438  e1c6 c4d5               		CPY RightMargin
   439  e1c8 90f9               		BCC EEOL_LOOP
   440  e1ca 60                 		RTS
   441                          }
   442                          
   443                          ;*********************************************************************************************************
   444                          ;** CURSOR_TO_LM / ESCAPE_J  [E1CB]
   445                          ;** Move Cursor to Left Margin
   446                          ;*********************************************************************************************************
   447                          
   448                          ESCAPE_J
   449                          CURSOR_TO_LM
   450  e1cb a4e2               		LDY LeftMargin				; First column of window
   451  e1cd 84c6               		STY CursorCol				; Cursor Column on Current Line
   452  e1cf a000               		LDY #0
   453  e1d1 60                 		RTS
   454                          
   455                          ;*********************************************************************************************************
   456                          ;** FULL_SCREEN  [E1D2]
   457                          ;** Set Full Screen (Exit Window). This routine set the screen to full size.
   458                          ;** OPTIONS: 'COLUMNS' determines 40 or 80 column screen
   459                          ;**          'SS40'    when COLUMNS=80 uses col size determined by Soft40 'SCNWIDTH' memory location
   460                          ;** Note: Changing SCNWIDTH does not change CRTC parameters. Use the ESC-X command!!!
   461                          ;*********************************************************************************************************
   462                          
   463  e1d2 a900               FULL_SCREEN	LDA #0					; Top/Left=0
   464  e1d4 aa                 		TAX
   465  e1d5 20e1e1             		JSR WIN_SET_TOP				; Set Window Top
   466                          
   467  e1d8 a918               		LDA #ROWS-1				; Number of Hard-coded Screen Rows - Nomally 25 (0-24). 32+ for 8296 only
   468                          
   469                          !IF SS40=1 {	LDX SCNWIDTH				; Current SS40 screen width
   470  e1da a24f                  } ELSE {	LDX #COLUMNS-1 				; Hard-coded Screen Width (Normally 0-79)
   471                          }
   472                          
   473                          ;*********************************************************************************************************
   474                          ;** WIN_SET_BOT  [E1DC]
   475                          ;** Set Bottom Right Corner of Window
   476                          ;*********************************************************************************************************
   477                          
   478  e1dc 85e1               WIN_SET_BOT	STA BotMargin				; Last line of window
   479  e1de 86d5               		STX RightMargin				; Physical Screen Line Length
   480  e1e0 60                 		RTS
   481                          
   482                          ;*********************************************************************************************************
   483                          ;** WIN_SET_TOP  [E1E1]
   484                          ;** Set Top Left Corner of Window
   485                          ;*********************************************************************************************************
   486                          
   487  e1e1 85e0               WIN_SET_TOP	STA TopMargin				; First line of window
   488  e1e3 86e2               		STX LeftMargin				; First column of window
   489  e1e5 60                 		RTS
   490                          
   491                          ;*********************************************************************************************************
   492                          ;** CHROUT_SCREEN  [E202]  (Called from Jump Table)
   493                          ;** $E202 - FIXED ENTRY POINT! Some BASIC/KERNAL bypass the Jump Table and jump directly here
   494                          ;** Output Character to Screen Dispatch 
   495                          ;*********************************************************************************************************
   496                          
   497  e1e6 aaaaaaaaaaaaaaaa...		!IF NOFILL=0 { !FILL $e202-*,$aa }	; FIXED ENTRY POINT! This must not move!
   498                          
   499                          ;#########################################################################################################
   500                          
   501  e202 48                 CHROUT_SCREEN	PHA
   502  e203 85d9               		STA DATAX				; Current Character to Print
   503  e205 8a                 		TXA
   504  e206 48                 		PHA
   505  e207 98                 		TYA
   506  e208 48                 		PHA
   507  e209 6ceb00             		JMP (SCROV) 				; Via Screen Output Vector (normally 'CHROUT_NORMAL')
   508                          
   509                          ;*********************************************************************************************************
   510                          ;** CHROUT_NORMAL  [E20C]
   511                          ;** Output Character to Screen. Character to print must be in DATAX.
   512                          ;** SCROV vector normally points here
   513                          ;*********************************************************************************************************
   514                          
   515  e20c a900               CHROUT_NORMAL	LDA #0
   516  e20e 85ac               		STA CRSW				; Flag: INPUT or GET from Keyboard
   517                          
   518  e210 a4c6               		LDY CursorCol				; Cursor Column on Current Line
   519  e212 a5d9               		LDA DATAX				; Current Character to Print
   520  e214 297f               		AND #$7F				; Strip off top bit (REVERSE)
   521                          
   522                          ;[PATCH]	--------------------------------------- Check for ESC Character
   523                          
   524                          !IF ESCCODES=1 {
   525                          		JMP CheckESC				; Check for ESC as last Char, then ESC as current Char. If so, perform it.
   526                          ESC_DONE	STA LASTCHAR				; Save the character
   527                          
   528                          } ELSE {
   529  e216 c91b               		CMP #$1B				; <ESC>	key? **** Also SHIFT-ESC $9B (Conflicts with COLOUR CODE!)
   530  e218 d003               		BNE CHROUT_CHECK
   531  e21a 4cbde3             		JMP ESCAPE				; Cancel RVS/INS/QUOTE modes
   532                          }
   533                          ESC_DONE2
   534                          
   535                          ;[E21D]		--------------------------------------- Reload character and check high bit
   536                          
   537  e21d a5d9               CHROUT_CHECK	LDA DATAX				; Current Character to Print
   538                          !IF COLOURPET=1 { JSR CheckColourCodes }		; Check table of color values @@@@@@@@@@@@@@@@ COLOURPET
   539  e21f 1003               		BPL CHROUT_LO				; Is top bit CLEAR? Yes, handle UNSHIFTED Character
   540  e221 4cf4e2             		JMP CHROUT_HI				; No, Handle SHIFTED Character
   541                          
   542                          ;*********************************************************************************************************
   543                          ;** Character Output with High Bit CLEAR  [E224]
   544                          ;** This section checks characters in the range 0 to 127.
   545                          ;** UN-SHIFTED character have the HI BIT is CLEAR
   546                          ;*********************************************************************************************************
   547                          
   548                          ;		--------------------------------------- Check for RETURN
   549                          
   550  e224 c90d               CHROUT_LO	CMP #$0D 				; Is it <RETURN>?
   551  e226 d003               		BNE Be22b				; No, skip to next check
   552  e228 4cb6e3             		JMP CURSOR_RETURN			; Yes, Handle <RETURN>
   553                          
   554                          ;		--------------------------------------- Check for Control Codes Range (0-31)
   555                          
   556  e22b c920               Be22b		CMP #$20 				; <SPACE>
   557  e22d 9008               		BCC Be237 				; -> Control code
   558  e22f 293f               		AND #$3f 				; '?'
   559  e231 206ae1             		JSR CheckQuote				; Check For Quotes
   560  e234 4c79e1             		JMP CHAR_TO_SCREEN2			; -> Print to screen
   561                          
   562  e237 a6dc               Be237		LDX INSRT				; Flag: Insert Mode, >0 = # INSTs
   563  e239 f003               		BEQ Be23e				; Is FLAG=0? Yes, skip ahead
   564  e23b 4c7de1             		JMP CHAR_TO_SCREEN3			; -> Print reverse to screen
   565                          
   566                          ;		--------------------------------------- Check for DELETE
   567                          
   568  e23e c914               Be23e		CMP #$14 				; Is it <DEL>?
   569  e240 d020               		BNE Be262				; No, skip ahead
   570                          
   571                          ;		--------------------------------------- DELETE - Check if it would wrap to previous line
   572                          
   573  e242 a4e2               		LDY LeftMargin				; Get left margin
   574  e244 c4c6               		CPY CursorCol				; Is it cursor at left margin?
   575  e246 9005               		BCC Be24d				; No, skip ahead
   576  e248 20aae1             		JSR CURSOR_TO_EOPL			; Yes, move to previous line
   577  e24b d00f               		BNE Be25c				; Skip ahead if we are at the top line (Was: BPL Be25c)
   578                          
   579                          ;		--------------------------------------- Perform DELETE
   580                          
   581  e24d c6c6               Be24d		DEC CursorCol				; Move cursor one position to the LEFT
   582  e24f a4c6               		LDY CursorCol				; Get the new cursor position
   583                          
   584                          !IF COLOURPET=0 {
   585  e251 c8                 Be251		INY					; LOOP[
   586  e252 b1c4               		LDA (ScrPtr),Y				;   Read Character from Screen RAM
   587  e254 88                 		DEY					;   move to the left
   588  e255 91c4               		STA (ScrPtr),Y				;   Write Character to Screen RAM
   589  e257 c8                 		INY					;   Next column
   590  e258 c4d5               		CPY RightMargin				;   Is it at the Right margin?
   591  e25a d0f5               		BNE Be251				; ] No, so go back for more
   592                          } ELSE {
   593                          		JSR ColourPET_Scroll_Left		; Scroll both Screen and Colour LEFT	@@@@@@@@@@@@@@ ColourPET
   594                          }
   595                          
   596                          ;[E25C]		--------------------------------------- Entry point for "80240.PRG"
   597                          
   598  e25c a920               Be25c		LDA #$20 				; <SPACE>
   599  e25e 91c4               		STA (ScrPtr),Y				; put it on the screen!
   600                          !IF COLOURPET=1 {
   601                          		LDA COLOURV				; Get the current Colour	@@@@@@@@@@@@@@@ ColourPET
   602                          		STA (COLOURPTR),Y			; put it to Colour MEM		@@@@@@@@@@@@@@@ ColourPET
   603                          }
   604  e260 d037               		BNE Be299
   605                          
   606  e262 a6cd               Be262		LDX QuoteMode				; Flag: Editor in Quote Mode, $00 = NO
   607  e264 f003               		BEQ Be269				; Quote mode OFF, so we need to action the character
   608  e266 4c7de1             		JMP CHAR_TO_SCREEN3			; Quote mode ON, so we need to print the QUOTEMODE version
   609                          
   610                          ;		--------------------------------------- Check for RVS
   611                          
   612  e269 c912               Be269		CMP #$12 				; Is it <RVS>?
   613  e26b d002               		BNE Be26f				; No, skip ahead
   614  e26d 859f               		STA ReverseFlag				; Yes, Set RVS flag
   615                          
   616                          ;		--------------------------------------- Check for HOME and HOME-HOME
   617                          
   618  e26f c913               Be26f		CMP #$13 				; Is it <HOME>?
   619  e271 d010               		BNE Be283				; No, skip ahead
   620  e273 a5e8               		LDA HOMECT 				; Is Home Count=0 (<HOME><HOME> sets window to full screen)
   621  e275 1004               		BPL Be27b				; Yes, skip ahead
   622  e277 20d2e1             		JSR FULL_SCREEN				; Set to full screen (remove any window)
   623  e27a 18                 		CLC
   624  e27b 66e8               Be27b		ROR HOMECT				; Reset Home Count
   625  e27d 205fe0             		JSR CURSOR_HOME				; Home the cursor
   626  e280 4c9de1             		JMP IRQ_EPILOG2
   627                          
   628                          ;		--------------------------------------- Check for CURSOR RIGHT
   629                          
   630  e283 c91d               Be283		CMP #$1d 				; Is it <CURSOR RIGHT>?
   631  e285 d00b               		BNE Be292				; No, skip ahead
   632  e287 c8                 		INY					; Yes, increment column
   633  e288 84c6               		STY CursorCol				; Update Column
   634  e28a 88                 		DEY					; Go back
   635  e28b c4d5               		CPY RightMargin				; Is it at Right Margin?
   636  e28d 900a               		BCC Be299				; No, skip ahead
   637  e28f 4c92e1             		JMP CHAR_TO_SCREEN4			; Yes
   638                          
   639                          ;		--------------------------------------- Check for CURSOR DOWN
   640                          
   641  e292 c911               Be292		CMP #$11 				; Is it <CURSOR DOWN>?
   642  e294 d006               		BNE Be29c				; No, skip ahead
   643  e296 20a3e3             		JSR CURSOR_DOWN				; Go to next line
   644  e299 4c99e1             Be299		JMP IRQ_EPILOG
   645                          
   646                          ;		--------------------------------------- Check for TAB
   647                          
   648  e29c c909               Be29c		CMP #9 					; Is it <TAB>?
   649  e29e d030               		BNE Be2d0				; No, skip to next check (see [BUG?]
   650                          
   651  e2a0 2074e5             		JSR JUMP_TO_TAB				; Perform <TAB>
   652  e2a3 ac3a03             Be2a3		LDY NextTab				; LOOP[
   653  e2a6 ee3a03             		INC NextTab
   654  e2a9 c4d5               		CPY RightMargin				;   Physical Screen Line Length
   655  e2ab 9009               		BCC Be2b6				;   
   656  e2ad a5d5               		LDA RightMargin				;   Physical Screen Line Length
   657  e2af 85c6               		STA CursorCol				;   Cursor Column on Current Line
   658  e2b1 ce3a03             		DEC NextTab				;   temp var
   659  e2b4 d0e3               		BNE Be299				;   Exit
   660  e2b6 0e3e03             Be2b6		ASL DOS_Syntax				;   temp var
   661  e2b9 d00a               		BNE Be2c5
   662  e2bb e8                 		INX
   663  e2bc e00a               		CPX #10					;   Have we reached end of tab table?
   664  e2be f0d9               		BEQ Be299				;   Yes, so no tab found. Exit.
   665  e2c0 a901               		LDA #1
   666  e2c2 8d3e03             		STA DOS_Syntax				;   temp var
   667  e2c5 bdee03             Be2c5		LDA TABS_SET,X				;   Get TAB from table
   668  e2c8 2d3e03             		AND DOS_Syntax				;   temp var
   669  e2cb f0d6               		BEQ Be2a3				; ]LOOP
   670  e2cd c8                 		INY
   671  e2ce 84c6               		STY CursorCol				; Set cursor column to new position
   672                          
   673                          ;[BUG?]		Why does this routine drop into the CTRL-V check? It should do JMP IRQ_EPILOG here
   674                          
   675                          ;[E2D0]		--------------------------------------- Check for Erase to End of line
   676                          
   677  e2d0 c916               Be2d0		CMP #$16 				; Is it <Ctrl V>? - Erase to EOL? NOTE: 40-col code has BUG here
   678  e2d2 d00c               		BNE Be2e0				; No, skip ahead
   679                          
   680                          ;[E2D4]		--------------------------------------- Erase to End of Line
   681                          
   682  e2d4 a920               		LDA #$20				; <SPACE>
   683  e2d6 88                 		DEY
   684                          
   685  e2d7 c8                 Be2d7		INY
   686  e2d8 91c4               		STA (ScrPtr),Y				; Write it to the screen
   687                          !IF COLOURPET=1 {
   688                          		PHA
   689                          		LDA COLOURV				; Current Colour		@@@@@@@@@@@@@@ COLOURPET
   690                          		STA (COLOURPTR),Y			; Write it to Colour RAM	@@@@@@@@@@@@@@ COLOURPET
   691                          		PLA
   692                          }
   693  e2da c4d5               		CPY RightMargin				; are we at right margin?
   694  e2dc 90f9               		BCC Be2d7
   695                          
   696  e2de b0b9               		BCS Be299
   697                          
   698                          ;[E2E0]		--------------------------------------- Check for Delete Line
   699                          ;
   700                          
   701  e2e0 c915               Be2e0		CMP #$15				; Is it <Ctrl U>? - DELETE LINE
   702  e2e2 f003               		BEQ DELETE_LINE				; Yes, go do it
   703  e2e4 4c95e5             		JMP Scroll_Or_Select_Charset		; No, skip ahead
   704                          
   705                          ;[E2E7]		--------------------------------------- Delete Line
   706                          
   707                          ESCAPE_D						; Esc-d Delete Line
   708                          DELETE_LINE
   709  e2e7 a5e0               		LDA TopMargin				; Top Line of Window
   710  e2e9 48                 		PHA
   711  e2ea a5d8               		LDA CursorRow				; Current Cursor Physical Line Number
   712  e2ec 85e0               		STA TopMargin				; Top Line of Window
   713  e2ee 20e8e3             		JSR WIN_SCROLL_UP			; Scroll window up
   714  e2f1 4ccee5             		JMP Me5ca
   715                          
   716                          ;*********************************************************************************************************
   717                          ;** CHROUT_HI  [E2F4]
   718                          ;** Character Output when High Bit SET (characters in the range 128 to 255).
   719                          ;** Handles: RETURN,INS,CRSR-UP,
   720                          ;*********************************************************************************************************
   721                          
   722  e2f4 297f               CHROUT_HI	AND #$7f				; strip off top bit
   723  e2f6 c97f               		CMP #$7f				; special case: code for PI (7F)
   724  e2f8 d002               		BNE COH_SKIP1
   725  e2fa a95e               		LDA #$5e 				; replace with screen code 5E
   726                          
   727  e2fc c920               COH_SKIP1	CMP #$20 				; Is it a Control Character?
   728  e2fe 9003                          	BCC COH_SKIP2				; Yes, skip ahead to check
   729  e300 4c77e1                        	JMP CHAR_TO_SCREEN			; No, so just jump to print it as-is
   730                          
   731                          ;		--------------------------------------- Check for SHIFT-RETURN
   732                          
   733  e303 c90d               COH_SKIP2     	CMP #$0D 				; Is it <SHIFT><RETURN>?
   734  e305 d003                          	BNE COH_SKIP3				; No, skip ahead
   735  e307 4cb6e3             		JMP CURSOR_RETURN			; Yes, handle it
   736                          
   737                          ;		--------------------------------------- Check Quote Mode
   738                          
   739  e30a a6cd               COH_SKIP3	LDX QuoteMode				; Is QUOTE MODE on?
   740  e30c d034               		BNE COH_SKIP6				; No, skip ahead
   741                          
   742                          ;		--------------------------------------- Check for INSERT
   743                          
   744  e30e c914               		CMP #$14 				; Is it <INS>? (Shift-DEL)
   745  e310 d02c                          	BNE COH_SKIP5				; No, skip ahead
   746                          
   747                          ;		--------------------------------------- Check if INSERT is possible
   748                          
   749  e312 a4d5               CHECK_INSERT	LDY RightMargin				; Right margin
   750  e314 b1c4                          	LDA (ScrPtr),Y				; Read the character at the end of the line
   751  e316 c920                          	CMP #$20 				; Is it <SPACE>?
   752  e318 d072               		BNE Be38c				; No, so no room to insert. Skip ahead
   753                          
   754  e31a c4c6               COH_SKIP4	CPY CursorCol				; There is a space, but are we at end of line?
   755  e31c 906e               		BCC Be38c				; Yes, so cancel insert
   756  e31e f06c               		BEQ Be38c				; Yes, so cancel insert
   757                          
   758                          ;		---------------------------------------- Do INSERT
   759                          
   760  e320 a4d5               DO_INSERT	LDY RightMargin
   761                          
   762                          !IF COLOURPET=0 {
   763  e322 88                 INS_LOOP1	DEY
   764  e323 b1c4               		LDA (ScrPtr),Y				; Read it from the Screen
   765  e325 c8                 		INY
   766  e326 91c4               		STA (ScrPtr),Y				; Write it to the Screen
   767  e328 88                 		DEY
   768  e329 c4c6               		CPY CursorCol
   769  e32b d0f5               		BNE INS_LOOP1
   770                          } ELSE {
   771                          		JSR ColourPET_Insert
   772                          }
   773  e32d a920               		LDA #$20 				; <SPACE>
   774  e32f 91c4               		STA (ScrPtr),Y				; Write it to the Screen
   775                          
   776  e331 a5d5               		LDA RightMargin				; Physical Screen Line Length
   777  e333 38                 		SEC
   778  e334 e5c6               		SBC CursorCol				; Cursor Column on Current Line
   779  e336 e5dc               		SBC INSRT				; Flag: Insert Mode, >0 = # INSTs
   780  e338 3052               		BMI Be38c
   781  e33a e6dc               		INC INSRT				; Flag: Insert Mode, >0 = # INSTs
   782  e33c d04e               		BNE Be38c
   783                          
   784                          ;		--------------------------------------- Check for INSERT in QUOTE MODE
   785                          
   786  e33e a6dc               COH_SKIP5	LDX INSRT				; Flag: Insert Mode, >0 = # INSTs
   787  e340 f005               		BEQ COH_CHECK1
   788                          
   789  e342 0940               COH_SKIP6	ORA #$40 				; '@'
   790  e344 4c7de1             		JMP CHAR_TO_SCREEN3
   791                          
   792                          ;		--------------------------------------- Check for CURSOR UP
   793                          
   794  e347 c911               COH_CHECK1	CMP #$11 				; Is it <CRSR-UP>? (SHIFT-CRSR-DOWN)
   795  e349 d00d               		BNE Be358				; No, skip ahead
   796                          
   797                          ;		--------------------------------------- Do Cursor UP
   798  e34b a6e0               		LDX TopMargin
   799  e34d e4d8               		CPX CursorRow
   800  e34f b03b               		BCS Be38c	
   801  e351 c6d8               		DEC CursorRow
   802  e353 2067e0             		JSR UPDATE_CURSOR_ROW
   803  e356 d034               		BNE Be38c
   804                          
   805                          ;		--------------------------------------- Check for RVS OFF
   806                          
   807  e358 c912               Be358		CMP #$12 				; Is it <OFF>?  (SHIFT-RVS)
   808  e35a d004               		BNE Be360				; No, skip ahead
   809  e35c a900               		LDA #0					; Set RVS OFF
   810  e35e 859f               		STA ReverseFlag				; Store it
   811                          
   812                          ;		--------------------------------------- Check for CURSOR LEFT
   813                          
   814  e360 c91d               Be360		CMP #$1d 				; Is it <LEFT>? (Shift-Cursor RIGHT)
   815  e362 d00f               		BNE Be373				; No, skip ahead
   816  e364 a4e2               		LDY LeftMargin			
   817  e366 c4c6               		CPY CursorCol				; Are we at the left margin already?
   818  e368 9005               		BCC Be36f 				; No, skip ahead         	@@@@@@@@@@@@@@@ was: BNE $E38C
   819  e36a 20aae1             		JSR CURSOR_TO_EOPL			; Yes, go to end previous line
   820  e36d d01d               		BNE Be38c				;				@@@@@@@@@@@@@@@ was: BPL Be38c
   821  e36f c6c6               Be36f		DEC CursorCol				; Move one position LEFT
   822  e371 1019               		BPL Be38c				;				@@@@@@@@@@@@@@@ was: BNE Be38c
   823                          
   824                          ;		--------------------------------------- Check for CLEAR SCREEN
   825                          
   826  e373 c913               Be373		CMP #$13 				; Is it <CLR>? (SHIFT-HOME)
   827  e375 d005               		BNE Be37c				; No, skip ahead
   828  e377 2051e0             		JSR WIN_CLEAR				; Yes, clear the screen/window
   829  e37a d010               		BNE Be38c				; Finish Up
   830                          
   831                          ;		--------------------------------------- Check for SET TAB
   832                          
   833  e37c c909               Be37c		CMP #9 					; Is it <SET-TAB>? (SHIFT-TAB)
   834  e37e d00f               		BNE Be38f				; No, skip ahead
   835                          
   836                          ;		--------------------------------------- Set a TAB STOP HERE
   837                          
   838  e380 2074e5             		JSR JUMP_TO_TAB
   839  e383 bdee03             		LDA TABS_SET,X
   840  e386 4d3e03             		EOR DOS_Syntax
   841  e389 9dee03             		STA TABS_SET,X
   842  e38c 4c99e1             Be38c		JMP IRQ_EPILOG
   843                          
   844                          ;		--------------------------------------- Check for ERASE TO START OF LINE
   845                          
   846  e38f c916               Be38f		CMP #$16 				; Is it <SHIFT>CTRL-V?  (Conflicts with COLOURPET!
   847                          !IF COLOURPET=0 {
   848  e391 f003               		BEQ ERASE_TO_SOL			; Remove Conflict			
   849                          }
   850  e393 4cc0e5             		JMP ProcControl_A
   851                          
   852                          ;*********************************************************************************************************
   853                          ;** ERASE_TO_SOL / ESCAPE_P [E396]
   854                          ;** Erases from cursor to Start of Line
   855                          ;*********************************************************************************************************
   856                          
   857                          ESCAPE_P
   858  e396 a920               ERASE_TO_SOL	LDA #$20 				; <SPACE>
   859  e398 a4e2               		LDY LeftMargin				; Start at Left Margin
   860  e39a c4c6               ESOL_LOOP	CPY CursorCol				; LOOP[ Have we reached the cursor position?
   861  e39c b0ee               		BCS Be38c				;   Yes, skip ahead
   862  e39e 91c4               		STA (ScrPtr),Y				;   No, Write it to the screen
   863                          !IF COLOURPET=1 {
   864                          		LDA COLOURV				;   Current Colour
   865                          		STA (COLOURPTR),Y			;   Write Current Colour to colour RAM
   866                          }
   867  e3a0 c8                 		INY					;   Move to next column
   868  e3a1 d0f7               		BNE ESOL_LOOP				; ] Loop back for more
   869                          
   870                          ;*********************************************************************************************************
   871                          ;** CURSOR_DOWN [E3A3]
   872                          ;** Do Cursor DOWN, Go to next line. If at bottom of window SCROLL UP.
   873                          ;*********************************************************************************************************
   874                          
   875  e3a3 46a3               CURSOR_DOWN	LSR InputRow
   876  e3a5 a6d8               		LDX CursorRow
   877  e3a7 e4e1               		CPX BotMargin
   878  e3a9 9006               		BCC Be3b1
   879  e3ab 20e8e3             		JSR WIN_SCROLL_UP
   880  e3ae 4c67e0             		JMP UPDATE_CURSOR_ROW
   881  e3b1 e6d8               Be3b1		INC CursorRow
   882  e3b3 4c67e0             		JMP UPDATE_CURSOR_ROW
   883                          
   884                          ;*********************************************************************************************************
   885                          ;** CURSOR_RETURN [E3B6]
   886                          ;** Cursor to start of line, then CURSOR DOWN. Also performs ESCAPE
   887                          ;*********************************************************************************************************
   888                          
   889  e3b6 a4e2               CURSOR_RETURN	LDY LeftMargin
   890  e3b8 84c6               		STY CursorCol
   891  e3ba 20a3e3             		JSR CURSOR_DOWN
   892                          
   893                          ;*********************************************************************************************************
   894                          ;** ESCAPE / ESCAPE_O [E3BD]
   895                          ;** Cancels Insert, Reverse and Quote modes
   896                          ;*********************************************************************************************************
   897                          
   898                          ESCAPE_O
   899  e3bd a900               ESCAPE		LDA #0
   900  e3bf 85dc               		STA INSRT
   901  e3c1 859f               		STA ReverseFlag
   902  e3c3 85cd               		STA QuoteMode
   903                          
   904                          !IF ESCCODES = 1 { STA LASTCHAR }
   905                          
   906  e3c5 4c99e1             		JMP IRQ_EPILOG
   907                          
   908                          ;*********************************************************************************************************
   909                          ;** WIN_SCROLL_DN / ESCAPE_W  [E3C8] (Called from Jump Table)
   910                          ;** Scrolls the current Window DOWN 
   911                          ;*********************************************************************************************************
   912                          
   913                          ESCAPE_W
   914  e3c8 a6e1               WIN_SCROLL_DN	LDX BotMargin
   915  e3ca e8                 		INX
   916  e3cb ca                 Be3cb		DEX
   917  e3cc 206ce0             		JSR UPDATE_CURSOR_R2			;@@@@@@@@@@ was: JSR CURSOR_LM	; Was: Cursor_BOL
   918  e3cf e4e0               		CPX TopMargin
   919  e3d1 f035               		BEQ Be3fe
   920                          
   921                          !IF COLOURPET=0 {
   922                          	!IF SS40=0 {
   923  e3d3 bd54e7             		LDA Line_Addr_Lo-1,X    		; Screen Line address table LO - 1
   924  e3d6 85c7               		STA SAL					; Pointer: Tape Buffer/ Screen Scrolling
   925  e3d8 bd6de7             		LDA Line_Addr_Hi-1,X 			; Screen Line address table HI - 1
   926  e3db 85c8               		STA SAL+1
   927                          	} ELSE {
   928                          		JSR SS40_SyncPointers2
   929                          	}
   930                          } ELSE {
   931                          		JSR ColourPET_SyncPointers2 		; Synchronize Pointers	@@@@@@@@@@@@@@@ COLOURPET
   932                          }
   933                          
   934  e3dd c8                 Be3d8		INY
   935                          !IF COLOURPET=0 {
   936                          
   937  e3de b1c7               		LDA (SAL),Y				; Read Character from Screen SOURCE
   938  e3e0 91c4               		STA (ScrPtr),Y				; Write it to Screen DESTINATION
   939                          } ELSE {
   940                          		JSR ColourPET_Scroll_Dest
   941                          }
   942  e3e2 c4d5               		CPY RightMargin
   943  e3e4 90f7               		BCC Be3d8
   944  e3e6 b0e3               		BCS Be3cb
   945                          
   946                          ;*********************************************************************************************************
   947                          ;** WIN_SCROLL_UP / ESCAPE_V  [E3E8] (Called from Jump Table)
   948                          ;** Scrolls current Window UP 
   949                          ;*********************************************************************************************************
   950                          
   951                          ESCAPE_V						; ESC-V Scroll Up
   952                          WIN_SCROLL_UP
   953  e3e8 a6e0               		LDX TopMargin
   954  e3ea ca                 		DEX
   955  e3eb e8                 Be3e6		INX
   956  e3ec 206ce0             		JSR UPDATE_CURSOR_R2			;@@@@@@@@@@@@@@ was: CURSOR_LM			; Was: Cursor_BOL
   957  e3ef e4e1               		CPX BotMargin
   958  e3f1 b015               		BCS Be3fe
   959                          
   960                          !IF COLOURPET=0 {
   961                          	!IF SS40=0 {	
   962  e3f3 bd56e7             		LDA Line_Addr_Lo+1,X			; Screen line address table LO + 1
   963  e3f6 85c7               		STA SAL					; Pointer: Tape Buffer/ Screen Scrolling
   964  e3f8 bd6fe7             		LDA Line_Addr_Hi+1,X			; Screen line address table HI + 1
   965  e3fb 85c8               		STA SAL+1				; Pointer: Tape Buffer/ Screen Scrolling
   966                          	} ELSE {
   967                          		JSR SS40_SyncPointers
   968                          	}
   969                          } ELSE {
   970                          		JSR ColourPET_SyncPointers		; Synchronize Pointers	@@@@@@@@@@@@@@@ COLOURPET
   971                          }
   972                          
   973  e3fd c8                 Be3f3		INY
   974                          !IF COLOURPET=0 {
   975  e3fe b1c7               		LDA (SAL),Y				; Read Character from Screen SOURCE
   976  e400 91c4               		STA (ScrPtr),Y				; Write to Screen DESTINATION
   977                          } ELSE {
   978                          		JSR ColourPET_Scroll_Dest		; Scroll Character and Colour RAM	
   979                          }
   980  e402 c4d5               		CPY RightMargin
   981  e404 90f7               		BCC Be3f3
   982  e406 b0e3               		BCS Be3e6
   983                          
   984  e408 20c1e1             Be3fe		JSR ERASE_TO_EOL			; Clear the bottom line
   985                          
   986                          ;*********************************************************************************************************
   987                          ;** Check Keyboard Scroll Control E40B]
   988                          ;*********************************************************************************************************
   989                          

; ******** Source: scrollpause-b.asm
     1                          ; PET/CBM EDIT ROM - Scroll Pause/Resume Control - B
     2                          ; ================
     3                          
     4                          ;--------------- Check Keyboard Scroll Control
     5                          
     6  e40b ad12e8             iE40B		LDA PIA1_Port_B		; PIA#1, Register 2 - Keyboard COL input
     7  e40e c9fe               iE40E		CMP #$FE        	; Is BIT 0 set? ie: key held down?
     8  e410 d00e               iE410		BNE iE420       	; no, skip scroll delay loop
     9                          
    10                          ;--------------- Scroll Delay and Pause
    11                          
    12  e412 a000               iE412		LDY #$00       		; Scroll delay
    13  e414 ea                 iE414		NOP
    14  e415 ca                 		DEX
    15  e416 d0fc               		BNE iE414       	; Loop back
    16  e418 88                 		DEY
    17  e419 d0f9               		BNE iE414       	; Loop back
    18                          
    19  e41b a000               iE41B		LDY #$00        	; Clear keyboard buffer
    20  e41d 849e               		STY CharsInBuffer	; No. of Chars. in Keyboard Buffer (Queue)
    21  e41f 60                 iE41F		RTS
    22                          
    23  e420 c9df               iE420		CMP #$DF        	; Is BIT 1 set? key held down?
    24  e422 d0fb               		BNE iE41F       	; no, return
    25  e424 ad12e8             iE424		LDA PIA1_Port_B		; PIA#1, Register 2 - Keyboard ROW input
    26  e427 c9df               		CMP #$DF        	; Is BIT 1 set? key held down?
    27  e429 f0f9               		BEQ iE424       	; yes, loop back
    28  e42b c9ff               		CMP #$FF        	; no keys?
    29  e42d f0f5               		BEQ iE424       	; yes, loop back
    30  e42f d0ea               		BNE iE41B       	; return back up to clear buffer

; ******** Source: editrom80.asm
   990                          
   991                          
   992                          ;*********************************************************************************************************
   993                          ;** Jiffy Clock Timer Correction Patch [E431]
   994                          ;*********************************************************************************************************
   995                          

; ******** Source: jiffyfix.asm
     1                          ; PET/CBM EDIT ROM - Jiffy Clock Timer Fix
     2                          ; ================
     3                          
     4                          ;************** Correct Jiffy Clock Timer
     5                          ; Patch for 50 Hz
     6                          ; TODO: Analyze JIFFY CLOCK differences from older ROMs
     7                          ; TODO: make selectable
     8                          
     9                          !if CODEBASE<2 {
    10                          ADVANCE_TIMER
    11  e431 20eaff             		JSR UDTIME			; Update System Jiffy Clock. KERNAL routine $FFEA
    12  e434 e6f8               		INC JIFFY6DIV5			; Counter to speed TI by 6/5
    13  e436 a5f8               		LDA JIFFY6DIV5			; Counter to speed TI by 6/5
    14  e438 c906               		CMP #$06			; every 6 IRQ's
    15  e43a d01c               		BNE IRQ_NORMAL2			; no, jump back to IRQ routine
    16  e43c a900               		LDA #$00      			; yes, reset counter
    17  e43e 85f8               		STA JIFFY6DIV5			; Counter to speed TI by 6/5
    18  e440 f0ef               		BEQ ADVANCE_TIMER		; re-do jiffy clock update
    19                          } ELSE {
    20                          
    21                          ADVANCE_TIMER_CORR
    22                          		LDA #6
    23                          		STA JIFFY6DIV5
    24                          ADVANCE_TIMER
    25                          		JSR ADVANCE_JIFFY_CLOCK		; In EDITROMEXT file
    26                          		DEC JIFFY6DIV5
    27                          		BEQ ADVANCE_TIMER_CORR
    28                          		RTS
    29                          }

; ******** Source: editrom80.asm
   996                          
   997                          
   998                          ;*********************************************************************************************************
   999                          ;** MAIN IRQ ENTRY [E442][E455] (Called from Jump Table) - FIXED ENTRY POINT!
  1000                          ;** This entry point must not move! It is called directly from KERNAL
  1001                          ;** The CRTC chip's V-Sync line is fed to a VIA to generate IRQ's. When an IRQ is triggered, the
  1002                          ;** Clock is updated, the keyboard scanned, ieee polled and tape monitored.
  1003                          ;*********************************************************************************************************
  1004                          
  1005                          		!IF NOFILL=0 { !FILL $e442-*,$aa }	; FIXED ENTRY POINT! This routine must not move!
  1006                          
  1007                          ;#########################################################################################################
  1008                          

; ******** Source: irq.asm
     1                          ; PET/CBM EDIT ROM - IRQ Handler Routines
     2                          ; ================
     3                          ; The IRQ does the work of updating the clock/timer, checking interrupts and calling the keyboard scanner.
     4                          
     5                          
     6                          IRQ_MAIN
     7  e442 48                 		PHA
     8  e443 8a                 		TXA
     9  e444 48                 		PHA
    10  e445 98                 		TYA
    11  e446 48                 		PHA
    12  e447 ba                 		TSX
    13  e448 bd0401             		LDA STACK+4,X
    14  e44b 2910               		AND #16
    15  e44d f003               		BEQ Be452
    16  e44f 6c9200             		JMP (CBINV)	; Vector: BRK Instr. Interrupt [D478]
    17  e452 6c9000             Be452		JMP (CINV)	; Vector: Hardware Interrupt   [E455] Points to 'IRQ_NORMAL'
    18                          
    19                          ;*********************************************************************************************************
    20                          ;** IRQ_NORMAL [$E455]
    21                          ;*********************************************************************************************************
    22                          
    23                          ;************** IRQ (Called from Jump Table)
    24                          ; The IRQ is fired when the CRTC chip does a VSYNC, so the timing is
    25                          ; dependent on the CRTC configuration.
    26                          ; Normally: $E455
    27                          
    28                          IRQ_NORMAL
    29                          		!IF IRQFIX=1 {
    30                          			!IF CODEBASE=0 { JMP ADVANCE_TIMER }
    31                          			!IF CODEBASE=1 { JMP ADVANCE_TIMER }
    32                          			!IF CODEBASE=2 { JSR ADVANCE_TIMER }
    33                          		} ELSE {
    34  e455 20eaff             			JSR UDTIME			; Update System Jiffy Clock. KERNAL routine $FFEA 			
    35                          		}
    36                          
    37                          ;		--------------------------------------- Blink the cursor
    38                          
    39                          IRQ_NORMAL2						; ie458
    40  e458 a5a7               		LDA Blink				; Cursor Blink enable: 0 = Flash Cursor
    41  e45a d018               		BNE Be474				; skip it
    42  e45c c6a8               		DEC BLNCT				; Timer: Countdown to Toggle Cursor
    43  e45e d014               		BNE Be474				; skip it
    44                          
    45  e460 a914               		LDA #$14				; default cursor blink rate (20)
    46                          !if REPEATOPT = 1 {
    47                          		BIT RPTFLG				; check repeat flag
    48                          		BPL ie468				; skip if not enabled
    49                          		LDA #2					; make cursor blink immediately
    50                          }
    51  e462 85a8               ie468		STA BLNCT				; store to blink countdown counter
    52  e464 a4c6               		LDY CursorCol				; Column where cursor lives
    53  e466 46aa               		LSR BlinkPhase				; Is it blinking?
    54  e468 b1c4               		LDA (ScrPtr),Y				; Get character from the screen
    55  e46a b004               		BCS Be470				; Yes, skip
    56  e46c e6aa               		INC BlinkPhase				; count
    57  e46e 85a9               		STA CursorChar				; Remember the character at cursor (to be restored when cursor moves)
    58  e470 4980               Be470		EOR #$80				; Flip the reverse bit
    59  e472 91c4               		STA (ScrPtr),Y				; Put it back on the screen
    60                          
    61                          ;		--------------------------------------- Prep for keyboard scanning [$E47B]
    62                          
    63  e474 a000               Be474		LDY #0
    64  e476 ad10e8             		LDA PIA1_Port_A 			; Keyboard ROW select - PIA#1, Register 0
    65                          							; Upper bits: IEEE and Cassette
    66                          							; Lower bits: Keyboard ROW select
    67                          !if CODEBASE<2 {
    68  e479 29f0               		AND #$F0				; Mask off lower 4 bits (reset keyboard scan row)
    69  e47b 8d10e8             		STA PIA1_Port_A				; Keyboard ROW select - PIA#1, Register 0				CHIP
    70  e47e ad10e8             		LDA PIA1_Port_A				; Keyboard ROW select - PIA#1, Register 0				CHIP
    71                          } 
    72                          
    73                          ;		--------------------------------------- Check IEEE and Cassette status
    74                          
    75  e481 0a                 		ASL					; Shift upper bits to lower 
    76  e482 0a                 		ASL 
    77  e483 0a                 		ASL 
    78  e484 1009               		BPL Be487				; Is CASSETTE#1 Sense? No, skip
    79                          
    80  e486 84f9               		STY CAS1				; Yes, Tape Motor Interlock #1
    81  e488 ad13e8             		LDA PIA1_Cont_B				; PIA#1 Register 13 (Retrace flag and interrupt
    82  e48b 0908               		ORA #8					; Is CASSETTE#2 Sense?
    83  e48d d009               		BNE Be490				; No, skip
    84                          
    85  e48f a5f9               Be487		LDA CAS1				; Yes, Tape Motor Interlock #1
    86  e491 d008               		BNE Be493				; No, skip
    87                          
    88  e493 ad13e8             		LDA PIA1_Cont_B				; PIA#1 Register 13 (Retrace flag and interrupt)
    89  e496 29f7               		AND #$f7				; Mask off bit 4
    90  e498 8d13e8             Be490		STA PIA1_Cont_B				; PIA#1 Register 13 (Retrace flag and interrupt)
    91  e49b 9009               Be493		BCC Be49e
    92                          
    93  e49d 84fa               		STY CAS2				; Tape Motor Interlock #2
    94  e49f ad40e8             		LDA VIA_Port_B				; VIA Register 0 (flags)
    95  e4a2 0910               		ORA #16
    96  e4a4 d009               		BNE Be4a7
    97  e4a6 a5fa               Be49e		LDA CAS2				; Tape Motor Interlock #2
    98  e4a8 d008               		BNE Be4aa
    99  e4aa ad40e8             		LDA VIA_Port_B				; VIA Register 0 (flags)
   100  e4ad 29ef               		AND #$ef
   101  e4af 8d40e8             Be4a7		STA VIA_Port_B				; VIA Register 0 (flags)
   102  e4b2 20b8e4             Be4aa		JSR SCAN_KEYBOARD			; Scan the keyboard
   103                          
   104                          !IF KEYRESET=1 {  JSR CheckReboot }			; Check for soft reset ******* should this go above Be474 ?????????????????
   105                          
   106  e4b5 4c00e6             		JMP IRQ_END				; Return from Interrupt
   107                          

; ******** Source: editrom80.asm
  1009                          
  1010                          ;!IF DEBUG=0 { !FILL $e4be-*,$aa }			;#################################################
  1011                          
  1012                          ;*********************************************************************************************************
  1013                          ;** KEYBOARD SCANNER  [E4BE]
  1014                          ;** The Keyboard is scanned during the IRQ and one keystroke is stored to KEYD. Other routines transfer
  1015                          ;** this keystroke to or from a small 10-byte buffer. The keyboard scanner does the actual interfacing to
  1016                          ;** the hardware to read the rows and columns of the keyboard matrix. When a key is pressed it gets the
  1017                          ;** keycode from the keyboard matrix table. If no key is pressed, then $FF is returned.
  1018                          ;*********************************************************************************************************
  1019                          
  1020                          !IF KEYSCAN=0 { !SOURCE "keyscan-g.asm" }		; Graphic Keyboard

; ******** Source: keyscan-b.asm
     1                          ; PET/CBM EDIT ROM - Keyboard Scan - Business Keyboards
     2                          ; ================
     3                          ; Standard Business Keyboard scanner. Requires one keyboard table.
     4                          ;
     5                          ; OPTIONS: KEYBOARD=7 modifies scanner for CBM-II keyboard (16x6 matrix)
     6                          
     7                          ;--------------- Scan Keyboard (scnkey)
     8                          ; NOTE: The keyboard ROW select is reset to zero in IRQ routine
     9                          
    10                          SCAN_KEYBOARD
    11                          ;!if DEBUG = 1 { INC DBLINE+5 }		; DEBUG - 6th character on top line
    12                          
    13  e4b8 a0ff               		LDY #$FF		; No Key
    14  e4ba 84a6               		STY Key_Image		; Key Image
    15  e4bc c8                 		INY
    16  e4bd 8498               		STY KEYFLAGS		; Store 0 in KEYFLAGS
    17  e4bf a5e4               		LDA RPTFLG		; Get Repeat Flag     : REPEAT Key Used, $80 = Repeat, $40 = disable
    18  e4c1 297f               		AND #$7F		; Clear HI bit - Turn off Repeat Mode
    19  e4c3 85e4               		STA RPTFLG		; Write it back       : REPEAT Key Used, $80 = Repeat, $40 = disable
    20                          
    21                          		!IF KEYBOARD=7 {
    22                          			LDX #$60	; 96 bytes in table. X is used as offset into the table (CBM-II keyboard)
    23                          		} ELSE {
    24  e4c5 a250               			LDX #$50	; 80 bytes in table. X is used as offset into the table (normal keyboards)
    25                          		}
    26                          
    27                          ;-------------- Start Scan
    28                          
    29                          SCAN_ROW
    30                          		!IF KEYBOARD=7 {
    31                          			 LDY #$06	; Number of Columns to check = 6 (CBM-II keyboard only)
    32                          		} ELSE {
    33  e4c7 a008               			 LDY #$08	; Number of Columns to check = 8 (normal keyboards)
    34                          		}
    35                          
    36  e4c9 ad12e8             		LDA PIA1_Port_B 	; Get byte from Keyboard ROW result
    37  e4cc cd12e8             		CMP PIA1_Port_B 	; Read again and compare
    38  e4cf d0f6               		BNE SCAN_ROW		; If they are not equal loop back up (Debounce)
    39                          
    40                          ;-------------- Shift the COL BITS
    41                          
    42  e4d1 4a                 SCAN_COL	LSR			; Shift the value right
    43  e4d2 b01f               		BCS SCAN_NEXT2		; If the bit was "1" then key is NOT down. Skip
    44                          
    45                          ;-------------- We have a key press. Look it up in the keyboard matrix
    46                          
    47  e4d4 48                 		PHA			; Save for later
    48  e4d5 bdd0e6             		LDA KEYBOARD_NORMAL-1,X	; Read Keyboard Matrix (X is offset)
    49                          
    50                          ;-------------- Check if SHIFT key pressed
    51                          
    52  e4d8 d006               		BNE SCAN_NOSH		; Is it SHIFT key ($00)? No, skip
    53                          
    54                          ;-------------- SHIFT key is pressed. Set SHIFT FLAG
    55                          
    56  e4da a901               		LDA #$01		; 1=Shift Key Pressed
    57  e4dc 8598               		STA KEYFLAGS		; Save it 
    58  e4de d012               		BNE SCAN_NEXT		; branch always
    59                          
    60                          ;-------------- Check REPEAT key pressed
    61                          
    62  e4e0 c910               SCAN_NOSH	CMP #$10		; Is it REPEAT?
    63  e4e2 d008               		BNE SCAN_NORPT		; No, skip
    64                          
    65                          ;-------------- Turn on REPEAT Mode
    66                          ; Note: We have Max 16 bytes we can insert here before we get "produced too much code"
    67                          
    68  e4e4 a5e4               		LDA RPTFLG		; Flag: REPEAT Key Used, $80 = Repeat, $40 = disable
    69  e4e6 0980               		ORA #$80
    70  e4e8 85e4               		STA RPTFLG		; Flag: REPEAT Key Used, $80 = Repeat, $40 = disable
    71  e4ea 3006               		BMI SCAN_NEXT
    72                          
    73                          ;-------------- Check if any other KEY is pressed
    74                          
    75  e4ec c9ff               SCAN_NORPT	CMP #$FF		; $FF=No key
    76  e4ee f002               		BEQ SCAN_NEXT		; No, skip
    77  e4f0 85a6               		STA Key_Image		; Yes, store the key
    78                          
    79                          ;-------------- Scan Next COL bit
    80                          
    81  e4f2 68                 SCAN_NEXT	PLA			; Restore value from keyboard scan for next loop
    82  e4f3 ca                 SCAN_NEXT2	DEX			; Decrement keyboard table offset
    83  e4f4 f008               		BEQ SCAN_GOT		; If 0 we have completed the entire matrix...Process Key Image
    84                          
    85  e4f6 88                 		DEY			; Next COLUMN
    86  e4f7 d0d8               		BNE SCAN_COL		; Go back up for next column bit
    87                          
    88                          ;-------------- Completed all bits in ROW, Increment ROW
    89                          
    90  e4f9 ee10e8             		INC PIA1_Port_A		; Next Keyboard ROW
    91  e4fc d0c9               		BNE SCAN_ROW		; More? Yes, loop back UP to scan next ROW
    92                          
    93                          ;-------------- Process Key Image
    94                          
    95  e4fe a5a6               SCAN_GOT	LDA Key_Image		; Key Image
    96  e500 c597               		CMP KEYPRESSED		; Current Key Pressed
    97  e502 f006               		BEQ SCAN_PRESS		; If key is the same then it's being held down
    98                          
    99  e504 a210               		LDX #$10
   100  e506 86e6               		STX DELAY		; Repeat Delay Counter
   101  e508 d02f               		BNE SCAN_REC
   102                          
   103  e50a 24e4               SCAN_PRESS	BIT RPTFLG		; Check Repeat Flag: $80 = Repeat, $40 = disable
   104  e50c 301e               		BMI SCAN_DELAY2		; Repeat not set, so skip
   105  e50e 7063               		BVS SCAN_OUT		; Exit
   106                          
   107  e510 c9ff               		CMP #$FF		; Was it a key?
   108  e512 f05f               		BEQ SCAN_OUT		; No, Exit
   109                          
   110                          ;-------------- Check Auto-Repeat for specific keys
   111                          
   112  e514 c914               		CMP #$14		; Yes, check for auto-repeat keys. Is it <DEL>?
   113  e516 f00c               		BEQ SCAN_DELAY
   114  e518 c920               		CMP #$20		; Is it <SPACE>?
   115  e51a f008               		BEQ SCAN_DELAY
   116  e51c c91d               		CMP #$1D		; Is it <RIGHT>?
   117  e51e f004               		BEQ SCAN_DELAY
   118  e520 c911               		CMP #$11		; Is it <DOWN>?
   119  e522 d04f               		BNE SCAN_OUT		; No auto-repeat keys skip ahead
   120                          
   121                          ;-------------- Found a non-repeating key. Set Delay counters
   122                          
   123  e524 a6e6               SCAN_DELAY	LDX DELAY		; Repeat Delay Counter
   124  e526 f004               		BEQ SCAN_DELAY2
   125  e528 c6e6               		DEC DELAY		; Repeat Delay Counter
   126  e52a d047               		BNE SCAN_OUT		; Exit
   127                          
   128  e52c c6e5               SCAN_DELAY2	DEC KOUNT		; Repeat Speed Counter
   129  e52e d043               		BNE SCAN_OUT		; Exit
   130  e530 a204               		LDX #$04
   131  e532 86e5               		STX KOUNT		; Repeat Speed Counter
   132  e534 a69e               		LDX CharsInBuffer	; No. of Chars. in Keyboard Buffer (Queue)
   133  e536 ca                 		DEX			; One less
   134  e537 103a               		BPL SCAN_OUT		; Exit
   135                          
   136                          ;-------------- Record the Keypress
   137                          
   138  e539 8597               SCAN_REC	STA KEYPRESSED		; Save the KEY
   139  e53b c9ff               		CMP #$FF		; No Key?
   140  e53d f034                		BEQ SCAN_OUT		; Yes, exit
   141                          
   142  e53f aa                 		TAX
   143  e540 08                 		PHP
   144  e541 297f               		AND #$7F		; Mask off upper bit (non-shiftable flag in key matrix byte)
   145  e543 28                 		PLP
   146  e544 3017               		BMI SCAN_NORM
   147                          
   148                          
   149                          ;-------------- Process SHIFT key flag with Numeric Keys or Graphic keys
   150                          
   151  e546 4698               		LSR KEYFLAGS		; Check for SHIFT
   152  e548 9013               		BCC SCAN_NORM		; No, store as-is
   153  e54a c92c               		CMP #$2C		; Is it less than 2C? 
   154  e54c 900d               		BCC SCAN_SHIFT		; Yes, skip
   155  e54e c93c               		CMP #$3C		; Is it greater than 3C?
   156  e550 b009               		BCS SCAN_SHIFT		; Yes, skip
   157  e552 e90f               		SBC #$0F		; No, it must be Numeric so subtract 15
   158  e554 c920               		CMP #$20		; Is it above <SPACE>
   159  e556 b005               		BCS SCAN_NORM		; Yes
   160                          
   161  e558 6920               		ADC #$20		; Add 32 to convert to shifted symbol on number key
   162  e55a 2c                 		!byte $2C		; Hide the next instruction trick
   163  e55b 0980               SCAN_SHIFT	ORA #$80		; Set upper bit for Graphics Symbol
   164                          
   165                          ;-------------- Put the KEY into the Buffer (Key in accumulator)
   166                          
   167                          SCAN_NORM
   168                          
   169                          !IF GRKMODE=1 {				; Handle GRKMODE - Changes KEYS to GRAPHIC SYMBOLS
   170  e55d a6e4               		LDX RPTFLG		; Check if REPEAT MODE is on
   171  e55f 1006               		BPL GRKSKIP		; No, skip ahead
   172  e561 c921               		CMP #33			; Is it "!"?
   173  e563 3002               		BMI GRKSKIP		; Less, so skip ahead
   174  e565 09c0               		ORA #$C0		; 11000000 Set BIT 7,6 - convert it to graphic symbol
   175                          GRKSKIP
   176                          }
   177                          
   178                          !IF ESCCODES=1 { JMP EUROSWAP }		; Check if Eurokeys need swapping
   179                          
   180  e567 a69e               SCAN_NORM2	LDX CharsInBuffer	; No. of Chars. in Keyboard Buffer (Queue)
   181  e569 e4e3               		CPX XMAX		; Size of Keyboard Buffer
   182  e56b b006               		BCS SCAN_OUT		; Exit if buffer full
   183  e56d 9d6f02             		STA KEYD,X		; Put the key into the buffer
   184                          !IF BACKARROW=0 {
   185  e570 e8                 		INX			; Increment character count
   186  e571 869e               		STX CharsInBuffer	; No. of Chars. in Keyboard Buffer (Queue)
   187                          } ELSE {
   188                          		JSR TestBackArrow	; Patch/Hack to use SHIFT-BACKARROW as screen mode toggle (text/graphic)
   189                          					; This patch is code-size neutral for THIS routine
   190                          }
   191                          
   192                          ;-------------- STOP KEY FIX
   193                          ; In the PET KERNAL there is code to check for the STOP key but is hard coded for N and B keyboards.
   194                          ; This fix puts the proper value ($EF) into STKEY ($9B) when the relocated STOP key is pressed.
   195                          ; NOTE: Must investigate further!
   196                          
   197                          !if KEYBOARD > 1 {			; Compensate for STOP key not in standard position
   198                          		CMP #3			; Is keycode "3" (STOP key)?
   199                          		BNE SCAN_OUT
   200                          		LDA #$EF		; fool kernal into thinking STOP is pressed
   201                          		STA STKEY		; store it
   202                          }
   203  e573 60                 SCAN_OUT	RTS

; ******** Source: editrom80.asm
  1021                          }		; Business Keyboard
  1022                          !IF KEYSCAN=2 { !SOURCE "keyscan-din.asm" }		; German DIN Keyboard
  1023                          !IF KEYSCAN=3 { !SOURCE "keyscan-c64.asm" }		; C64 Keyboard
  1024                          !IF KEYSCAN=4 { !SOURCE "keyscan-cbm2.asm" }		; CBM2 Keyboard (future implementation)
  1025                          
  1026                          ;*********************************************************************************************************
  1027                          ;** JUMP_TO_TAB  [E570]
  1028                          ;** Tab positions are stored in a table of 80 bits (10 bytes). This routine
  1029                          ;*********************************************************************************************************
  1030                          
  1031  e574 a5c6               JUMP_TO_TAB	LDA CursorCol				; Get Cursor column on current line
  1032  e576 29f8               		AND #$f8				; mask off upper 5 bits
  1033  e578 8d3a03             		STA NextTab				; This will be the new column to jump to
  1034  e57b 4a                 		LSR					; shift right 3 bits (divide by 8)
  1035  e57c 4a                 		LSR
  1036  e57d 4a                 		LSR
  1037  e57e aa                 		TAX
  1038  e57f a901               		LDA #1					; Set bit 0 to 1
  1039  e581 8d3e03             		STA DOS_Syntax				; temp storage
  1040  e584 a4c6               		LDY CursorCol				; Get Cursor column on current line
  1041  e586 cc3a03             JTTAB1 		CPY NextTab				; LOOP[ Is 
  1042  e589 f009               		BEQ JTTABDONE				;   Yes, exit out
  1043  e58b 0e3e03             		ASL DOS_Syntax				;   No, Move the "1" bit forward
  1044  e58e ee3a03             		INC NextTab				;   Move ahead one column
  1045  e591 4c86e5             		JMP JTTAB1				; ] Loop back for more
  1046  e594 60                 JTTABDONE	RTS
  1047                          
  1048                          ;		--------------------------------------- Check for CTRL-Y
  1049                          
  1050                          Scroll_Or_Select_Charset
  1051                          
  1052  e595 c919               		CMP #$19 				; Is it CTRL-Y? (Scroll window up)
  1053  e597 d006               		BNE Be59b				; No, skip ahead
  1054  e599 20e8e3             		JSR WIN_SCROLL_UP 			; Yes, Window Scroll Up
  1055  e59c 4cdde5             		JMP Me5d9
  1056                          
  1057                          ;		--------------------------------------- Check for CTRL-O
  1058                          
  1059  e59f c90f               Be59b		CMP #15 				; Is it CTRL-O (Set Window Top-Left)
  1060  e5a1 d00b               		BNE Be5aa				; No, skip ahead
  1061                          
  1062                          ;*********************************************************************************************************
  1063                          ;** ESCAPE_T
  1064                          ;** This sets the Window's Top-Left corner to the current cursor position
  1065                          ;*********************************************************************************************************
  1066                          
  1067  e5a3 a5d8               ESCAPE_T	LDA CursorRow				; Get current cursor ROW
  1068  e5a5 85e0               		STA TopMargin				; Store it as the TOP
  1069  e5a7 a5c6               		LDA CursorCol				; Get current cursor COL
  1070  e5a9 85e2               		STA LeftMargin				; Store it as the LEFT
  1071  e5ab 4c99e1             Be5a7		JMP IRQ_EPILOG
  1072                          
  1073                          ;		--------------------------------------- Check for CTRL-N
  1074                          
  1075  e5ae c90e               Be5aa		CMP #14 				; Is it CTRL-N? (Text mode)
  1076  e5b0 d005               		BNE Be5b3				; No, skip ahead
  1077  e5b2 207ae0             		JSR CRT_SET_TEXT			; Yes, do it
  1078  e5b5 30f4               		BMI Be5a7
  1079                          
  1080                          ;		--------------------------------------- Check for CTRL-G
  1081                          
  1082  e5b7 c907               Be5b3		CMP #7 					; Is it CTRL-G? (Ring Bell)
  1083  e5b9 d0f0               		BNE Be5a7				; No, skip ahead
  1084  e5bb 20a7e6             		JSR BEEP				; Yes, do BEEP
  1085  e5be f0eb               		BEQ Be5a7
  1086                          
  1087                          ;*********************************************************************************************************
  1088                          ;** ProcControl_A  [E5BC]
  1089                          ;** Continue checking codes.
  1090                          ;*********************************************************************************************************
  1091                          
  1092                          ProcControl_A
  1093                          !IF COLOURPET=0 {
  1094  e5c0 c915               		CMP #$15 				; Is it CTRL-SHIFT-U? (Insert Line) - CONFLICT with colour code = DK YELLOW					
  1095  e5c2 d012               		BNE ProcControl_C			; @@@@@@ Was: BNE ProcControl_B
  1096                          } ELSE {
  1097                          		JMP ProcControl_C
  1098                          }
  1099                          
  1100                          ;*********************************************************************************************************
  1101                          ;** ESCAPE_I
  1102                          ;** Insert a blank line at current cursor position
  1103                          ;*********************************************************************************************************
  1104                          
  1105  e5c4 a5e0               ESCAPE_I	LDA TopMargin
  1106  e5c6 48                 		PHA
  1107  e5c7 a5d8               		LDA CursorRow
  1108  e5c9 85e0               		STA TopMargin
  1109  e5cb 20c8e3             		JSR WIN_SCROLL_DN			; Scroll Window Down
  1110  e5ce 68                 Me5ca		PLA
  1111  e5cf 85e0               		STA TopMargin
  1112  e5d1 2063e0             		JSR CURSOR_LM
  1113  e5d4 d018               		BNE EB_DONE
  1114                          
  1115                          ;[E5D2]		--------------------------------------- Check for CTRL-SHIFT-Y
  1116                          
  1117  e5d6 c919               ProcControl_C	CMP #$19 				; Is it CTRL-SHIFT-Y? (Scroll window up)
  1118  e5d8 d008               		BNE Be5de				; No, skip ahead
  1119                          
  1120                          !IF COLOURPET=0 {
  1121  e5da 20c8e3             		JSR WIN_SCROLL_DN			; CONFLICT with colour code = LT GREEN
  1122                          }
  1123  e5dd 2067e0             Me5d9		JSR UPDATE_CURSOR_ROW
  1124  e5e0 d00c               		BNE EB_DONE
  1125                          
  1126                          ;[E5DE]		--------------------------------------- Check for CTRL-SHIFT-O
  1127                          
  1128  e5e2 c90f               Be5de		CMP #15 				; Is it CTRL-SHIFT-O? (Set Window Bottom)
  1129  e5e4 d00b               		BNE Be5ed				; No, skip ahead
  1130                          
  1131                          
  1132                          ;*********************************************************************************************************
  1133                          ;** ESCAPE_B
  1134                          ;** Set Windos Bottom-Left
  1135                          ;*********************************************************************************************************
  1136                          
  1137  e5e6 a5d8               ESCAPE_B	LDA CursorRow
  1138  e5e8 85e1               		STA BotMargin
  1139  e5ea a5c6               		LDA CursorCol
  1140  e5ec 85d5               		STA RightMargin
  1141  e5ee 4c99e1             EB_DONE		JMP IRQ_EPILOG
  1142                          
  1143                          ;[E5ED]		--------------------------------------- Check for CTRL-SHIFT-N
  1144                          
  1145  e5f1 c90e               Be5ed		CMP #14 				; Is it CTRL-SHIFT-N? (Graphics mode)
  1146  e5f3 d0c2               		BNE Be5b3				; No, skip ahead
  1147  e5f5 2082e0             		JSR CRT_SET_GRAPHICS			; Yes, do it
  1148  e5f8 30f4               		BMI EB_DONE
  1149                          
  1150                          ;*********************************************************************************************************
  1151                          ;** IRQ_END  [E600]  (Called from Jump Table) - FIXED ENTRY POINT!
  1152                          ;** The IRQ routine jumps here when completed. Do not modify this routine!
  1153                          ;*********************************************************************************************************
  1154                          
  1155  e5fa aaaaaaaaaaaa       		!IF NOFILL=0 { !FILL $e600-*,$aa }	;FIXED ENTRY POINT! This routine must not move! It is called directly from KERNAL
  1156                          
  1157                          ;#########################################################################################################
  1158                          
  1159  e600 68                 IRQ_END		PLA
  1160  e601 a8                 		TAY
  1161  e602 68                 		PLA
  1162  e603 aa                 		TAX
  1163  e604 68                 		PLA
  1164  e605 40                 		RTI
  1165                          
  1166                          ;*********************************************************************************************************
  1167                          ;** RESTORE_CHR_AT_CRSR  [E606]
  1168                          ;** This routine is called to put the character back at the cursor position.
  1169                          ;** It is called to put the initial character on the screen and as part of the cursor blinking routine.
  1170                          ;** NOTE: ColourPET: DOES NOT set/change COLOUR ATTRIBUTE!
  1171                          ;*********************************************************************************************************
  1172                          
  1173                          RESTORE_CHR_AT_CRSR
  1174  e606 a4c6               		LDY CursorCol				; Cursor Column on Current Line		
  1175  e608 91c4               		STA (ScrPtr),Y				; Put the character on the screen!!!!!!!!!!!!!!!!!!!!! 
  1176  e60a a902               		LDA #2					; Set blink count so cursor appears immediately
  1177  e60c 85a8               		STA BLNCT				; Timer: Countdown to Toggle Cursor
  1178  e60e 60                 		RTS
  1179                          
  1180                          ;*********************************************************************************************************
  1181                          ;** INIT_EDITOR  [E60F]
  1182                          ;** Initializes the Editor. Clears Clock. Sets IRQ Vector. Sets Keyboard buffer size. Clears TABs.
  1183                          ;** Sets zero-page locations. And finally, chimes the BELL.
  1184                          ;*********************************************************************************************************
  1185                          
  1186  e60f a97f               INIT_EDITOR	LDA #$7f
  1187  e611 8d4ee8             		STA VIA_IER				; VIA, Register E - I/O Timers
  1188  e614 a26d               		LDX #$6d
  1189  e616 a900               		LDA #0
  1190  e618 85e8               		STA HOMECT				; Clear Home Count (80-col)
  1191                          	
  1192                          !IF REPEATOPT = 1 { STA RPTFLG }			; Clear REPEAT ($80 = Repeat, $40 = disable)
  1193                          
  1194  e61a 958d               INITED1		STA JIFFY_CLOCK,X			; Clear Real-Time Jiffy Clock (approx) 1/60 Sec
  1195  e61c ca                 		DEX
  1196  e61d 10fb               		BPL INITED1
  1197  e61f 8698               		STX KEYFLAGS 				; $FF = Clear all flags
  1198                          
  1199                          ;		--------------------------------------- Set IRQ Vector - Normally $E455 or $E900 for Execudesk
  1200                          
  1201                          !IF EXECUDESK=1 {
  1202                          		LDA #<IRQ_EDESK				; Execudesk IRQ Vector LO
  1203                          		STA CINV
  1204                          		LDA #>IRQ_EDESK				; Execudesk IRQ Vector HI
  1205                          		STA CINV+1
  1206                          } ELSE {
  1207  e621 a955               		LDA #<IRQ_NORMAL			; Normal IRQ Vector LO
  1208  e623 8590               		STA CINV
  1209  e625 a9e4               		LDA #>IRQ_NORMAL			; Normal IRQ Vector HI
  1210  e627 8591               		STA CINV+1
  1211                          }
  1212                          
  1213                          ;		--------------------------------------- Init SS40
  1214                          
  1215                          !IF SS40=1 {
  1216                          	!IF HARD4080=1 {
  1217                          		LDA #1					; 40/80 Switcher board INSTALLED
  1218                          		STA SCN4080BOARD
  1219                          	} ELSE {
  1220                          		LDA #0					; 40/80 Switcher board NOT installed
  1221                          		STA SCN4080BOARD	
  1222                          	}
  1223                          
  1224                          	!IF SS40MODE=80 {
  1225                          		JSR SS40_INIT80				; Initialize Switchable Soft-40 to 80 columns
  1226                          	} ELSE {
  1227                          		JSR SS40_INIT40				; Initialize Switchable Soft-40 to 40 columns
  1228                          	}
  1229                          }
  1230                          ;		--------------------------------------- Continue
  1231                          
  1232  e629 a909               		LDA #$09
  1233  e62b 85e3               		STA XMAX				; Size of Keyboard Buffer
  1234  e62d a903               		LDA #$03
  1235  e62f 85b0               		STA DFLTO				; Default Output (CMD) Device (3)
  1236  e631 a90f               		LDA #15
  1237  e633 8d10e8             		STA PIA1_Port_A 			; Keyboard ROW select
  1238  e636 0a                 		ASL 
  1239  e637 8d40e8             		STA VIA_Port_B
  1240  e63a 8d42e8             		STA VIA_DDR_B
  1241  e63d 8e22e8             		STX PIA2_Port_B
  1242  e640 8e45e8             		STX VIA_Timer_1_Hi
  1243  e643 a93d               		LDA #$3d
  1244  e645 8d13e8             		STA PIA1_Cont_B
  1245  e648 2c12e8             		BIT PIA1_Port_B 			; Keyboard COL read
  1246  e64b a93c               		LDA #$3c
  1247  e64d 8d21e8             		STA PIA2_Cont_A
  1248  e650 8d23e8             		STA PIA2_Cont_B
  1249  e653 8d11e8             		STA PIA1_Cont_A
  1250  e656 8e22e8             		STX PIA2_Port_B
  1251  e659 a90e               		LDA #14
  1252  e65b 85a8               		STA BLNCT				; Timer: Countdown to Toggle Cursor
  1253  e65d 85a7               		STA Blink				; Cursor Blink enable: 0 = Flash Cursor
  1254  e65f 85e6               		STA DELAY				; Repeat Delay Counter
  1255  e661 85e5               		STA KOUNT				; Repeat Speed Counter
  1256  e663 8d4ee8             		STA VIA_IER
  1257  e666 20d2e1             		JSR FULL_SCREEN				; Exit Window - Set screen size (ie: 80x25)
  1258                          
  1259                          ;[E669]		--------------------------------------- Clear Tab Stops (80 bits) 
  1260                          
  1261  e669 a20c               CLEAR_TABS	LDX #12					; 12 bytes (10 bytes plus?)
  1262  e66b a900               		LDA #0					; To Clear the table
  1263  e66d 9dee03             CT_LOOP		STA TABS_SET,X				; LOOP[  Table of 80 bits to set TABs
  1264  e670 ca                 		DEX					;   next byte
  1265  e671 10fa               		BPL CT_LOOP				; ] Loop back for more
  1266                          
  1267                          ;		--------------------------------------- Set Screen Input and Output Vectors
  1268                          
  1269  e673 a91d               		LDA #<DEFAULT_SCREEN_VECTOR		; LO Address of Screen Input vector (from E006)
  1270  e675 a2e1               		LDX #>DEFAULT_SCREEN_VECTOR		; HI 
  1271  e677 85e9               		STA SCRIV				; Input from screen vector (from E006)
  1272  e679 86ea               		STX SCRIV+1				; Input from screen vector (from E006)
  1273                          
  1274  e67b a90c               		LDA #<CHROUT_NORMAL
  1275  e67d a2e2               		LDX #>CHROUT_NORMAL
  1276  e67f 85eb               		STA SCROV				; Print to screen vector (from E009)
  1277  e681 86ec               		STX SCROV+1				; Print to screen vector (from E009)
  1278                          
  1279  e683 a910               		LDA #$10
  1280  e685 85e7               		STA CHIME
  1281                          
  1282                          ;		--------------------------------------- Patches for new features here
  1283                          
  1284                          !IF ESCCODES=1 {
  1285                          		LDA #1					; 1=Enabled
  1286                          		STA BELLMODE				; Flag to Enable BELL
  1287                          }
  1288                          !IF AUTORUN=1 {	JSR AUTOSTART }				; Do Auto Run Prep
  1289                          
  1290                          ;		--------------------------------------- Finish up by ringing BELL 4 times
  1291                          
  1292  e687 20a4e6             		JSR BEEP_BEEP				; Power-up chimes
  1293  e68a f018               		BEQ BEEP_BEEP				; More chimes (4 total)
  1294                          
  1295                          
  1296                          ;*********************************************************************************************************
  1297                          ;** ChrOutMarginBeep  [E68C]
  1298                          ;** Checks the cursor position and rings the BELL if near the end of the line
  1299                          ;*********************************************************************************************************
  1300                          
  1301                          ChrOutMarginBeep
  1302  e68c 2002e2             		JSR CHROUT_SCREEN			; Output to Screen
  1303  e68f aa                 		TAX
  1304  e690 a5d5               		LDA RightMargin				; Physical Screen Line Length
  1305  e692 38                 		SEC
  1306  e693 e5c6               		SBC CursorCol				; Cursor Column on Current Line
  1307  e695 c905               		CMP #5					; 5 characters from end of line
  1308  e697 d037               		BNE BELLDONE
  1309  e699 8a                 		TXA
  1310  e69a c91d               		CMP #$1d 				; <Cursor Right> ?
  1311  e69c f006               		BEQ BEEP_BEEP				; Ring BELL
  1312  e69e 297f               		AND #$7f
  1313  e6a0 c920               		CMP #$20 				; <SPACE>
  1314  e6a2 902c               		BCC BELLDONE
  1315                          
  1316                          ;*********************************************************************************************************
  1317                          ;** BEEP / BEEP_BEEP  [E6A7]
  1318                          ;** Rings the BELL
  1319                          ;*********************************************************************************************************
  1320                          
  1321  e6a4 20a7e6             BEEP_BEEP	JSR BEEP				; Double BEEP
  1322                          BEEP							; Single BEEP
  1323                          
  1324                          !IF SILENT=0 {
  1325  e6a7 a4e7               		LDY CHIME				; Chime Time FLAG
  1326                          } ELSE {
  1327                          		!IF CRUNCH=0 { NOP }			; To keep code aligned
  1328                          		RTS
  1329                          }
  1330                          
  1331                          !IF ESCCODES=1 {
  1332                          		LDA BELLMODE
  1333                          		BPL BELLENABLED
  1334                          		RTS
  1335                          }
  1336  e6a9 f025               BELLENABLED	BEQ BELLDONE
  1337  e6ab a910               		LDA #16
  1338  e6ad 8d4be8             		STA VIA_ACR
  1339  e6b0 a90f               		LDA #15
  1340  e6b2 8d4ae8             		STA VIA_Shift
  1341  e6b5 a207               		LDX #7
  1342  e6b7 bd4de7             BELLOOP1	LDA SOUND_TAB-1,X
  1343  e6ba 8d48e8             		STA VIA_Timer_2_Lo
  1344  e6bd a5e7               		LDA CHIME				; Chime Time
  1345                          
  1346  e6bf 88                 BELLOOP2	DEY
  1347  e6c0 d0fd               		BNE BELLOOP2				; Delay loop
  1348  e6c2 38                 		SEC
  1349  e6c3 e901               		SBC #1
  1350  e6c5 d0f8               		BNE BELLOOP2				; Delay loop
  1351  e6c7 ca                 		DEX
  1352  e6c8 d0ed               		BNE BELLOOP1				; Delay loop
  1353  e6ca 8e4ae8             		STX VIA_Shift
  1354  e6cd 8e4be8             		STX VIA_ACR
  1355  e6d0 60                 BELLDONE	RTS
  1356                          
  1357                          ;*********************************************************************************************************
  1358                          ;** Keyboard Decoding Table  [E6D1]
  1359                          ;*********************************************************************************************************
  1360                          

; ******** Source: keyboard.asm
     1                          ; PET/CBM EDIT ROM - Keyboard Matrix Selection
     2                          ; ================
     3                          ; This adds the appropriate keyboard matrix or matrices depending on options:
     4                          ; KEYSCAN=n  -- which keyboard scanning routine is used
     5                          ; KEYBOARD=n -- to select the matrix layout
     6                          ;
     7                          ; Note: Not all keyboards are defined for all options! Please check source
     8                          ;------------------------------------------------------------------------------
     9                          
    10                          !if KEYSCAN=0 { !source "keyboard-tables1.asm" }	; Graphic (Normal) Keyboard Scanner - Simple

; ******** Source: keyboard-tables1.asm
     1                          ; PET/CBM EDIT ROM - Keyboard Matrix Tables for KEYSCAN-N, KEYSCAN-B scanner code
     2                          ; ================
     3                          ; 
     4                          ; Notes:
     5                          ;	Modifier Keys: 00 = Shift, 10 = Repeat, 80 = CTRL
     6                          ;	Special Codes: Bit 7 set (+$80) = Unshiftable, FF = No Key
     7                          ;       Labelling:
     8                          ;	   KP = Keypad, S- = Shift , GR- = Graphic Code, NONE = No Key
     9                          ;          CTRL- = CTRL+key , SHC- = Shift-CTRL+key, A- = Accent
    10                          ;
    11                          ; The keyboard matrix bytes are arranged in the order they appear in the ROM.
    12                          ; The keyboard is scanned from ROW 9/COL7 and works its way backwards to ROW0/COL0 in the matrix.
    13                          ; Due to hardware, ROWS are wired BACKWARDS, so when it stores a 0 into the PIA ROW SELECT register
    14                          ; it is selecting ROW 9 in the table. The scanner selects a ROW then reads the COL bits which are
    15                          ; also BACKWARDS. C7 is BIT0 and C0 is BIT7. Any KEY that is DOWN will set the BIT to "0". 
    16                          ;
    17                          ; STOP KEY:
    18                          ; When scanning is complete ROW0 is left selected. This is HARDWARE ROW9.
    19                          ; The KERNAL has a routine at $F7A1 that scans the last selected ROW, which is ROW0 and puts it in STKEY ($9B).
    20                          ; Then the routine at $F335 checks for STOP by looking in $9B for a zero in BIT4. On N/B this at: ROW X, COL 2.
    21                          ; If the STOP key is relocated, the key at ROW0/COL3 will trigger STOP by returning 11101111 binary (Hex $EF).
    22                          
    23                          KEYBOARD_NORMAL
    24                          
    25                          ;---------- Normal/Graphic Keyboard - QWERTY Layout (chicklet or standard type)
    26                          ;
    27                          !IF KEYBOARD=0 {
    28                          ; BIT: 7   6   5   4   3   2   1   0
    29                          ;     C0  C1  C2  C3  C4  C5  C6  C7    COL0   COL1   COL2   COL3   COL4   COL5   COL6   COL7   NOTES HWROW
    30                          ;     === === === === === === === ===   ====== ====== ====== ====== ====== ====== ====== ====== ===== =====
    31                          !byte $3d,$2e,$10,$03,$3c,$20,$5b,$12 ; KP =   KP .   CTRL-P STOP   <      SPACE  [      RVS    ROW0/A  9    STOP is in DEFAULT location
    32                          !byte $2d,$30,$00,$3e,$ff,$5d,$40,$00 ; KP -   KP 0   SHIFT  >      NONE   ]      @      SHIFT  ROW1/B  8
    33                          !byte $2b,$32,$ff,$3f,$2c,$4e,$56,$58 ; KP +   KP 2   NONE   ?      ,      n      v      x      ROW2/C  7
    34                          !byte $33,$31,$0d,$3b,$4d,$42,$43,$5a ; KP 3   KP 1   RETURN ;      m      b      c      z      ROW3/D  6
    35                          !byte $2a,$35,$ff,$3a,$4b,$48,$46,$53 ; KP *   KP 5   NONE   :      k      h      f      s      ROW4/E  5
    36                          !byte $36,$34,$ff,$4c,$4a,$47,$44,$41 ; KP 6   KP 4   NONE   l      j      g      d      a      ROW5/F  4
    37                          !byte $2f,$38,$ff,$50,$49,$59,$52,$57 ; KP /   KP 8   NONE   p      i      y      r      w      ROW6/G  3
    38                          !byte $39,$37,$5e,$4f,$55,$54,$45,$51 ; KP 9   KP 7   UP-ARR o      u      t      e      q      ROW7/H  2
    39                          !byte $14,$11,$09,$29,$5c,$27,$24,$22 ; DEL    DOWN   TAB??? )      \      '      $      "      ROW8/I  1 
    40                          !byte $1d,$13,$5f,$28,$26,$25,$23,$21 ; RIGHT  HOME   BK-ARR (      &      %      #      !      ROW9/J  0
    41                          }
    42                          
    43                          ;---------- Business Keyboard - QWERTY Layout
    44                          ;
    45                          !IF KEYBOARD=1 {
    46                          ;     C0  C1  C2  C3  C4  C5  C6  C7    COL0   COL1   COL2   COL3   COL4   COL5   COL6   COL7   NOTES 
    47                          ;     === === === === === === === ===   ====== ====== ====== ====== ====== ====== ====== ====== =====
    48  e6d1 16043a03393633df   !byte $16,$04,$3A,$03,$39,$36,$33,$DF ; CTRL-V CTRL-D :      STOP   9      6      3      BK-ARR ROW0/A  STOP is in DEFAULT location
    49  e6d9 b12f15134d205812   !byte $B1,$2F,$15,$13,$4D,$20,$58,$12 ; KP 1   /      CTRL-U HOME   m      SPACE  x      RVS    ROW1/B
    50  e6e1 b2100fb02c4e565a   !byte $B2,$10,$0F,$B0,$2C,$4E,$56,$5A ; KP 2   RPT    CTRL-O KP 0   ,      n      v      z      ROW2/C 
    51  e6e9 b30019ae2e424300   !byte $B3,$00,$19,$AE,$2E,$42,$43,$00 ; KP 3   SHIFT  CTRL-Y KP .   .      b      c      SHIFT  ROW3/D
    52  e6f1 b4db4f1155544551   !byte $B4,$DB,$4F,$11,$55,$54,$45,$51 ; KP 4   [      o      DOWN   u      t      e      q      ROW4/E 
    53  e6f9 145049dc59525709   !byte $14,$50,$49,$DC,$59,$52,$57,$09 ; DEL    p      i      \      y      r      w      TAB    ROW5/F 
    54  e701 b6c04c0d4a474441   !byte $B6,$C0,$4C,$0D,$4A,$47,$44,$41 ; KP 6   @      l      RETURN j      g      d      a      ROW6/G
    55  e709 b53b4bdd4846539b   !byte $B5,$3B,$4B,$DD,$48,$46,$53,$9B ; KP 5   ;      k      ]      h      f      s      ESC    ROW7/H
    56  e711 b906deb7b0373431   !byte $B9,$06,$DE,$B7,$B0,$37,$34,$31 ; KP 9   CTRL-F UP-ARR KP 7   0      7      4      1      ROW8/I
    57  e719 050e1db82d383532   !byte $05,$0E,$1D,$B8,$2D,$38,$35,$32 ; CTRL-E CTRL-N RIGHT  KP 8   -      8      5      2      ROW9/J
    58                          }
    59                          
    60                          ;---------- Business Keyboard - German DIN, QWERTZ (Version 1) Layout
    61                          ;
    62                          !IF KEYBOARD=2 {
    63                          ;     C0  C1  C2  C3  C4  C5  C6  C7    COL0   COL1   COL2   COL3   COL4   COL5   COL6   COL7   NOTES
    64                          ;     === === === === === === === ===   ====== ====== ====== ====== ====== ====== ====== ====== =====
    65                          !byte $16,$04,$40,$03,$39,$36,$33,$5F ; CTRL-V CTRL-D @      STOP   9      6      3      BK-ARR ROW0/A  ..x....x  STOP is in DEFAULT location
    66                          !byte $B1,$2F,$15,$13,$4D,$20,$58,$12 ; KP 1   /      CTRL-U HOME   M      SPACE  x      RVS    ROW1/B  ........
    67                          !byte $B2,$80,$0F,$01,$2C,$4E,$56,$59 ; KP 2   CTRL   CTRL-O KP 0   ,      n      v      y      ROW2/C  .x.x...x <- $80=CTRL (was $10=REPEAT)
    68                          !byte $B3,$00,$19,$AE,$2E,$42,$43,$00 ; KP 3   SHIFT  CTRL-Y KP .   .      b      c      SHIFT  ROW3/D  ........ <- $00=SHIFT
    69                          !byte $B4,$5B,$4F,$11,$55,$54,$45,$51 ; KP 4   [      o      DOWN   u      t      e      q      ROW4/E  .x......
    70                          !byte $14,$50,$49,$3A,$5A,$52,$57,$09 ; DEL    p      i      :      z      r      w      TAB    ROW5/F  ...xx...
    71                          !byte $B6,$5D,$4C,$0D,$4A,$47,$44,$41 ; KP 6   ]      l      RETURN j      g      d      a      ROW6/G  .x......
    72                          !byte $B5,$5C,$4B,$3B,$48,$46,$53,$1B ; KP 5   \      k      ;      h      f      s      ESC    ROW7/H  .......x
    73                          !byte $B9,$06,$5E,$B7,$B0,$37,$34,$31 ; KP 9   CTRL-F UP-ARR KP 7   0      7      4      1      ROW8/I  ..x.....
    74                          !byte $05,$0E,$1D,$B8,$2D,$38,$35,$32 ; CTRL-E CTRL-N RIGHT  KP 8   -      8      5      2      ROW9/J  ........
    75                          }
    76                          
    77                          ;---------- C64/VIC-20 Keyboard
    78                          ;
    79                          ; Keyboard will plug directly into the PET keyboard connector.
    80                          ; It is electrically compatible, but only uses an 8x8 matrix of keys.
    81                          ; Due to the nature of the keyboard and different labelling, the following changes are made:
    82                          ;
    83                          ; * Code Change: SHIFT=01 with 00
    84                          ; * Reassign   : POUND as \=5C, CTRL as RVS=12, C= as ESC=9B
    85                          ; * Reassign   : F1 as TEXT=0E, F3 as DELETE LINE=15, F5 as ERASE TO START=16, F7 as SCROLL DOWN=19
    86                          
    87                          !IF KEYBOARD=3 {
    88                          ;     C0  C1  C2  C3  C4  C5  C6  C7    COL0   COL1   COL2   COL3   COL4   COL5   COL6   COL7   NOTES 
    89                          ;     === === === === === === === ===   ====== ====== ====== ====== ====== ====== ====== ====== =====
    90                          !byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF ; NONE   NONE   NONE   NONE   NONE   NONE   NONE   NONE   ROW0/A  STOP is RELOCATED!
    91                          !byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF ; NONE   NONE   NONE   NONE   NONE   NONE   NONE   NONE   ROW1/B
    92                          !byte $19,$13,$2D,$30,$38,$36,$34,$32 ; F7     HOME   -      0      8      6      4      2      ROW2/C
    93                          !byte $16,$5E,$40,$4F,$55,$54,$45,$51 ; F5     UP-ARR @      O      U      T      E      Q      ROW3/D
    94                          !byte $15,$3D,$3A,$4B,$48,$46,$53,$9B ; F3     =      :      K      H      F      S      C=     ROW4/E
    95                          !byte $0E,$00,$2E,$4D,$42,$43,$5A,$20 ; F1     SHIFT  .      M      B      C      Z      SPACE  ROW5/F
    96                          !byte $11,$2F,$2C,$4E,$56,$58,$00,$03 ; DOWN   /      ,      N      V      X      SHIFT  STOP   ROW6/G <- to here
    97                          !byte $1D,$3B,$4C,$4A,$47,$44,$41,$12 ; RIGHT  ;      L      J      G      D      A      CTRL   ROW7/H
    98                          !byte $0D,$2A,$50,$49,$59,$52,$57,$DF ; RETURN *      P      I      Y      R      W      BK-ARR ROW8/I
    99                          !byte $14,$5C,$2B,$39,$37,$35,$33,$31 ; DEL    POUND  +      9      7      5      3      1      ROW9/J
   100                          }
   101                          
   102                          ;---------- Business Keyboard - Modified QWERTY Layout - BSJG
   103                          ;
   104                          ; This is a B keyboard with re-arranged layout to make it closer to C64 keyboard
   105                          ; ESC moved to top left. Cursor keys to bottom CLR/HOME and INS/DEL moved to top row
   106                          ; REPEAT moved to bottom left.
   107                          ;
   108                          !IF KEYBOARD=4 {
   109                          ;     C0  C1  C2  C3  C4  C5  C6  C7    COL0   COL1   COL2   COL3   COL4   COL5   COL6   COL7   NOTES 
   110                          ;     === === === === === === === ===   ====== ====== ====== ====== ====== ====== ====== ====== ======
   111                          !byte $16,$04,$3A,$14,$39,$36,$33,$9B ; CTRL-V CTRL-D :      DEL    9      6      3      ESC    ROW0/A  STOP is RELOCATED!
   112                          !byte $B1,$2F,$15,$1D,$4D,$20,$58,$10 ; KP 1   /      CTRL-U RIGHT  m      SPACE  x      REPT   ROW1/B 
   113                          !byte $B2,$11,$0F,$B0,$2C,$4E,$56,$5A ; KP 2   DOWN   CTRL-O KP 0   ,      n      v      z      ROW2/C
   114                          !byte $B3,$00,$19,$AE,$2E,$42,$43,$00 ; KP 3   SHIFT  CTRL-Y KP .   .      n      c      SHIFT  ROW3/D
   115                          !byte $B4,$DB,$4F,$DF,$55,$54,$45,$51 ; KP 4   [      o      BK-ARR u      t      e      q      ROW4/E
   116                          !byte $DE,$50,$49,$DD,$59,$52,$57,$09 ; UP-ARR p      i      ]      y      r      w      TAB    ROW5/F
   117                          !byte $B6,$C0,$4C,$0D,$4A,$47,$44,$41 ; KP 6   @      l      RETURN j      g      d      a      ROW6/G
   118                          !byte $B5,$3B,$4B,$DC,$48,$46,$53,$03 ; KP 5   ;      k      \      h      f      s      STOP   ROW7/H <- to here
   119                          !byte $B9,$06,$12,$B7,$B0,$37,$34,$31 ; KP     CTRL-F RVS    KP 7   0      7      4      1      ROW8/I
   120                          !byte $05,$0E,$13,$B8,$2D,$38,$35,$32 ; CTRL-E CTRL-N HOME   KP 8   -      8      5      2      ROW9/J
   121                          }
   122                          
   123                          ;---------- Graphic Keyboard - Modified QWERTY Layout - NSJG
   124                          ;
   125                          ; In order to use ESC codes, the keyboard must have an ESC key. The standard Graphic keyboard has none,
   126                          ; so the "@" key is used instead as it occupies the position an ESC key would normally be. The BACKARROW
   127                          ; key will become the "@" symbol so that the DOS wedge is usable (BACKARROW is rarely used).
   128                          ;
   129                          !IF KEYBOARD=5 {
   130                          ;     C0  C1  C2  C3  C4  C5  C6  C7    COL0   COL1   COL2   COL3   COL4   COL5   COL6   COL7   NOTES 
   131                          ;     === === === === === === === ===   ====== ====== ====== ====== ====== ====== ====== ====== =====
   132                          !byte $3d,$2e,$10,$03,$3c,$20,$5b,$12 ; KP =   KP .   CTRL-P STOP   <      SPACE  [      RVS    ROW0/A  STOP is in DEFAULT location
   133                          !byte $2d,$30,$00,$3e,$ff,$5d,$9b,$00 ; KP -   KP 0   SHIFT  >      NONE   ]      ESC    SHIFT  ROW1/B  @ replaced with ESC
   134                          !byte $2b,$32,$ff,$3f,$2c,$4e,$56,$58 ; KP +   KP 2   NONE   ?      ,      n      v      x      ROW2/C
   135                          !byte $33,$31,$0d,$3b,$4d,$42,$43,$5a ; KP 3   KP 1   RETURN ;      m      b      c      z      ROW3/D
   136                          !byte $2a,$35,$ff,$3a,$4b,$48,$46,$53 ; KP *   KP 5   NONE   :      k      h      f      s      ROW4/E
   137                          !byte $36,$34,$ff,$4c,$4a,$47,$44,$41 ; KP 6   KP 4   NONE   l      j      g      d      a      ROW5/F
   138                          !byte $2f,$38,$ff,$50,$49,$59,$52,$57 ; KP /   KP 8   NONE   p      i      y      r      w      ROW6/G
   139                          !byte $39,$37,$5e,$4f,$55,$54,$45,$51 ; KP 9   KP 7   UP-ARR o      u      t      e      q      ROW7/H
   140                          !byte $14,$11,$09,$29,$5c,$27,$24,$22 ; DEL    DOWN   TAB??? )      \      '      $      "      ROW8/I
   141                          !byte $1d,$13,$40,$28,$26,$25,$23,$21 ; RIGHT  HOME   @      (      &      %      #      !      ROW9/J  BACKARROW replaced by @
   142                          }
   143                          
   144                          ;---------- Business Keyboard - QWERTZ Layout
   145                          ;
   146                          !IF KEYBOARD=6 {
   147                          ;     C0  C1  C2  C3  C4  C5  C6  C7    COL0   COL1   COL2   COL3   COL4   COL5   COL6   COL7   NOTES 
   148                          ;     === === === === === === === ===   ====== ====== ====== ====== ====== ====== ====== ====== =====
   149                          !byte $16,$04,$3A,$03,$39,$36,$33,$DF ; CTRL-V CTRL-D :      STOP   9      6      3      BK-ARR ROW0/A  STOP is in DEFAULT location 
   150                          !byte $B1,$2F,$15,$13,$4D,$20,$58,$12 ; KP 1   /      CTRL-U HOME   m      SPACE  x      RVS    ROW1/B 
   151                          !byte $B2,$10,$0F,$B0,$2C,$4E,$56,$59 ; KP 2   RPT    CTRL-O KP 0   ,      n      v      y      ROW2/C 
   152                          !byte $B3,$00,$19,$AE,$2E,$42,$43,$00 ; KP 3   SHIFT  CTRL-Y KP .   .      b      c      SHIFT  ROW3/D
   153                          !byte $B4,$DB,$4F,$11,$55,$54,$45,$51 ; KP 4   ]      o      DOWN   u      t      e      q      ROW4/E
   154                          !byte $14,$50,$49,$DC,$5A,$52,$57,$09 ; DEL    p      i      @      z      r      w      TAB    ROW5/F
   155                          !byte $B6,$C0,$4C,$0D,$4A,$47,$44,$41 ; KP 6   [      l      RETURN j      g      d      a      ROW6/G
   156                          !byte $B5,$3B,$4B,$DD,$48,$46,$53,$9B ; KP 5   \      k      ;      h      f      s      ESC    ROW7/H
   157                          !byte $B9,$06,$DE,$B7,$B0,$37,$34,$31 ; KP 9   CTRL-F UP-ARR KP 7   0      7      4      1      ROW8/I
   158                          !byte $05,$0E,$1D,$B8,$2D,$38,$35,$32 ; CTRL-E CTRL-N RIGHT  KP 8   -      8      5      2      ROW9/J
   159                          }
   160                          
   161                          ;----------- Business Keyboard - French AZERTY Layout
   162                          ;
   163                          !IF KEYBOARD=7 {
   164                          ;     C0  C1  C2  C3  C4  C5  C6  C7    COL0   COL1   COL2   COL3   COL4   COL5   COL6   COL7   NOTES 
   165                          ;     === === === === === === === ===   ====== ====== ====== ====== ====== ====== ====== ====== =====
   166                          !byte $16,$04,$3A,$03,$39,$36,$33,$DF ; CTRL-V CTRL-D :      STOP   9      6      3      BK-ARR ROW0/A  STOP is in DEFAULT location
   167                          !byte $B1,$2F,$15,$13,$4D,$20,$58,$12 ; KP 1   /      CTRL-U HOME   m      SPACE  x      RVS    ROW1/B
   168                          !byte $B2,$10,$0F,$B0,$2C,$4E,$56,$5A ; KP 2   RPT    CTRL-O KP 0   ,      n      v      z      ROW2/C 
   169                          !byte $B3,$00,$19,$AE,$2E,$42,$43,$00 ; KP 3   SHIFT  CTRL-Y KP .   .      b      c      SHIFT  ROW3/D
   170                          !byte $B4,$DB,$4F,$11,$55,$54,$45,$51 ; KP 4   [      o      DOWN   u      t      e      q      ROW4/E 
   171                          !byte $14,$50,$49,$DC,$59,$52,$57,$09 ; DEL    p      i      \      y      r      w      TAB    ROW5/F 
   172                          !byte $B6,$C0,$4C,$0D,$4A,$47,$44,$41 ; KP 6   @      l      RETURN j      g      d      a      ROW6/G
   173                          !byte $B5,$3B,$4B,$DD,$48,$46,$53,$9B ; KP 5   ;      k      ]      h      f      s      ESC    ROW7/H
   174                          !byte $B9,$06,$DE,$B7,$B0,$37,$34,$31 ; KP 9   CTRL-F UP-ARR KP 7   0      7      4      1      ROW8/I
   175                          !byte $05,$0E,$1D,$B8,$2D,$38,$35,$32 ; CTRL-E CTRL-N RIGHT  KP 8   -      8      5      2      ROW9/J
   176                          }
   177                          
   178                          ;----------- CBM-II (B-Series, P-Series) - QWERTY Layout
   179                          ;
   180                          ; The CBM-II keyboard has a 16*6 matrix, so it requires a hardware modification to work on the PET,
   181                          ; and a small modification to the keyboard scanning routine.
   182                          ; It also has many extra keys with no equivilent function, and so will have some non-functioning keys.
   183                          ;
   184                          ; *** WORK IN PROGRESS!!!!!!!
   185                          ;
   186                          !IF KEYBOARD=8 {
   187                          ;     C0  C1  C2  C3  C4  C5    COL0   COL1   COL2   COL3   COL4   COL5   NOTES 
   188                          ;     === === === === === ===   ====== ====== ====== ====== ====== ====== =====
   189                          !BYTE $E0,$1B,$09,$FF,$00,$01 ; F1     ESCAPE TAB    NONE   SHIFT  CTRL   ROW0/A
   190                          !BYTE $E1,$31,$51,$41,$5A,$FF ; F2     1      Q      A      Z      NONE   ROW1/B
   191                          !BYTE $E2,$32,$57,$53,$58,$43 ; F3     2      W      S      X      C      ROW2/C
   192                          !BYTE $E3,$33,$45,$44,$46,$56 ; F4     3      E      D      F      V      ROW3/D
   193                          !BYTE $E4,$34,$52,$54,$47,$42 ; F5     4      R      T      G      B      ROW4/E
   194                          !BYTE $E5,$35,$36,$59,$48,$4E ; F6     5      6      Y      H      N      ROW5/F
   195                          !BYTE $E6,$37,$55,$4A,$4D,$20 ; F7     7      U      J      M      SPACE  ROW6/G
   196                          !BYTE $E7,$38,$49,$4B,$2C,$2E ; F8     8      I      K      ,      .      ROW7/H
   197                          !BYTE $E8,$39,$4F,$4C,$3B,$2F ; F9     9      O      L      ;      /      ROW8/I
   198                          !BYTE $E9,$30,$2D,$50,$5B,$27 ; F10    0      -      P      [      '      ROW9/J
   199                          !BYTE $11,$3D,$5F,$5D,$0D,$DE ; DOWN   =      _      ]      RETURN PI     ROW10/K
   200                          !BYTE $91,$9D,$1D,$14,$02,$FF ; UP     LEFT   RIGHT  DEL    CMDR   NONE   ROW11/L
   201                          !BYTE $13,$3F,$37,$34,$31,$30 ; HOME   ?      7      4      1      0      ROW12/M
   202                          !BYTE $12,$04,$38,$35,$32,$2E ; RVS    CE     8      5      2      .      ROW13/N
   203                          !BYTE $8E,$2A,$39,$36,$33,$30 ; GRAPH  *      9      6      3      00     ROW14/O
   204                          !BYTE $03,$2F,$2D,$2B,$0D,$FF ; STOP   /      -      +      ENTER  NONE   ROW15/P
   205                          }
   206                          
   207                          ;----------- Normal/Graphic Keyboard - Modified QWERTY Layout with [ESC] modification
   208                          ;
   209                          ; In order to use ESC codes, the keyboard must have an ESC key. The standard Graphic keyboard has none.
   210                          ; This layout changes the BACKARROW to ESC.
   211                          ;
   212                          !IF KEYBOARD=9 {
   213                          ;     C0  C1  C2  C3  C4  C5  C6  C7    COL0   COL1   COL2   COL3   COL4   COL5   COL6   COL7   NOTES 
   214                          ;     === === === === === === === ===   ====== ====== ====== ====== ====== ====== ====== ====== =====
   215                          !byte $3d,$2e,$10,$03,$3c,$20,$5b,$12 ; KP =   KP .   CTRL-P STOP   <      SPACE  [      RVS    ROW0/A  STOP is in DEFAULT location
   216                          !byte $2d,$30,$00,$3e,$ff,$5d,$40,$00 ; KP -   KP 0   SHIFT  >      NONE   ]      @      SHIFT  ROW1/B
   217                          !byte $2b,$32,$ff,$3f,$2c,$4e,$56,$58 ; KP +   KP 2   NONE   ?      ,      n      v      x      ROW2/C
   218                          !byte $33,$31,$0d,$3b,$4d,$42,$43,$5a ; KP 3   KP 1   RETURN ;      m      b      c      z      ROW3/D
   219                          !byte $2a,$35,$ff,$3a,$4b,$48,$46,$53 ; KP *   KP 5   NONE   :      k      h      f      s      ROW4/E
   220                          !byte $36,$34,$ff,$4c,$4a,$47,$44,$41 ; KP 6   KP 4   NONE   l      j      g      d      a      ROW5/F
   221                          !byte $2f,$38,$ff,$50,$49,$59,$52,$57 ; KP /   KP 8   NONE   p      i      y      r      w      ROW6/G
   222                          !byte $39,$37,$5e,$4f,$55,$54,$45,$51 ; KP 9   KP 7   UP-ARR o      u      t      e      q      ROW7/H
   223                          !byte $14,$11,$09,$29,$5c,$27,$24,$22 ; DEL    DOWN   TAB??? )      \      '      $      "      ROW8/I
   224                          !byte $1d,$13,$1b,$28,$26,$25,$23,$21 ; RIGHT  HOME   BK-ARR (      &      %      #      !      ROW9/J   BACKARROW replaced by @
   225                          }
   226                          
   227                          ;----------- TED Series (C116/C16/Plus4) QWERTY Layout
   228                          ;
   229                          ; The TED keyboards have different connectors depending on model. Also, the pinouts
   230                          ; do not group the ROWs and COLs so you will need to make an adapter cable.
   231                          ; TED keyboards have 4 separate cursor keys meaning no SHIFT is needed. This will likely
   232                          ; conflict with the keyboard scanner which uses the TOP BIT of the character to indicate
   233                          ; it cannot be shifted. Cursor UP and LEFT are normally shifted.
   234                          ;
   235                          ; Due to the nature of the keyboard and different labelling, the following changes are made:
   236                          ;
   237                          ; * Code Change: SHIFT=01 with 00, CTRL with 80
   238                          ; * Reassign   : POUND as \=5C, C= as TEXT/GRAPHICS mode
   239                          ; * Reassign   : F1 as TEXT=0E, F2 as DELETE LINE=15, F3 as ERASE TO START=16, HELP as SCROLL DOWN=19
   240                          ;
   241                          ; NOTE: Pin 3=LED, Pin 4=GND
   242                          ; *** THIS KEYBOARD MATRIX HAS NOT BEEN TESTED!!!!
   243                          ;
   244                          !IF KEYBOARD=11 {
   245                          ;PIN: 17  14  13  2   6   8   9   16
   246                          ;     C0  C1  C2  C3  C4  C5  C6  C7    COL0   COL1   COL2   COL3   COL4   COL5   COL6   COL7   NOTES  PIN
   247                          ;     === === === === === === === ===   ====== ====== ====== ====== ====== ====== ====== ====== =====  ===
   248                          !byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF ; NONE   NONE   NONE   NONE   NONE   NONE   NONE   NONE   ROW0/A -    STOP is RELOCATED
   249                          !byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF ; NONE   NONE   NONE   NONE   NONE   NONE   NONE   NONE   ROW1/B -
   250                          !byte $31,$13,$00,$03,$20,$0E,$51,$32 ;	1      CLR    CTRL   STOP   SPACE  C=     Q      2      ROW2/C 5 
   251                          !byte $33,$57,$41,$00,$5A,$53,$45,$34 ; 3      W      A      SHIFT  Z      S      E      4      ROW3/D 7
   252                          !byte $35,$52,$44,$58,$43,$46,$54,$36 ; 5      R      D      X      C      F      T      6      ROW4/E 11
   253                          !byte $37,$59,$47,$56,$42,$48,$55,$38 ; 7      Y      G      V      B      H      U      8      ROW5/F 10
   254                          !byte $39,$49,$4A,$4E,$4D,$4B,$4F,$30 ; 9      I      J      N      M      K      O      0      ROW6/G 12
   255                          !byte $11,$50,$4C,$2C,$2E,$3B,$2D,$91 ; DOWN   P      L      ,      .      :      -      UP     ROW7/H 1
   256                          !byte $9D,$2A,$3B,$2F,$1B,$3D,$2B,$1D ; LEFT   *      ;      /      ESC    =      +      RIGHT  ROW8/I 15
   257                          !byte $14,$0D,$5C,$40,$0E,$15,$16,$19 ; DEL    RETURN POUND  @      F1     F2     F3     HELP   ROW9/J 18
   258                          }
   259                          
   260                          ;----------- C128 Keyboard - Requires hardware mod for larger matrix
   261                          ;
   262                          ; This table is taken from a C128 ROM disassembly and re-formatted
   263                          ; This has not been tested! It looks like the ROWS and COLUMNS are
   264                          ; reversed compared to the PET/CBM keyboard scanner. This will either
   265                          ; require re-ordering the matrix, or re-wiring/adapting the connector.
   266                          ;
   267                          ; CHANGES:
   268                          ;           SHIFT ($01) to SHIFT ($00)
   269                          ;           CTRL  ($04) to CTRL  ($80)
   270                          ;           ALT   ($08) to SHIFT ($00)
   271                          ;           NOSCRL($FF) to SHIFT ($00)
   272                          ; PIN
   273                          ; 1   GROUND
   274                          ; 2   NO PIN (keyed)
   275                          ; 4   +5V
   276                          ; 
   277                          ; Keys not in matrix:
   278                          ;    RESTORE  = pin 1 and pin 3
   279                          ;    40/80    = pin 1 and pin 24
   280                          ;    CAPS LOCK= pin 1 and pin 25
   281                          ;
   282                          ; *** THIS KEYBOARD MATRIX HAS NOT BEEN TESTED!!!!
   283                          ;
   284                          !IF KEYBOARD=12 {
   285                          
   286                          ;PIN: 12  11  10  5   8   7   6   9
   287                          ;     C0  C1  C2  C3  C4  C5  C6  C7    COL0   COL1   COL2   COL3   COL4   COL5   COL6   COL7   NOTES  PIN
   288                          ;     === === === === === === === ===   ====== ====== ====== ====== ====== ====== ====== ====== =====  ===
   289                          !byte $14,$0D,$1D,$88,$85,$86,$87,$11 ; DEL    RETURN RIGHT  .      .      .      .      DOWN   ROW0   13  STOP is RELOCATED
   290                          !byte $33,$57,$41,$34,$5A,$53,$45,$00 ; 3      w      a      4      z      s      e      SHIFT  ROW1   19
   291                          !byte $35,$52,$44,$36,$43,$46,$54,$58 ; 5      r      d      6      c      f      t      x      ROW2   18
   292                          !byte $37,$59,$47,$38,$42,$48,$55,$56 ; 7      y      g      8      b      h      u      v      ROW3   17
   293                          !byte $39,$49,$4A,$30,$4D,$4B,$4F,$4E ; 9      i      j      0      m      k      o      n      ROW4   16
   294                          !byte $2B,$50,$4C,$2D,$2E,$3A,$40,$2C ; +      p      l      -      .      :      @      ,      ROW5   15
   295                          !byte $5C,$2A,$3B,$13,$00,$3D,$5E,$2F ; \      *      ;      HOME   SHIFT  =      ^      /      ROW6   14
   296                          !byte $31,$5F,$80,$32,$20,$02,$51,$03 ; 1      BARROW CTRL   2      SPACE  CBM    q      STOP   ROW7   20
   297                          !byte $84,$38,$35,$09,$32,$34,$37,$31 ; HELP   8      5      TAB    2      4      7      1      ROW8   21
   298                          !byte $1B,$2B,$2D,$0A,$0D,$36,$39,$33 ; ESC    +      -      LF     ENTER  6      9      3      ROW9   22
   299                          !byte $08,$30,$2E,$91,$11,$9D,$1D,$00 ; ALT    0      .      UP     DOWN   LEFT   RIGHT  NOSCRL ROW10  23
   300                          }

; ******** Source: keyboard.asm
    11                          }	; Business Keyboard Scanner - Simple with code for specific shifted keys
    12                          !if KEYSCAN=2 { !source "keyboard-tables2.asm" }	; Extended Keyboard Scanner - Two Tables (Normal and Shifted)
    13                          !if ((CODEBASE>0) & (KEYSCAN=3)) { 
    14                          		!source "keyboard-tables3.asm" }	; C64 keyboard tables (only on newer codebases; put in ext space on codebase 0)

; ******** Source: editrom80.asm
  1361                          
  1362                          
  1363                          ;*********************************************************************************************************
  1364                          ;** SHIFT RUN/STOP string  [E721]
  1365                          ;*********************************************************************************************************
  1366                          
  1367  e721 44cc222a0d         RUN_STRING	!byte $44,$cc,$22,$2a,$0d		; dL"*<RETURN>
  1368  e726 52554e0d           		!byte $52,$55,$4e,$0d			; run<RETURN>
  1369                          
  1370                          ;*********************************************************************************************************
  1371                          ;** CRTC Chip Register Setup Tables (2K ROMs) [E72A]
  1372                          ;*********************************************************************************************************
  1373                          

; ******** Source: crtc-tables.asm
     1                          ; PET/CBM EDIT ROM - CRTC Register Table Selection
     2                          ; ================
     3                          ; Sets the CRTC Table depending on options
     4                          ; COLUMNS ---- 40 or 80 column hardware (with special cases 90 and 32)
     5                          ; SOFT40 ----- Software Defined 40-column modes
     6                          
     7                          
     8                          !IF COLUMNS=40 {
     9                          	!IF SOFT40=0 { !SOURCE "crtc-reg-normal.asm" }
    10                          	!IF SOFT40=1 { !SOURCE "crtc-reg-soft40.asm" }
    11                          } ELSE {

; ******** Source: crtc-reg-normal.asm
     1                          ; PET/CBM EDIT ROM - CRTC Register Tables
     2                          ; ================
     3                          ; For "normal" configurations (ie: for single main screen)
     4                          ; Sets the CRTC Table depending on options:
     5                          ; COLUMNS = 32,40,64,80,90
     6                          ;
     7                          ;======================================
     8                          ; NORMAL 4000/8000/8296/SuperPET MODELS
     9                          ;======================================
    10                          ; Common settings for "normal" machines (4000,8000,8296,SuperPET) with 12" monitor
    11                          ; NOTE: The 8296D uses a different monitor than the 8296 and requires a different register table (see below)
    12                          
    13                          ; REGISTER#->>>      DECIMAL: 00  01  02  03  04  05  06  07  08  09  10  11  12  13  14  15  16  17
    14                          ;                        HEX: 00  01  02  03  04  05  06  07  08  09  0A  0B  0C  0D  0E  0F  10  11  
    15                          ;                             ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==
    16                          ;
    17                          ;---------------------- 40/80x25, 50 Hz, 20 kHz for 12" Internal Monitor (inverted video R12=$10)
    18                          !IF REFRESH=0 {
    19                          CRT_CONFIG_TEXT:	!byte $31,$28,$29,$0f,$27,$00,$19,$20,$00,$09,$00,$00,$10,$00,$00,$00,$00,$00 
    20                          CRT_CONFIG_GRAPHICS:	!byte $31,$28,$29,$0f,$31,$00,$19,$25,$00,$07,$00,$00,$10,$00,$00,$00,$00,$00
    21                          }
    22                          
    23                          ;---------------------- 40/80x25, 60 Hz, 20 kHz for 12" Internal Monitor (inverted video)
    24                          !IF REFRESH=1 {
    25  e72a 3128290f2003191d...CRT_CONFIG_TEXT:	!byte $31,$28,$29,$0f,$20,$03,$19,$1d,$00,$09,$00,$00,$10,$00,$00,$00,$00,$00 
    26  e73c 3128290f28051921...CRT_CONFIG_GRAPHICS:	!byte $31,$28,$29,$0f,$28,$05,$19,$21,$00,$07,$00,$00,$10,$00,$00,$00,$00,$00
    27                          }
    28                          
    29                          ;---------------------- 40/80x25, 50 Hz, 15.625 kHz (PAL)  for External Monitor (inverted video)
    30                          !IF REFRESH=2 {
    31                          CRT_CONFIG_TEXT:	!byte $3f,$28,$2f,$14,$24,$7b,$19,$20,$00,$07,$00,$00,$10,$00,$00,$00,$00,$00 
    32                          CRT_CONFIG_GRAPHICS:	!byte $3f,$28,$2f,$14,$24,$7b,$19,$20,$00,$07,$00,$00,$10,$00,$00,$00,$00,$00
    33                          }
    34                          
    35                          ;---------------------- 40/80x25, 60 Hz, 15.748 kHz (NTSC) for External Monitor (inverted video)
    36                          !IF REFRESH=3 {
    37                          CRT_CONFIG_TEXT:	!byte $3f,$28,$32,$12,$1e,$06,$19,$1C,$00,$07,$00,$00,$10,$00,$00,$00,$00,$00 
    38                          CRT_CONFIG_GRAPHICS:	!byte $3f,$28,$32,$12,$1e,$06,$19,$1C,$00,$07,$00,$00,$10,$00,$00,$00,$00,$00
    39                          }
    40                          
    41                          ;---------------------- 40/80x25, 50 Hz, 15 kHz for 9" Internal Monitor (non-inverted video)
    42                          !IF REFRESH=4 {
    43                          CRT_CONFIG_TEXT:	!byte $3F,$28,$30,$8E,$20,$00,$19,$1C,$00,$09,$00,$00,$00,$00,$00,$00,$00,$00 
    44                          CRT_CONFIG_GRAPHICS:	!byte $3F,$28,$30,$8E,$20,$00,$19,$1C,$00,$07,$00,$00,$00,$00,$00,$00,$00,$00 
    45                          }
    46                          
    47                          ;---------------------- 40/80x25, 60 Hz, 15 kHz for 9" Internal Monitor (non-inverted video)
    48                          !IF REFRESH=5 {
    49                          CRT_CONFIG_TEXT:	!byte $3F,$28,$30,$8E,$20,$00,$19,$1C,$00,$09,$00,$00,$00,$00,$00,$00,$00,$00 
    50                          CRT_CONFIG_GRAPHICS:	!byte $3F,$28,$30,$8E,$20,$00,$19,$1C,$00,$07,$00,$00,$00,$00,$00,$00,$00,$00 
    51                          }
    52                          
    53                          ;===============
    54                          ; 8296D MACHINES
    55                          ;===============
    56                          ; The 8296D has a different monitor than standard machines and requires slightly modified timing
    57                          
    58                          ;---------------------- 40/80x25, 50 Hz, 16.949 kHz for 12" Internal 8296D Monitor (V1)
    59                          !IF REFRESH=82 {
    60                          CRT_CONFIG_TEXT:	!byte $3A,$28,$2C,$08,$20,$09,$19,$1D,$00,$09,$00,$00,$10,$00,$00,$00,$00,$00
    61                          CRT_CONFIG_GRAPHICS:	!byte $3A,$28,$2C,$08,$29,$03,$19,$22,$00,$07,$00,$00,$10,$00,$00,$00,$00,$00
    62                          }
    63                          
    64                          ;---------------------- 40/80x25, 50 Hz, 16.949 kHz for 12" Internal 8296D Monitor (V2)
    65                          !IF REFRESH=83 {
    66                          CRT_CONFIG_TEXT:	!byte $32,$28,$28,$08,$26,$02,$19,$20,$00,$09,$00,$00,$10,$00,$00,$00,$00,$00
    67                          CRT_CONFIG_GRAPHICS:	!byte $32,$28,$28,$08,$30,$00,$19,$25,$00,$07,$00,$00,$10,$00,$00,$00,$00,$00
    68                          }
    69                          
    70                          
    71                          ;======================
    72                          ; Extended/Experimental
    73                          ;======================
    74                          ; NOTE: Screens larger than 25 lines are for 8296 ONLY!!! The 8296 has additional screen RAM.
    75                          ;       These settings push the monitor to it's maximum possible resolution. Because of this you loose
    76                          ;       the ability to expand the line height in 'text' mode.
    77                          
    78                          ;---------------------- 40/80x32, 60 Hz, ?? kHz for 12" Internal Monitor (8296 ONLY!!!!)
    79                          !IF REFRESH=90 {
    80                          CRT_CONFIG_TEXT:	!byte 47,40,41,15,40,7,32,39,0,7,0,0,16,0,0,0,0,0 
    81                          CRT_CONFIG_GRAPHICS:	!byte 47,40,41,15,40,7,32,39,0,7,0,0,16,0,0,0,0,0 
    82                          }
    83                          
    84                          ;---------------------- 40/80x35, 60 Hz, ?? kHz for 12" Internal Monitor (8296 ONLY!!!!)
    85                          !IF REFRESH=91 {
    86                          CRT_CONFIG_TEXT:	!byte 47,40,41,15,40,7,35,39,0,7,0,0,16,0,0,0,0,0 
    87                          CRT_CONFIG_GRAPHICS:	!byte 47,40,41,15,40,7,35,39,0,7,0,0,16,0,0,0,0,0 
    88                          }
    89                          
    90                          ;---------------------- 45/90x35, 60 Hz, ?? kHz for 12" Internal Monitor (8296 ONLY!!!!)
    91                          !IF REFRESH=92 {
    92                          CRT_CONFIG_TEXT:	!byte 52,45,45,12,40,17,35,39,0,7,0,0,16,0,0,0,0,0 
    93                          CRT_CONFIG_GRAPHICS:	!byte 52,45,45,12,40,17,35,39,0,7,0,0,16,0,0,0,0,0 
    94                          }
    95                          
    96                          ;=======================
    97                          ; CUSTOM - You Define It
    98                          ;=======================
    99                          
   100                          ;---------------------- CUSTOM - Your parameters here!
   101                          !IF REFRESH=99 {
   102                          CRT_CONFIG_TEXT:	!byte $3e,$28,$32,$12,$1e,$06,$19,$1C,$00,$07,$00,$00,$10,$00,$00,$00,$00,$00 
   103                          CRT_CONFIG_GRAPHICS:	!byte $3e,$28,$32,$12,$1e,$06,$19,$1C,$00,$07,$00,$00,$10,$00,$00,$00,$00,$00
   104                          }
   105                          

; ******** Source: crtc-tables.asm
    12                          

; ******** Source: editrom80.asm
  1374                          
  1375                          
  1376                          ;*********************************************************************************************************
  1377                          ;** BELL Sound Table  [E74D]
  1378                          ;*********************************************************************************************************
  1379                          
  1380  e74e 0e1e3e7e3e1e0e     SOUND_TAB	!byte $0e,$1e,$3e,$7e,$3e,$1e,$0e	; BELL chime values
  1381                          
  1382                          ;*********************************************************************************************************
  1383                          ;** Screen Line Address Tables  [E755][E76E]
  1384                          ;*********************************************************************************************************
  1385                          

; ******** Source: screen1v.asm
     1                          ; PET/CBM EDIT ROM - Screen line address table - Screen 1 @ $8000 Video (characters)
     2                          ; ================
     3                          ; Variables: ROWS,COLUMNS
     4                          ; These tables are used to calculate the starting address of each line on the screen.
     5                          ; The standard screens are 40x25 and 80x25. Experimental screens can be up to 90x35.
     6                          ; 32 and 64 are included for future support of non-cbm type screens.
     7                          ; When ROWS>25 it assumes maximum 35 rows although less are supported as well.
     8                          
     9                          ;---------- 32 characters wide (32x32 = 1K RAM)
    10                          !IF COLUMNS=32 {
    11                          Line_Addr_Lo	!byte $00,$20,$40,$60,$80,$A0,$C0,$E0,$00,$20,$40,$60,$80,$A0,$C0,$E0
    12                          		!byte $00,$20,$40,$60,$80,$A0,$C0,$E0,$00,$20,$40,$60,$80,$A0,$C0,$E0
    13                          Line_Addr_Hi	!byte $80,$80,$80,$80,$80,$80,$80,$80,$81,$81,$81,$81,$81,$81,$81,$81
    14                          		!byte $82,$82,$82,$82,$82,$82,$82,$82,$83,$83,$83,$83,$83,$83,$83,$83
    15                          }
    16                          
    17                          ;---------- 40 characters wide 
    18                          !IF COLUMNS=40 {
    19                          Line_Addr_Lo	!byte $00,$28,$50,$78,$a0,$c8,$f0,$18,$40,$68,$90,$b8,$e0,$08,$30,$58
    20                          		!byte $80,$a8,$d0,$f8,$20,$48,$70,$98,$c0
    21                          !if ROWS>25 {	!byte $e8,$10,$38,$60,$88,$b0,$d8,$00,$28,$50 }
    22                          
    23                          Line_Addr_Hi	!byte $80,$80,$80,$80,$80,$80,$80,$81,$81,$81
    24                          		!byte $81,$81,$81,$82,$82,$82,$82,$82,$82,$82
    25                          		!byte $83,$83,$83,$83,$83
    26                          !if ROWS>25 {	!byte $83,$84,$84,$84,$84,$84,$84,$85,$85,$85 }
    27                          }
    28                          
    29                          ;---------- 64 characters wide (64x32 = 2K RAM)
    30                          !IF COLUMNS=64 {
    31                          Line_Addr_Lo	!byte $00,$40,$80,$C0,$00,$40,$80,$C0,$00,$40,$80,$C0,$00,$40,$80,$C0
    32                          		!byte $00,$40,$80,$C0,$00,$40,$80,$C0,$00,$40,$80,$C0,$00,$40,$80,$C0
    33                          Line_Addr_Hi	!byte $80,$80,$80,$80,$81,$81,$81,$81,$82,$82,$82,$82,$83,$83,$83,$83
    34                          		!byte $84,$84,$84,$84,$85,$85,$85,$85,$86,$86,$86,$86,$87,$87,$87,$87
    35                          }
    36                          
    37                          ;---------- 80 characters wide 
    38                          !IF COLUMNS=80 {
    39  e755 0050a0f04090e030...Line_Addr_Lo	!byte $00,$50,$a0,$f0,$40,$90,$e0,$30,$80,$d0
    40  e75f 2070c01060b00050...		!byte $20,$70,$c0,$10,$60,$b0,$00,$50,$a0,$f0
    41  e769 4090e03080         		!byte $40,$90,$e0,$30,$80
    42                          !if ROWS>25 {	!byte $d0,$20,$70,$c0,$10,$60,$b0,$00,$50,$a0,$f0 }
    43                          
    44  e76e 8080808081818182...Line_Addr_Hi	!byte $80,$80,$80,$80,$81,$81,$81,$82,$82,$82
    45  e778 8383838484848585...		!byte $83,$83,$83,$84,$84,$84,$85,$85,$85,$85
    46  e782 8686868787         		!byte $86,$86,$86,$87,$87
    47                          !if ROWS>25 {	!byte $87,$88,$88,$88,$89,$89,$89,$8a,$8a,$8a,$8a }
    48                          }
    49                          
    50                          ;---------- 90 characters wide
    51                          !IF COLUMNS=90 {
    52                          Line_Addr_Lo	!byte $00,$5a,$b4,$0e,$68,$c2,$1c,$76,$d0,$2a,$84,$de,$38,$92,$ec,$46
    53                          		!byte $a0,$fa,$54,$ea,$08,$62,$bc,$16,$70,$ca,$24,$7e,$d8,$32,$8c,$e6
    54                          		!byte $40,$9a,$f4
    55                          Line_Addr_Hi	!byte $80,$80,$80,$81,$81,$81,$82,$82,$82,$83,$83,$83,$84,$84,$84,$85
    56                          		!byte $85,$85,$86,$86,$87,$87,$87,$88,$88,$88,$89,$89,$89,$8a,$8a,$8a
    57                          		!byte $8b,$8b,$8b
    58                          }

; ******** Source: editrom80.asm
  1386                          					; Screen RAM address table
  1387                          		!IF COLOURPET > 0 { !SOURCE "screen1c.asm" }			; Colour address table (future hardware)
  1388                          
  1389                          ;*********************************************************************************************************
  1390                          ;** Small patches here  [E787]
  1391                          ;*********************************************************************************************************
  1392                          
  1393                          !IF BACKARROW =1 { !SOURCE "editbarrow.asm" }		; Patch for BackArrow toggling of screen mode
  1394                          
  1395                          ;#########################################################################################################
  1396  e787 cd                 !IF CRUNCH=0 {	!byte $cd }		; to match 901474-04
  1397                          
  1398                          ;*********************************************************************************************************
  1399                          ;** FILLER
  1400                          ;*********************************************************************************************************
  1401                          ; There are approximately 120 unused bytes HERE in a CODEBASE 1 EditROM.
  1402                          ; When some patches are applied they will push more code here and have less fill bytes.
  1403                          ; If too many patches are applied ACME will generate a "produced too much code" error.
  1404                          
  1405  e788 aaaaaaaaaaaaaaaa...		!IF NOFILL=0 { !FILL $e800-*,$aa }	; Fill to end of 2K
  1406                          
  1407                          ;#########################################################################################################
  1408                          ;END! DO NOT ADD ANYTHING BELOW THIS LINE!!!!!!!!

; ******** Source: editrom.asm
    39                          			; 80-column CODEBASE
    40                          	!IF CODEBASE=2 {!SOURCE "editrom82.asm"}			; 80-column EXTENDED CODEBASE
    41                          
    42                          ;=======================================================================
    43                          ; Determine if we need to assemble a 4K ROM
    44                          ;=======================================================================
    45                          ; We must include this area if:
    46                          ;   1) We are using CODEBASE 2
    47                          ;   2) Certain EXTended features are enabled
    48                          ;   3) BACKARROW feature needs relocating.
    49                          
    50                          	!IF ((CODEBASE=2) | ((COLOURPET + ESCCODES + WEDGE + EXECUDESK + SS40 + AUTORUN + KEYRESET) > 0) | (BACKARROW=2) | (CODEBASE=0 & KEYSCAN=3)) {
    51                          		!SOURCE "editrom_hi.asm"
    52                          	}
    53                          
    54                          ; Do not place code below this point!
