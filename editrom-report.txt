
; ******** Source: editrom.asm
     1                          ; PET/CBM EDIT ROM - Steve J. Gray - Started: Nov 29/2013
     2                          ; ================
     3                          ; This is the main Assembler file. It brings in the USER-DEFINED variables and acts on them to build a
     4                          ; functional EDITOR ROM.
     5                          ;
     6                          ;---------------------- Get User Variables and validate some settings, and set output file
     7                          

; ******** Source: edit.asm
     1                          ; PET/CBM EDIT ROM - Steve J. Gray - Started: Nov 29/2013
     2                          ; ================
     3                          ; A Project to create replacement EDIT ROMs for the PET/CBM line of computers.
     4                          ; Use MAKE.BAT to assemble (ACME.EXE must be in same folder or in search path).
     5                          ; For complete documentation see:
     6                          ;      http://www.cbmsteve.ca/editrom/index.html
     7                          ;
     8                          ; Edit these settings to choose which features are included.
     9                          ;
    10                          ; The most important is the CODEBASE setting. It determines which main code to use, which will determine
    11                          ; how many features are available:
    12                          ;
    13                          ;   CODEBASE=0 for 40-column (30xx/40xx) machines with Universal Dynamic Motherboard. Line Linking.
    14                          ;   CODEBASE=1 for 80-column (80xx/82xx/9000) machines with Universal Dynamic Motherboard. No Line Linking.
    15                          ;   CODEBASE=2 for 80-column (8296/8296D) machines (mostly DIN keyboard versions). No Line Linking.
    16                          ;
    17                          ; If there are no options listed it means that support has not been added yet!
    18                          ;
    19                          ; NOTE!: Not all combinations may be valid!!
    20                          ; NOTE!: SuperPET's require a special adapter to use EPROMS and have compatibility issues with 4K edit roms (see web page)
    21                          ;
    22                          ;----------------------------------------------------------------------------------------------------------------------------
    23                          ; The following DATE and COMMENT strings will be placed in the IO area (if used).
    24                          ; Take care that comments do not overflow into code space!
    25                          
    26                          !macro DATE      { !pet "2025-08-14" }
    27                          !macro COMMENT   { !pet "sjg-editrom" }
    28                          
    29                          ;----------------------------------------------------------------------------------------------------------------------------
    30                          
    31                          ; NAME		FEATURE				VALID OPTIONS			NOTES / FUTURE OPTIONS
    32                          ;---------	-------				-------------			----------------------
    33                          CODEBASE  = 1   ; Code Base			0=4000, 1=8000, 2=8296		Important!!! Read Webpage for details
    34                          OPTROM    = 0   ; Location of EXT code		0=$E800-EFFF, 1=$9000, 2=$A000  Normal is 0.
    35                          
    36                          ;-- Keyboard
    37                          KEYSCAN   = 1   ; Keyboard Scanner		0=Normal,1=Business,2=DIN
    38                          KEYBOARD  = 3	; Keyboard type:		0=N-QWERTY,1=B-QWERTY,2=DIN,3=C64,4=B-SJG,5=N-SJG,6=B-QWERTZ,7=B-AZERTY,8=CBM-II (req hw mod)
    39                          REPEATOPT = 0	; Key Repeat Option		0=No (Always ON), 1=Yes
    40                          FONTSET   = 0	; Initial Screen Font		0=Text/Lower, 1=Upper/Graphics	Generally: 40xx machines=1, 8xxx machines=0
    41                          
    42                          ;-- Screen
    43                          REFRESH   = 1	; Screen refresh:		0=Euro,1=N.America,2=PAL,3=NTSC,4=9",82=8296D#1,83=8296D#2,90=32-line,91=35-line,92=90x35,99=Custom
    44                          COLUMNS   = 80	; Screen Width			40,80,90,32 columns		Special cases 32 or 90.
    45                          ROWS      = 25  ; Screen Height			25,35,16 rows			Special cases 16 or 35.
    46                          
    47                          ;-- Line Frequency (50/60)
    48                          HERTZ     = 60	; Line Frequency (Clock):	50=Euro,60=N.America
    49                          IRQFIX    = 0   ; Fix Jiffy Clock?		0=No, 1=Yes			Still needs investigating.
    50                          
    51                          ;-- ESC Codes
    52                          ESCCODES  = 1	; Add ESC codes? 		0=No, 1=Yes			Enable when using COLOURPET or SS40.
    53                          VIDSWITCH = 0   ; Video Mode Select ESC codes?  0=No, 1=Yes			Requires ESC Codes! ESC+0 to ESC+9 to Switch CRTC parameters.
    54                          
    55                          ;-- EXTended Features
    56                          EXECUDESK = 0	; Add Execudesk Menu?		0=No, 1=Yes, 2=Yes/OPTROM	Note: Requires BOOT to TEXT mode!
    57                          COLOURPET = 0	; ColourPET additions?		0=No, 1=Yes			Requires ESC Codes! ESC+0 to ESC+? to set Colour (unless VIDSWITCH=1).
    58                          UPET      = 0   ; Is a Ultra-PET/Micro-PET?     0=No, 1=Yes                     For special Reboot - Andre Fachat's project
    59                          
    60                          ;-- AutoRUN Features
    61                          AUTORUN   = 1   ; Set for BANNER and/or WEDGE	0=No, 1=Yes			Enable if you use any AUTOBOOT feature below
    62                          BYPASS    = 0   ; Check for key to bypass? 	0=No, 1=Yes			Valid when AUTORUN=1. Hold key on ROW9 to bypass.
    63                          BANNER    = 1  	; Custom Banner (power on msg)?	0=No, N=Banner# (1-21,98,99)    Valid when AUTORUN=1. Refer to docs or source. 99=custom message
    64                          WEDGE     = 1	; DOS Wedge?			0=No, 1=Yes			Valid when AUTORUN=1.
    65                          WEDGEMSG  = 0	; Show wedge message?		0=No, 1=Yes			Valid when AUTORUN=1 and WEDGE>0.
    66                          DISKBOOT  = 0	; Boot first file on disk?	0=No, 1=Yes			Valid when AUTORUN=1.
    67                          
    68                          ;-- 40/80 Switching
    69                          SOFT40    = 0	; 40 columns on 8032s?		0=No, 1=Yes			Do NOT enable SOFT40 and SS40 at the same time!
    70                          SS40      = 1	; Software Switchable Soft-40	0=No, 1=Yes			Also set ESCCODES=1. Also if BACKARROW>0 and BACKACTION=1.
    71                          SS40MODE  = 80  ; Initial SS40 Mode		40 or 80 columns		Valid when SS40=1.
    72                          HARD4080  = 1   ; Hardware 40/80 Board?         0=No, 1=Yes			Valid when SS40=1.
    73                          
    74                          ;-- Misc Options
    75                          KEYRESET  = 0	; Add keyboard reset? 		0=No, 1=Yes
    76                          SILENT    = 0	; Disable BELL/CHIME		0=Normal, 1=Disabled
    77                          BACKARROW = 1   ; SHIFT-Backarrow Hack code?	0=NO, 1=Yes, 2=Yes EXT		Enable Shift-Backarrow, and where to put the code.
    78                          BACKACTION= 0   ; Backarrow Action		0=Text/Graphic, 1=40/80		Which Backarrow Action? NOTE: 40/80 requires ESC Codes!
    79                          
    80                          MOT6845   = 0   ; Is CRTC a Motorola6845?       0=No, 1=Yes			Probably 0=No for compatibility.
    81                          INFO      = 0   ; Add proj info to code area?	0=NO, 1=Yes,2=Yes+FONT		INFO=2 shows character set at top of screen
    82                          
    83                          CRUNCH    = 0   ; Remove unneeded code?		0=No, 1=Yes			Removes NOPs, filler, and unreachable code.
    84                          BUGFIX    = 1   ; Correct Known bugs?		0=No, 1=Yes			Fix known bugs
    85                          DEBUG 	  = 0	; Add debugging?		0=No, 1=Yes			Add code to display debug info on screen
    86                          NOFILL    = 0   ; Disable FILL?			0=No, 1=Yes			Lets you test assemble but will NOT generate usable code!!!!!
    87                          
    88                          ;-- ColourPET Options
    89                          COLOURVER = 0	; ColourPET Hardware Version	0=Beta,1=Normal/uPET		0=ColourRAM at $8400, 1=$8800 (use for VICE).
    90                          COLOURMODE= 0	; ColourPET Hardware Type	0=Digital, 1=Analog
    91                          DEFAULTFG = 2	; ColourPET Foreground colour   0 to 15 RGBI 			0=black,1=DkGry,2=DkBlu ,3=LtBlu, 4=DkGrn, 5=Grn,   6=DkCyan,7=LtCyan
    92                          DEFAULTBG = 2	; ColourPET Background colour   0 to 15 RGBI 			8=DKred,9=LTred,10=DKpur,11=LTpur,12=DkYel,13=LtYel,14=LtGry,15=White
    93                          DEFAULTBO = 2   ; ColourPET Border colour       0 to 15 RGBI
    94                          BYPASSFG  = 5   ; ColourPET Bypass FG     	0 to 15 RGBI			Colours when AUTOSTART is bypassed.
    95                          BYPASSBG  = 0   ; ColourPET Bypass BG     	0 to 15 RGBI

; ******** Source: editrom.asm
     8                          					; Include USER-DEFINED variables
     9                          	!IF COLOURPET>0 { ESCCODES=1 }					; Make sure ESC Codes is ON if SS40 or COLOURPET is enabled
    10                          	!IF SS40=1      { SOFT40=0 }                         		; Make sure SOFT40 is OFF if SS40 is enabled
    11                          
    12                          	!IF COLOURPET=0 { !TO "editrom.bin",plain }			; Generic output file with no load address
    13                          	!IF COLOURPET>0 { !TO "cpetrom.bin",plain }			; ColourPET output file with no load address
    14                          
    15                          ;---------------------- These are the symbol definitions for PET/CBM memory and IO chips
    16                          

; ******** Source: memzeropage.asm
     1                          ; PET/CBM EDIT ROM - Standard Zero Page locations/variables/storage
     2                          ; ================
     3                          ; Descriptions are from Butterfield's memory maps from Transactor
     4                          
     5                          ;		--------------- Common Usage (All Codebases)
     6                          
     7                          Basic_USR 	= $00		; USR Jump
     8                          USRADD 		= $01		; USR Jump
     9                          CHARAC 		= $03		; Search Character
    10                          ENDCHR 		= $04		; Scan between Quotes Flag
    11                          COUNT 		= $05		; Input buffer pointer. # of subscripts
    12                          DIMFLG 		= $06		; Default DIM flag
    13                          VALTYP 		= $07		; Type: FF=string, 00=numeric
    14                          INTFLG 		= $08		; Type: 80=integer, 00=floating point
    15                          GARBFL 		= $09		; Flag: DATA scan; List quote; memory
    16                          SUBFLG 		= $0a		; Flag: Subscript; FNX flag
    17                          INPFLG 		= $0b		; 0=input; $40=GET; $98=READ
    18                          TANSGN 		= $0c		; ATN sign/Comparison Evaluation Flag
    19                          DS_1 		= $0d		; Disk Status DS$ descriptor
    20                          DS_2 		= $0e		; Disk Status DS$ descriptor
    21                          DS_3 		= $0f		; Disk Status DS$ descriptor
    22                          IOPMPT 		= $10		; Current i/o device for prompt suppress
    23                          LINNUM 		= $11		; Integer value (for SYS, GOTO etc)
    24                          TEMPPT 		= $13		; Pointers for descriptor stack
    25                          LASTPT 		= $14	 	
    26                          TEMPST 		= $16		; Descriptor stack (temp strings)
    27                          INDEXA 		= $1f		; Utility pointer area
    28                          INDEXB 		= $21
    29                          FAC3EX 		= $23		; Product area for multiplication
    30                          FAC3M1 		= $24		
    31                          FAC3M2 		= $25
    32                          FAC3M3 		= $26
    33                          FAC3M4 		= $27
    34                          TXTTAB 		= $28		; Pointer: Start of BASIC
    35                          VARTAB 		= $2a		; Pointer: Start of Variables
    36                          ARYTAB 		= $2c		; Pointer: Start of Arrays
    37                          STREND 		= $2e		; Pointer: End of Arrays
    38                          FRETOP 		= $30		; Pointer: String Storage (moving down)
    39                          FRESPC 		= $32		; Pointer: Utility string
    40                          MEMSIZ 		= $34		; Pointer: Limit of Memory
    41                          CURLIN 		= $36		; Current BASIC line number
    42                          OLDLIN 		= $38		; Previous BASIC line number
    43                          OLDTXT 		= $3a		; Pointer: BASIC statement for CONT
    44                          DATLIN 		= $3c		; Current DATA line number
    45                          DATPTR 		= $3e		; Current DATA address
    46                          INPPTR 		= $40		; Input Vector
    47                          VARNAM 		= $42		; Current variable name
    48                          VARPTR 		= $44		; Current variable address
    49                          FORPNT 		= $46		; Variable pointer for FOR/NEXT
    50                          YSAVE 		= $48		; Y-Save; op-save; BASIC pointer save
    51                          ACCSYM 		= $4a		; Comparison symbol accumulator
    52                          FUNCPT 		= $4b		; Misc work area/pointers
    53                          DESCPT 		= $4d
    54                          GARBSS 		= $50
    55                          JUMPER 		= $51		; Jump vector for functions
    56                          FUNJMP 		= $52		
    57                          FACTPA 		= $54		; Misc numeric work area
    58                          TMPPTA 		= $55
    59                          TMPPTB 		= $57
    60                          FACTPB 		= $59
    61                          TMPVA2 		= $5a
    62                          TMPPTC 		= $5c
    63                          FAC1EX 		= $5e		; Accum#1: Exponent
    64                          FAC1M1 		= $5f		; Accum#1: Mantissa
    65                          FAC1M2 		= $60
    66                          FAC1M3 		= $61
    67                          FAC1M4 		= $62
    68                          FAC1SI 		= $63		; Accum#1: Sign
    69                          SGNFLG 		= $64		; Series evaluation constant pointer
    70                          BITS 		= $65		; Accum#1: hi-order (overflow)
    71                          FAC2EX 		= $66	
    72                          FAC2M1 		= $67
    73                          FAC2M2 		= $68
    74                          FAC2M3 		= $69
    75                          FAC2M4 		= $6a
    76                          FAC2SI 		= $6b
    77                          STRPTR		= $6c
    78                          FAC1M5 		= $6d
    79                          TMPPTD 		= $6e
    80                          CHRGET 		= $70
    81                          CHRGETX		= $73		; UNUSED
    82                          CHRGOT 		= $76
    83                          TXTPTR 		= $77
    84                          ISNUM 		= $7d
    85                          RNDX 		= $88
    86                          JIFFY_CLOCK 	= $8d
    87                          CINV 		= $90
    88                          CBINV 		= $92
    89                          NMINV 		= $94
    90                          STATUS		= $96
    91                          KEYPRESSED	= $97		; Which KEY down - $FF = no key
    92                          KEYFLAGS	= $98		; SHIFT KEY - $01 = Pressed
    93                          JIFFY_CORR	= $99		; Correction for JIFFY clock
    94                          STKEY		= $9b		; Keyswitch PIA - Stop and Reverse Flag
    95                          SVXT		= $9c		; Timing Constant for TAPE
    96                          VERCK		= $9d		; Tape mode: 0=Load, 1=Verify
    97                          CharsInBuffer 	= $9e		; Number of characters in keyboard buffer
    98                          ReverseFlag 	= $9f		; Screen Reverse Flag
    99                          C3PO 		= $a0		; IEEE Output - $FF=character pending
   100                          LastInputCol	= $a1		; End of Line for input pointer
   101                          InputRow 	= $a3		; Cursor Log: Row
   102                          InputCol 	= $a4		; Cursor Log: Column
   103                          BSOUR 		= $a5		; IEEE output buffer
   104                          Key_Image	= $a6		; Key Image
   105                          Blink		= $a7		; Cursor Flag: 0=Flash Cursor
   106                          BLNCT		= $a8		; Cursor Timing Countdown
   107                          CursorChar	= $a9		; Character Under Cursor
   108                          BlinkPhase	= $aa		; Cursor in Blink phase
   109                          SYNO		= $ab		; EOT (End of Tape) received from Tape
   110                          CRSW		= $ac		; Input from Screen or Keyboard
   111                          TEMPX		= $ad		; Save X
   112                          LDTND		= $ae		; How many open files?
   113                          DFLTN		= $af		; Input Device - Normally 0
   114                          DFLTO		= $b0		; Output CMD Device - Normally 3
   115                          PRTY		= $b1		; TAPE character parity
   116                          DPSW		= $b2		; Byte Received FLAG
   117                          SAVELA		= $b3		; Logical Address temporary save
   118                          TIMCMD		= $b4		; Tape buffer character / MLM command
   119                          MONCNT		= $b5		; Filename pointer / MLM Flag, counter
   120                          TMPZB7		= $b7
   121                          TMPZB9		= $b9
   122                          TMPZBA		= $ba
   123                          BUFPNT		= $bb
   124                          INBIT		= $bd
   125                          BITCI		= $be
   126                          RINONE		= $bf
   127                          PTR1		= $c0
   128                          PTR2		= $c1
   129                          RIDATA		= $c2
   130                          RIPRTY		= $c3
   131                          ScrPtr		= $c4		; Pointer to character screen line
   132                          CursorCol	= $c6		; Position of cursor on above line
   133                          SAL		= $c7		; Utility Pointer - Tape or Scrolling
   134                          EAL		= $c9		; Tape end address / End of current program
   135                          CMP0		= $cb		; Tape Timing Constants (ColourPET pointer to colour line)
   136                          BLNSW		= $cc		; Tape Timing Constants (ColourPET pointer to colour line)
   137                          QuoteMode	= $cd		; 0=Direct Cursor, else programmed
   138                          BITTS		= $ce		; Tape read timer 1 enabled
   139                          EOT		= $cf		; EOT recieved from TAPE
   140                          READERR		= $d0		; Read Character error
   141                          FNLEN		= $d1		; Number of characters in filename
   142                          LA		= $d2		; Current file Logical Address
   143                          SA		= $d3		; Current file Secondary Address
   144                          FA		= $d4		; Current file Device number
   145                          RightMargin	= $d5		; Window RIGHT margin
   146                          TAPE1		= $d6		; Pointer: Start of Tape Buffer
   147                          CursorRow	= $d8		; Line where cursor lives
   148                          DATAX		= $d9		; Last Key / Checksum / Misc
   149                          FNADR		= $da		; Filename pointer
   150                          INSRT		= $dc		; Number of inserts outstanding
   151                          ROPRTY		= $dd		; Write shift word / read character in
   152                          FSBLK		= $de		; Tape blocks remaining to write
   153                          MYCH		= $df		; Serial word buffer
   154                          CAS1		= $f9		; Cassette #1 status
   155                          CAS2		= $fa		; Cassette #2 status
   156                          STAL		= $fb		; Tape start address/ MLM
   157                          MEMUSS		= $fd		; MLM / DOS pointer / Misc
   158                          
   159                          ;		---------------- 40-Column Only Usage (Codebase 0)
   160                          ;		*** Currently, We cannot use ESC codes with CODEBASE 0 because this area is used for line linking!
   161                          ;		*** The line link table uses 24 bytes, 1 for each line (line 25 can never be linked)
   162                          ;		*** The line link table also holds the HI byte for the 40-col screen line table. It may be possible to
   163                          ;		*** Move the HI byte back into ROM like in the 80 column code, then pack the 24 bytes down to 3 using
   164                          ;		*** BITS instead. This would free 21 bytes that could be used for 80-column plus enhanced features.
   165                          ;		*** However, the code to handle BIT-based line linking would be more complicated and take more code.
   166                          
   167                          !IF CODEBASE=0 {
   168                          LineLinkTable   = $e0		; 40-Col Line Link Table (to $F8)
   169                          
   170                          } ELSE {
   171                          
   172                          ;		---------------- 80-Column Only Usage (Codebase 1 or 2)
   173                          ;		*** These are the normal 80-column screen editor locations. Since we have 80 columns there is no need
   174                          ;		*** for a line-link table, therefor we can use this for enhanced 80-column functions (windowing).
   175                          
   176                          TopMargin	= $e0		; Window TOP line
   177                          BotMargin	= $e1		; Window BOTTOM line
   178                          LeftMargin	= $e2		; Window LEFT margin
   179                          XMAX		= $e3		; Maximum characters in input buffer
   180                          RPTFLG		= $e4		; Key REPEAT flag
   181                          KOUNT		= $e5		; Repeat countdown
   182                          DELAY		= $e6		; New key marker
   183                          CHIME		= $e7		; Chime Time
   184                          HOMECT		= $e8		; Home count
   185                          SCRIV		= $e9		; Screen Input Vector  (E9/EA)
   186                          SCROV		= $eb		; Screen Output Vector (EB/EC)
   187                          ; $ED-F7 			; UNUSED
   188                          JIFFY6DIV5	= $f8		; TI clock adjust (speed by 6/5)
   189                          }
   190                          
   191                          ;		---------------- These are Customized Locations
   192                          ;      		*** With Codebase 1 the area from $ED-$F7 are unused
   193                          ;      		*** With Codebase 0 the area is part of the LineWrap Table
   194                          ;		***  ( can these move to TAPE BUFFER#1? - will conflict with tape and some ML programs)
   195                          
   196                          ; If ESC codes are not active but Backarrow Hack is set to Toggle 40/80
   197                          ; then define Screen Width Location
   198                          !IF (ESCCODES = 0) AND (BACKARROW>0) AND (BACKACTION=1) {
   199                          SCNWIDTH	= $0381		; Screen Mode (40 or 80) for SS40
   200                          }
   201                          
   202                          !IF ESCCODES = 1 {
   203                            !IF CODEBASE = 0 {
   204                          
   205                          ;               *** CODEBASE 0 must avoid line-link table! We will use TAPE#2 buffer (which DOS uses)
   206                          
   207                          SCNWIDTH	= $0381		; Screen Mode (40 or 80) for SS40
   208                          LASTCHAR	= $0382		; Last Key Pressed - used to remember ESC key
   209                          BELLMODE	= $0383		; 0=Disable, 1=Enable BELL/CHIME
   210                          EUROFLAG        = $0384		; 0=ASCII, 1=DIN
   211                          SCN4080BOARD    = $0385		; Flag for Hardware 40/80 Column Switcher board
   212                          
   213                          MYZP            = $00           ; LO General ZP pointer (we don't have a good location for this!)
   214                          ;                 $01           ; HI                    (we will take over the USR jump vector which is rarely used)
   215                          
   216                            } ELSE {
   217                          ;               *** CODEBASE 1/2 can safely go where line-link table would be
   218                          
   219                          SCNWIDTH	= $f0		; Screen Mode (40 or 80) for SS40
   220                          LASTCHAR	= $f1		; Last Key Pressed - used to remember ESC key
   221                          BELLMODE	= $f2		; 0=Disable, 1=Enable BELL/CHIME
   222                          EUROFLAG        = $f3		; 0=ASCII, 1=DIN
   223                          SCN4080BOARD    = $f4		; Flag for Hardware 40/80 Column Switcher board
   224                          MYZP            = $f5           ; LO General ZP pointer
   225                          ;                 $f6           ; HI
   226                          ;                 $f7		; not used
   227                          
   228                            }
   229                          }

; ******** Source: editrom.asm
    17                          				; $0000-00FF	Zero Page 

; ******** Source: memlow.asm
     1                          ; PET/CBM EDIT ROM - Standard Low Mem locations/variables/storage
     2                          ; ================
     3                          
     4                          ;------------------------ Common Usage
     5                          
     6                          STACK 			= $0100	;Processor Stack
     7                          BUF 			= $0200	;MLM work area; Input buffer
     8                          LAT 			= $0251	;File Logical Address Table
     9                          FAT 			= $025b	;File Device Number Table
    10                          SAT 			= $0265	;File Secondary Address Table
    11                          KEYD 			= $026f	;Keyboard input buffer
    12                          TAPEB1 			= $027a	;TAPE#1 input buffer
    13                          TAPEB2                  = $033a ;TAPE#2 input buffer (to $03F9)
    14                          
    15                          ;------------------------ Shared with TAPE#2 buffer
    16                          
    17                          NextTab 		= $033a	;DOS character pointer
    18                          DOS_Drive_1 		= $033b	;DOS drive 1 flag
    19                          DOS_Drive_2 		= $033c	;DOS drive 2 flag
    20                          DOS_Length 		= $033d	;DOS length/write flag
    21                          DOS_Syntax 		= $033e	;DOS syntax flags
    22                          DOS_Id 			= $033f	;DOS disk ID
    23                          DOS_Command_Length 	= $0341	;DOS command string count
    24                          DOS_Filename 		= $0342	;DOS filename buffer
    25                          DOS_Command_Buffer 	= $0353	;DOS command string buffer (to $0380)
    26                          ;			  $0381-03e8 ???
    27                          
    28                          ;------------------------ 40-Column Usage
    29                          
    30                          !IF CODEBASE=0 {
    31                          DELAY			= $03e9 ;Repeat Key countdown delay 	(40 col)
    32                          KOUNT			= $03ea ;Delay between repeats 		(40 col)
    33                          XMAX			= $03eb ;Max keyboard buffer size 	(40 col)
    34                          CHIME			= $03ec ;Chime Time 0=off 		(40 col)
    35                          JIFFY6DIV5		= $03ed ;TI clock adjust (speed by 6/5) (40 col) Was: TIADJ
    36                          RPTFLG			= $03ee ;Repeat Flag                    (40 col)
    37                          TABS			= $03ef ;TAB-STOP table			(40 col)
    38                          }
    39                          
    40                          ;------------------------ Common Usage
    41                          
    42                          TABS_SET 		= $03ee	;80 column TAB stop table ($03ee-03f7) ** Should this be $03ef ???? **
    43                          ;			  $03f8 ???
    44                          ; 			  $03f9 ???
    45                          
    46                          ;------------------------ End of TAPE#2 bufer
    47                          
    48                          Reset_Vector 		= $03fa	;Monitor extension vector
    49                          Reset_Param 		= $03fc	;IEEE timeout defeat; $FF=disable
    50                          ;			  $03fd ???
    51                          ;			  $03fe ???
    52                          ;			  $03ff ???
    53                          
    54                          ;------------------------ BASIC Program Area
    55                          

; ******** Source: editrom.asm
    18                          					; $0100-03FC	Low Memory

; ******** Source: memchips.asm
     1                          ; PET/CBM EDIT ROM - Standard Chip Registers and Screen Ram
     2                          ; ================
     3                          
     4                          ;--------------------------- Screen RAM $8000-$8FFF
     5                          
     6                          SCREEN_RAM = $8000					; 40 Col = $8000-83FF, 80 Col = $8000-87FF
     7                          
     8                          !IF COLUMNS = 80 { KBD_MATRIX = $87d0 }			; Used with Extended DIN ROM keyboard scanning routine
     9                          !IF COLUMNS = 40 { KBD_MATRIX = $83e8 }			; First unused byte in SCREEN_RAM
    10                          
    11                          
    12                          ;--------------------------- PIA #1 - 6520 Chip
    13                          
    14                          PIA1_Port_A = $e810					; Keyboard ROW select
    15                          PIA1_Cont_A = $e811
    16                          PIA1_Port_B = $e812					; Keyboard COLUMN read
    17                          PIA1_Cont_B = $e813
    18                          
    19                          ;--------------------------- PIA #2 - 6520 Chip
    20                          
    21                          PIA2_Port_A = $e820
    22                          PIA2_Cont_A = $e821
    23                          PIA2_Port_B = $e822
    24                          PIA2_Cont_B = $e823
    25                          
    26                          ;--------------------------- VIA - 6522 Chip
    27                          
    28                          VIA_Port_B = $e840					; IEEE, Screen Retrace, Cassette motor
    29                          VIA_Port_A = $e841					; Parallel Port (User Port) with handshaking
    30                          VIA_DDR_B = $e842					; Data Direction Register for PORT B
    31                          VIA_DDR_A = $e843					; Data Direction Register for PORT A
    32                          VIA_Timer_1_Lo = $e844				; Timer 1
    33                          VIA_Timer_1_Hi = $e845
    34                          VIA_Timer_1_Latch_Lo = $e846			; Timer 1 Latch
    35                          VIA_Timer_1_Latch_Hi = $e847
    36                          VIA_Timer_2_Lo = $e848				; Timer 2
    37                          VIA_Timer_2_Hi = $e849
    38                          VIA_Shift = $e84a					; Shift Register
    39                          VIA_ACR = $e84b						; Shift Register Control
    40                          VIA_PCR = $e84c
    41                          VIA_IFR = $e84d
    42                          VIA_IER = $e84e
    43                          VIA_Port_A_no_HS = $e84f				; Parallel Port, no handshaking
    44                          
    45                          ;--------------------------- CTRC - 6545 CRT Controller
    46                          
    47                          CRT_Address = $e880					; Register Select Port
    48                          CRT_Status = $e881					; Register DATA port

; ******** Source: editrom.asm
    19                          					; $E800-E8FF	Chips

; ******** Source: memkernal.asm
     1                          ; PET/CBM EDIT ROM - Standard Kernal calls
     2                          ; ================
     3                          ; These are calls from the EDIT ROM to KERNAL entry points
     4                          ;---------------------------------------------------------
     5                          ; Non-vectored calls (direct - caution: could change if KERNAL is changed)
     6                          
     7                          CHKSTOP 	= $F335 ; Check for STOP key
     8                          
     9                          ;----------------- Standard KERNAL Entry Points
    10                          
    11                          BASIN		= $ffcf ; read char from input channel -> A
    12                          BSOUT		= $ffd2	; Write A to stdout
    13                          GETIN		= $ffe4	; read char from keyboard buffer -> A
    14                          UDTIME		= $FFEA	; Update Time
    15                          
    16                          ACPTR		= $f1c0	; input IEEE -> A
    17                          CHKIN		= $ffc6	; stdin from logical file # in X
    18                          CIOUT		= $f19e	; output A -> IEEE
    19                          CKOUT		= $ffc9	; stdout to logical file # in X
    20                          CLOSE		= $f2e0	; close file
    21                          CLSEI		= $f72f	; close and unlisten
    22                          CLRCH		= $ffcc	; reset stdio to defaults
    23                          LISTN		= $f0d5	; send LISTEN
    24                          LOAD		= $f408	; LOAD
    25                          LOADOP		= $f356	; LOAD without pointer change
    26                          FILENOTFOUND	= $f425	; FILE NOT FOUND, return to BASIC
    27                          OPEN		= $f563	; open file
    28                          OPENI		= $f4a5	; open file on IEEE device
    29                          SCNT		= $f2c1	; prepare SETT for logical file A
    30                          SECND		= $f143	; send secondary address A
    31                          SETT		= $f2cd	; set LF,DN,SA from table
    32                          TALK		= $f0d2	; send TALK
    33                          TWAIT		= $f92b	; 
    34                          UNLSN		= $f1b9	; send UNLISTEN
    35                          UNTLK		= $f1ae	; send UNTALK
    36                          RESET		= $fd16	; basic cold start
    37                          STOPEQ		= $f335	; set Z flag if stop key pressed
    38                          STOPR		= $ffe1	; return to basic if stop key pressed

; ******** Source: editrom.asm
    20                          					; $F000-FFFF	Kernal

; ******** Source: membasic4.asm
     1                          ; --------- BASIC 4 ROM ROUTINES
     2                          
     3                          SCROUT	= $e202	; output A to screen
     4                          RDOA	= $d754	; read hex address -> $FB,$FC
     5                          RDOB	= $d763	; read hex byte -> A
     6                          CLRSCR	= $e015	; clear screen
     7                          CRLF	= $d534	; move cursor to next line
     8                          FPOUT	= $cf8d	; write floating point
     9                          INTOUT	= $cf83	; write integer 0-65535 X=LSB,A=MSB
    10                          SCROLD	= $e021	; scroll down
    11                          SCROLU	= $e024	; scroll up
    12                          SPAC2	= $d52e	; write 2 spaces
    13                          SPACE	= $d531	; write space
    14                          STROUTZ	= $bb1d	; A=LSB, Y=MSB			; BASIC4 STROUTZ is broken!
    15                          STROUT	= $bb24	; X=len, STRADR=ptr
    16                          WROA	= $d717	; write hex address
    17                          HEXOUT	= $d722	; write A as hex
    18                          WROB	= $d731	; write hex byte
    19                          WRTWO	= $d731	; write XA to screen
    20                          
    21                          ADRFP	= $cd7f	; uint LSB=$5f, MSB=$60 -> FAC1
    22                          ASCII	= $d73a	; hex digit -> ascii hex digit
    23                          FPINT	= $cdd1	; FAC1 -> uint $61=MSB, $62=LSB
    24                          FPSTR	= $cf93	; fp -> str $0100..NUL
    25                          HEXIT	= $d78d	; hex ascii digit A -> hex digit A
    26                          INTFP	= $c4bc	; int Y=LSB, A=MSB -> FAC1
    27                          STRFP	= $c8eb	; string -> fp
    28                          RDINT	= $b8f6	; read basic text -> LINNUM
    29                          
    30                          ABS	= $cd8e	; FAC1 = ABS(FAC1)
    31                          ADD	= $c9a0	; FAC1 = FAC1 + FAC2
    32                          ATN	= $d32C	; FAC1 = ATN(FAC1)
    33                          COS	= $d282	; FAC1 = COS(FAC1)
    34                          DIV	= $cc48	; FAC1 = FAC2 / FAC1
    35                          EXP	= $d184	; FAC1 = EXP(FAC1)
    36                          FAC12	= $cd45	; FAC2 := FAC1
    37                          
    38                          READY	= $b3ff	; basic warm start
    39                          NEWSTT	= $b74a	; set up next statement for execution
    40                          MOVBLK	= $b357	; move block
    41                          
    42                          LINKPRG	= $b4b6	; rechain lines
    43                          RSTXCLR	= $b5e9	; reset TXTPTR and perform CLR
    44                          STXTPT	= $b622	; reset TXTPTR
    45                          CLR	= $b5f0	; perform CLR
    46                          SCRTCH	= $b5d4	; perform NEW
    47                          
    48                          MAINS	= $b40f	; MAIN's return addr on stack for CHRGET routine

; ******** Source: editrom.asm
    21                          					; BASIC
    22                          
    23                          	!IF COLOURPET=1 { !SOURCE "memcpet.asm" }			; Non-standard memory usage (may change without notice)
    24                          
    25                          ;---------------------- Debug stuff
    26                          
    27                          	DBLINE = SCREEN_RAM + 24 * COLUMNS				; Calculate bottom line of screen for debug
    28                          
    29                          ;=======================================================================
    30                          ; Standard 2K Edit ROM code starts here
    31                          ;=======================================================================
    32                          ; $E000-E7FF are for normal Edit ROMS.
    33                          ; The CODEBASE setting determines which BASE features are included,
    34                          ; which roughly determines which machine they were targetted to.
    35                          ; This area MAY include NEW code depending on SETTINGS. Some new code may
    36                          ; require standard code to be relocated to EXT code area.
    37                          
    38                          	!IF CODEBASE=0 {!SOURCE "editrom40.asm"}			; 40-column CODEBASE

; ******** Source: editrom80.asm
     1                          ; PET/CBM EDIT ROM  - Commented and Adapted by Steve J. Gray, Dec 14, 2015
     2                          ; ================    sjgray@rogers.com
     3                          ;
     4                          ; ***** THIS IS 80-COLUMN CODEBASE *****
     5                          ; 
     6                          ; This is reverse engineered source code for the EDIT ROMs of the Commodore PET/CBM computers.
     7                          ; The "324243-04" ROM was used as a base as it was (AFAIK) the LAST EDIT ROM that Commodore made
     8                          ; for the PET/CBM line; 8296 computer, 50HZ, 80 column, DIN keyboard, 4K size. Addresses inside
     9                          ; [brackets] are original code addresses. This disassembly is a combination of my own disassembly
    10                          ; plus a disassembly from Edilbert Kirk. Both were adapted by me for use with the ACME assembler.
    11                          ;
    12                          ; The EDIT ROM is mapped from $E000 to EFFF (4K). Many Early versions used only $E000-E7FF (2K).
    13                          ; Note that the area from $E800 to $E8FF (256 bytes) is not available due to the I/O chips in this range.
    14                          ;
    15                          ; PET/CBM machines come in several flavours:
    16                          ;    * 40 or 80 column screens
    17                          ;    * Normal, Business, or DIN keyboards
    18                          ;    * 50 or 60 Hz power frequency
    19                          ;    * Specialized options, ie: Execudesk
    20                          ;
    21                          ; In addition I am adapting the EDIT roms to these additional options:
    22                          ;    * ColourPET - My own project to add colour capabilities
    23                          ;    * Alternate Keyboards - Such as the VIC/C64 keyboard
    24                          ;    * Soft40 - Simulate a 40 column screen on 80 column hardware
    25                          ;    * Soft-switchable SOFT40
    26                          ;    * Soft-switchable real 40/80 columns (requires hardware mod)
    27                          ;    * Extended screen editor - C128 or CBM-II compatible ESC sequences
    28                          ;    * Keyboard soft-reset (like CTRL-ALT-DEL on PC's)
    29                          ;    * Autoboot from default drive
    30                          ;    * DOS Wedge
    31                          ;
    32                          ; See EDIT.ASM for assemble OPTIONS!
    33                          ; Use MAKE.BAT to assemble a binary file with the current options.
    34                          ;
    35                          ;-----------------------------------------------------------------------------------------------
    36                          ; BUG!: the 80-column screen editor does not support line-linking. This means that you are
    37                          ;       limited to entering BASIC lines to the maximum width of one screen line.
    38                          ;       This ALSO applies when you have defined a window... you will be limited to the width
    39                          ;       of the window. Take caution when editing BASIC lines inside a window; any line that
    40                          ;       wraps around to the next line will be TRUNCATED if you edit it inside a window!!!!!
    41                          
    42                          ;-----------------------------------------------------------------------------------------------
    43                          * = $e000	; Normal start address for EDIT ROM is $E000
    44                          
    45                          ;*********************************************************************************************************
    46                          ;** Edit ROM Jump Table  [E000]
    47                          ;** Note: Not all KERNAL and BASIC calls go through this table.
    48                          ;** There are FIVE hard-coded entry points: $E0A7, $E116, $E202, $E442, $E600
    49                          ;*********************************************************************************************************
    50                          
    51  e000 4c4be0             EDITOR		JMP RESET_EDITOR	; [E000] Main Initialization (called from Kernal power up reset at $FD16) 
    52  e003 4ca7e0             		JMP GETKEY		; [E003] Get Character From Keyboard Buffer	(FIXED ENTRY POINT. Must not move!)
    53  e006 4c16e1             		JMP INPUT_CHARACTER	; [E006] Input From Screen or Keyboard		(FIXED ENTRY POINT. Must not move!)
    54  e009 4c02e2             		JMP CHROUT_SCREEN	; [E009] Output to Screen			(FIXED ENTRY POINT. Must not move!)
    55  e00c 4c42e4             		JMP IRQ_MAIN		; [E00C] Main IRQ Handler			(FIXED ENTRY POINT. Must not move!)
    56  e00f 4c55e4             		JMP IRQ_NORMAL		; [E00F] Actual IRQ (clock, keyboard scan)
    57  e012 4c00e6             		JMP IRQ_END		; [E012] Return From Interrupt			(FIXED ENTRY POINT. Must not move!)
    58  e015 4c51e0             		JMP WIN_CLEAR		; [E015] Clear Window
    59  e018 4c76e0             		JMP CRT_SET_TEXT	; [E018] Set CRTC to TEXT mode
    60  e01b 4c79e0             		JMP CRT_SET_GRAPHICS	; [E01B] Set CRTC to GRAPHICS mode
    61  e01e 4c7ce0             		JMP CRT_PROGRAM		; [E01E] Program CRTC (Table pointer in A/X, chr set in Y)
    62  e021 4cc8e3             		JMP WIN_SCROLL_DN	; [E021] Scroll Window DOWN
    63  e024 4ce1e3             		JMP WIN_SCROLL_UP	; [E024] Scroll Window UP
    64  e027 4cb8e4             		JMP SCAN_KEYBOARD	; [E027] Scan Keyboard
    65  e02a 4cb5e6             		JMP BEEP		; [E02A] Ring BELL/CHIME
    66  e02d 4c36e0             		JMP SET_REPEAT_MODE	; [E02D] Set REPEAT MODE
    67  e030 4ce1e1             		JMP WIN_SET_TOP		; [E030] Set Window Top
    68  e033 4cdce1             		JMP WIN_SET_BOT		; [E033] Set Window Bottom
    69                          
    70                          ;*********************************************************************************************************
    71                          ;** SET_REPEAT_MODE  [E036]  (Called from Jump Table)
    72                          ;** Sets Repeat mode to 'A'. Flag: $80 = Repeat, $40 = disable
    73                          ;*********************************************************************************************************
    74                          
    75                          SET_REPEAT_MODE
    76                          		!IF REPEATOPT = 1 {
    77                          			STA RPTFLG				;$E4
    78                          		} else {
    79                          			!IF CRUNCH=0 {
    80  e036 ea                 				NOP
    81  e037 ea                 				NOP
    82                          			}
    83                          		}
    84  e038 60                 		RTS
    85                          
    86  e039 aaaaaaaaaaaaaaaa...!IF CRUNCH=0 {	!FILL $e04b-*,$aa }			;#################################################
    87                          
    88                          ;*********************************************************************************************************
    89                          ;** RESET_EDITOR  [E04B]  (Called from Jump Table)
    90                          ;** Initializes Editor, then sets the screen to TEXT or GRAPHICS mode.
    91                          ;*********************************************************************************************************
    92                          
    93                          RESET_EDITOR
    94                          
    95                          !IF COLOURPET=0 {
    96  e04b 200fe6             		JSR INIT_EDITOR				; Initialize Editor
    97                          } ELSE {
    98                          		JSR ColourPET_Init			; Initialize ColourPET settings, then INIT_EDITOR
    99                          }
   100                          
   101  e04e 2076e0             !IF FONTSET=0	{ JSR CRT_SET_TEXT }			; Set Screen to TEXT mode
   102                          !IF FONTSET=1	{ JSR CRT_SET_GRAPHICS }			; Set Screen to GRAPHICS mode
   103                          
   104                          ;*********************************************************************************************************
   105                          ;** WIN_CLEAR  [E051]  (Called from Jump Table)
   106                          ;** This routine Clears the current window. It clears ONLY the screen memory specified.
   107                          ;** Since this is the 80-column codebase there is no line-linking code. Both LO and HI
   108                          ;** screen address tables are in ROM.
   109                          ;*********************************************************************************************************
   110                          
   111  e051 a6e0               WIN_CLEAR	LDX TopMargin				; Window Top line
   112  e053 ca                 		DEX					; prep for loop
   113  e054 e8                 WC_LOOP		INX					; LOOP[  Next line
   114  e055 206ce0             		JSR UPDATE_CURSOR_R2			;   was: CURSOR_LM  ; Was: Cursor_BOL
   115  e058 20c1e1             		JSR ERASE_TO_EOL			;   Erase the line
   116  e05b e4e1               		CPX BotMargin				;   Check if at the last line
   117  e05d 90f5               		BCC WC_LOOP				; ] No, go do next line
   118                          
   119                          ;*********************************************************************************************************
   120                          ;** CURSOR_HOME  [E05F]
   121                          ;** Moves the cursor to the HOME position of the current WINDOW.
   122                          ;*********************************************************************************************************
   123                          
   124  e05f a6e0               CURSOR_HOME	LDX TopMargin				; Go to TOP of window
   125  e061 86d8               		STX CursorRow				; put cursor there too
   126                          
   127                          ;*********************************************************************************************************
   128                          ;** CURSOR_LM  [E063]
   129                          ;** Moves cursor to LEFT MARGIN of the current WINDOW.
   130                          ;*********************************************************************************************************
   131                          
   132  e063 a4e2               CURSOR_LM	LDY LeftMargin				; Get Left margin
   133  e065 84c6               		STY CursorCol				; Set cursor there
   134                          
   135                          ;*********************************************************************************************************
   136                          ;** Update Cursor ROW [E067] - Get pointer from Screen Line Address Tables (and Colour)
   137                          ;*********************************************************************************************************
   138                          
   139                          UPDATE_CURSOR_ROW
   140  e067 a6d8               		LDX CursorRow				; Current Cursor Physical Line Number
   141  e069 4c6fe0             		JMP UPDATE_CURSOR_R3			;
   142                          UPDATE_CURSOR_R2
   143  e06c a4e2               		LDY LeftMargin				; First column of window
   144  e06e 88                 		DEY
   145                          UPDATE_CURSOR_R3
   146  e06f bd68e7             		LDA Line_Addr_Lo,X			; Screen Line Addresses LO
   147                          
   148                          ;*********************************************************************************************************
   149                          ;** Update Screen Pointers
   150                          ;*********************************************************************************************************
   151                          
   152                          UPDATE_SCREEN_PTR
   153                          	!IF COLOURPET=1 {
   154                          		JSR ColourPET_SyncPointersX		; Sync Pointers to Current Line
   155                          	} ELSE {
   156                          		!IF SS40=1 {
   157  e072 2094ed             			JSR SS40_SyncPointersX		; Update screen pointers based on current screen width
   158                          		} ELSE {
   159                          			STA ScrPtr			; Pointer: Current Screen Line Address LO
   160                          			LDA Line_Addr_Hi,X		; Screen Line Addresses HI
   161                          			STA ScrPtr+1         		; Pointer: Current Screen Line Address HI
   162                          		}
   163                          	}
   164  e075 60                 		RTS
   165                          
   166                          ;*********************************************************************************************************
   167                          ;** CRTC Programming and Screen Modes  [E07A]
   168                          ;*********************************************************************************************************
   169                          

; ******** Source: crtc.asm
     1                          ; PET/CBM EDIT ROM - CRTC Programming for Text/Graphics Screen Modes
     2                          ; ================
     3                          ; Programms the CRTC controller chip for various screen timings and Text/Graphic modes.
     4                          ; This code requires two CRTC Register tables - One for Text and one for Graphics modes.
     5                          
     6                          
     7                          ;************** Set Screen to TEXT or GRAPHICS MODE
     8                          ;
     9                          ; TEXT/GRAPHICS mode determines which font is displayed.
    10                          ; - GRAPHICS mode has uppercase and full graphics. Characters take 8 scanlines
    11                          ; - TEXT mode has lower case, upper case and limited graphics. Characters take 10 scanlines (normally)
    12                          ; 
    13                          ; OPTIONS: 'EXTENDED' and 'SS40'
    14                          
    15                          ;-------------- Initialize CRTC to TEXT Mode (Called from Jump Table)
    16                          
    17                          CRT_SET_TEXT
    18                          
    19                          !if CODEBASE<2 {
    20                          	!IF SS40=0 {
    21                          		LDA #<CRT_CONFIG_TEXT			; Point to CRTC Table
    22                          		LDX #>CRT_CONFIG_TEXT			; Point to CRTC Table
    23                          		LDY #$0E				; Character Set = TEXT
    24                          		BNE CRT_PROGRAM
    25                          	} ELSE {
    26  e076 4c25ed             		JMP CRT_SET_TEXT_SS40			; Jump to SS40 version (upper rom)
    27                          	}
    28                          }
    29                          
    30                          !IF CODEBASE=2 {
    31                          	JMP CRT_SET_TEXT_EXT				; Jump to EXTENDED version (upper rom)
    32                          
    33                          	!if CRUNCH=0 {	
    34                          		NOP
    35                          		NOP
    36                          		NOP
    37                          		NOP
    38                          		NOP
    39                          	}
    40                          }
    41                          
    42                          ;-------------- Initialize CRTC to GRAPHICS Mode (Called from Jump Table)
    43                          
    44                          CRT_SET_GRAPHICS
    45                          
    46                          !if CODEBASE<2 {
    47                          	!IF SS40=0 {
    48                          		LDA #<CRT_CONFIG_GRAPHICS       	; Point to CRTC Table
    49                          		LDX #>CRT_CONFIG_GRAPHICS       	; Point to CRTC Table
    50                          		LDY #$0C				; Character Set = GRAPHICS
    51                          	} ELSE {
    52  e079 4c29ed             		JMP CRT_SET_GRAPHICS_SS40		; Jump to SS40 version (upper rom)
    53                          	}
    54                          }
    55                          !IF CODEBASE=2 {
    56                          	JMP CRT_SET_GRAPHICS_EXT		; Jump to EXTENDED version (upper rom)
    57                          
    58                          	!if CRUNCH=0 {
    59                          		NOP
    60                          		NOP
    61                          		NOP
    62                          	}
    63                          }
    64                          
    65                          ;************** Program CRTC chip for selected screen MODE (Called from Jump Table)
    66                          ;
    67                          ; The CRTC controller controls the parameters for generating the display on the monitor. The CRTC chip has
    68                          ; several registers that must be set properly according to the type of connected display. These set characters on the line,
    69                          ; left and right margins, lines on the screen, height of each line and positioning of the top of the screen.
    70                          ; The parameters are read from a table and written to the CRTC controller chip. The VIA chip is used to select which of the
    71                          ; two fonts from the CHARACTER ROM is used.
    72                          ;
    73                          ; Parameters: Table pointer in A/X, CHRSET in Y
    74                          ; OPTIONS: 'SS40' uses new routine in upper rom
    75                          
    76                          CRT_PROGRAM
    77                          
    78                          !IF SS40=0 {
    79                          ;		--------------------- Set 'Character Set'
    80                          
    81                          		STA SAL					; Pointer LO: Tape Buffer/ Screen Scrolling
    82                          		STX SAL+1				; Pointer HI
    83                          		LDA VIA_PCR				; Get current register byte VIA Register C - CA2	CHIP 
    84                          		AND #$f0				; mask out lower nibble
    85                          		STA FNLEN				; save it to Temp Variable
    86                          		TYA					; Move 'Character Set' byte to A
    87                          		ORA FNLEN				; update lower nibble in Temp Variable
    88                          		STA VIA_PCR				; write it back to VIA Register C - CA2			CHIP
    89                          
    90                          ;		--------------------- Write to the CRTC controller
    91                          
    92                          		LDY #$11				; Number of bytes to copy = 17
    93                          
    94                          CRT_LOOP	LDA (SAL),Y				; Pointer: Tape Buffer/ Screen Scrolling
    95                          		STY CRT_Address				; Select the register to update 6545/6845 CRT		CHIP
    96                          		STA CRT_Status				; Write to the register
    97                          		DEY
    98                          		BPL CRT_LOOP				; loop for more
    99                          		RTS
   100                          } ELSE {
   101  e07c 4c3fed             		JMP CRT_PROGRAM_SS40			; Jump to Switchable Soft-40 version (upper rom)
   102                          }

; ******** Source: editrom80.asm
   170                          
   171                          
   172                          ;*********************************************************************************************************
   173                          ;** GETKEY  [E0A7]  (Called from Jump Table)
   174                          ;** Get a KEY from keyboard buffer. Reads a character from 'KEYD' then shifts remaining buffer characters
   175                          ;** If there is NO key it will return $FF.
   176                          ;*********************************************************************************************************
   177                          
   178  e07f aaaaaaaaaaaaaaaa...	!IF NOFILL=0 { !FILL $e0a7-*,$aa }		; FIXED ENTRY POINT! This must not move!
   179                          
   180                          ;#########################################################################################################
   181                          
   182                          GETKEY
   183                          !IF DEBUG=1 { INC DBLINE+2,X }			; DEBUG
   184  e0a7 ac6f02             		LDY KEYD				; Get key at start of buffer
   185  e0aa a200               		LDX #0 					; Start at 0
   186                          
   187  e0ac bd7002             GK_LOOP		LDA KEYD+1,X				; LOOP[ START - Now shift the next keys in line
   188  e0af 9d6f02             		STA KEYD,X				;   to the front of the buffer
   189                          !IF DEBUG=1 { STA DBLINE+10,X }				;   DEBUG - update screen
   190  e0b2 e8                 		INX
   191  e0b3 e49e               		CPX CharsInBuffer			;   Num Chars in Keyboard Buffer
   192  e0b5 d0f5               		BNE GK_LOOP				; ] Done? No, loop for another
   193                          
   194  e0b7 c69e               		DEC CharsInBuffer			; Reduce Num Chars in Keyboard Buffer
   195                          
   196  e0b9 98                 		TYA					; Put the character in Accumulator
   197                          !IF DEBUG=1 { STA DBLINE+3 }				; DEBUG - 4th chr on bottom line
   198  e0ba 58                 		CLI
   199  e0bb 60                 		RTS
   200                          
   201                          ;*********************************************************************************************************
   202                          ;** GETLINE  [E0BC]
   203                          ;** The PET is usually in this routine, waiting for keypresses and printing them or acting on them.
   204                          ;** This routine continually loops until a <RETURN> is pressed. When <RETURN> is pressed then the line
   205                          ;** where the cursor is, is processed. If the <RUN> key is pressed then the string is stuffed into
   206                          ;** the keyboard buffer (overwriting whatever might be there)
   207                          ;*********************************************************************************************************
   208                          
   209  e0bc 209ae6             GETLINE		JSR ChrOutMarginBeep			; 
   210                          GETLINE2	!IF DEBUG=1 { INC DBLINE+5 }		; DEBUG - 6th chr on bottom line
   211  e0bf a59e               		LDA CharsInBuffer			; Are there any keys waiting?
   212  e0c1 85a7               		STA Blink 				; 0 chars -> blink cursor
   213  e0c3 f0fa               		BEQ GETLINE2 				; loop until char in buffer
   214                          
   215                          !IF DEBUG=1 { INC DBLINE+6 }				; DEBUG - 7th chr on bottom line
   216                          
   217                          ;[E0C5]		--------------- Got a character, so process it
   218                          
   219  e0c5 78                 		SEI
   220  e0c6 a5aa               		LDA BlinkPhase				; Check if cursor in blink phase
   221  e0c8 f009               		BEQ GL_1				; no, so no need to restore original character
   222  e0ca a5a9               		LDA CursorChar				; yes, get character under Cursor
   223  e0cc a000               		LDY #0					; 
   224  e0ce 84aa               		STY BlinkPhase				; Reset blinkphase
   225  e0d0 2006e6             		JSR RESTORE_CHR_AT_CRSR		; Restore OLD character under cursor before processing new one
   226  e0d3 20a7e0             GL_1		JSR GETKEY				; Get Character From Keyboard Buffer
   227  e0d6 c983               		CMP #$83				; Is it the <RUN> key?
   228  e0d8 d010               		BNE GL_3				; No, skip ahead
   229                          
   230                          ;[E0DA]		---------------- Stuff the <RUN> string to the keyboard buffer
   231                          
   232  e0da 78                 		SEI
   233  e0db a209               		LDX #9					; Length of string
   234  e0dd 869e               		STX CharsInBuffer			; Set number of characters in buffer
   235  e0df bd33e7             GL_2		LDA RUN_STRING-1,X			; Normally:  dL"*<RETURN>run<RETURN>
   236  e0e2 9d6e02             		STA KEYD-1,X				; stuff it into the buffer
   237  e0e5 ca                 		DEX
   238  e0e6 d0f7               		BNE GL_2				; loop back for more
   239  e0e8 f0d5               		BEQ GETLINE2
   240                          
   241                          ;[E0EA]		--------------- Check for RETURN key
   242                          
   243  e0ea c90d               GL_3		CMP #$0D 				; Check if <RETURN> pressed
   244  e0ec d0ce               		BNE GETLINE				; if not go get more keys
   245                          
   246                          ;*********************************************************************************************************
   247                          ;** PARSE_LINE  [E0EE]
   248                          ;** When the <RETURN> key is pressed the line where the cursor lives is executed
   249                          ;*********************************************************************************************************
   250                          
   251                          PARSE_LINE
   252                          		!IF DEBUG=1 { INC DBLINE+7 }		; DEBUG - 8th chr on bottom line
   253                          
   254  e0ee a4d5               		LDY RightMargin				; Physical Screen Line Length
   255  e0f0 84ac               		STY CRSW 				; # 0 -> Screen Input
   256                          
   257  e0f2 b1c4               PL_LOOP		LDA (ScrPtr),Y				; LOOP[  Read Character from Screen RAM
   258  e0f4 c920               		CMP #$20 				;   Is it <SPACE> Ignore trailing blanks
   259  e0f6 d003               		BNE PL_SKIP				; 	No, exit out
   260  e0f8 88                 		DEY					; 	Yes, move to previous position
   261  e0f9 d0f7               		BNE PL_LOOP				; ] At start of line? No, loop back for more
   262                          
   263                          ;[E0FB]		------------------------ Process line
   264                          
   265  e0fb c8                 PL_SKIP 	INY					; last was not <SPACE> so move ahead one
   266  e0fc 84a1               		STY LastInputCol			; record the position
   267  e0fe 20cbe1             		JSR CURSOR_TO_LM			; Move to the start of the line [80] 
   268  e101 ea                 !IF CRUNCH=0 {	NOP }					; (this is a patch)		[80] 
   269  e102 84cd               		STY QuoteMode 				; Turn off quote mode
   270  e104 a5a3               		LDA InputRow				; Cursor Y-X Pos. at Start of INPUT
   271  e106 3019               		BMI Screen_Input
   272  e108 c5d8               		CMP CursorRow				; Current Cursor Physical Line Number
   273  e10a d015               		BNE Screen_Input
   274  e10c a5a4               		LDA InputCol
   275  e10e 85c6               		STA CursorCol				; Cursor Column on Current Line
   276  e110 c5a1               		CMP LastInputCol			; Pointer: End of Logical Line for INPUT
   277  e112 900d               		BCC Screen_Input
   278  e114 b02e               		BCS Screen_Input2
   279                          
   280                          ;*********************************************************************************************************
   281                          ;** INPUT_CHARACTER  [E116]  (Called from Jump Table) - FIXED ENTRY POINT!!!!!
   282                          ;** Push X and Y to stack then call Input a Character routine via pointer
   283                          ;*********************************************************************************************************
   284                          
   285                          		!IF NOFILL=0 { !FILL $e116-*,$aa }	; FIXED ENTRY POINT! This must not move!
   286                          
   287                          ;#########################################################################################################
   288                          
   289  e116 98                 INPUT_CHARACTER	TYA
   290  e117 48                 		PHA
   291  e118 8a                 		TXA
   292  e119 48                 		PHA
   293  e11a 6ce900             		JMP (SCRIV)	; Jump to Input from Screen routine (Vector normally points to DEFAULT_SCREEN_VECTOR)
   294                          
   295                          ;*********************************************************************************************************
   296                          ;** DEFAULT_SCREEN_VECTOR  [E11D]
   297                          ;** Input from Screen Routine
   298                          ;*********************************************************************************************************
   299                          
   300                          DEFAULT_SCREEN_VECTOR
   301  e11d a5ac               		LDA CRSW				; Flag: INPUT or GET from Keyboard
   302  e11f f09e               		BEQ GETLINE2
   303                          
   304                          ;		--------------------------------------- Screen Input
   305                          
   306  e121 a4c6               Screen_Input	LDY CursorCol				; Cursor Column on Current Line
   307  e123 b1c4               		LDA (ScrPtr),Y				; Pointer: Current Screen Line Address
   308  e125 85d9               		STA DATAX				; Current Character to Print
   309  e127 293f               		AND #$3f 				; '?'
   310  e129 06d9               		ASL DATAX				; Current Character to Print
   311  e12b 24d9               		BIT DATAX				; Current Character to Print
   312  e12d 1002               		BPL SI_SKIP1
   313  e12f 0980               		ORA #$80
   314  e131 9004               SI_SKIP1	BCC SI_SKIP2
   315  e133 a6cd               		LDX QuoteMode				; Flag: Editor in Quote Mode, $00 = NO
   316  e135 d004               		BNE SI_SKIP3
   317  e137 7002               SI_SKIP2	BVS SI_SKIP3
   318  e139 0940               		ORA #$40 				; '@'
   319  e13b e6c6               SI_SKIP3	INC CursorCol				; Cursor Column on Current Line
   320  e13d 206ae1             		JSR CheckQuote				; ?? Was: INCREASE_COL ??
   321  e140 c4a1               		CPY LastInputCol			; Pointer: End of Logical Line for INPUT
   322  e142 d017               		BNE SI_SKIP6
   323                          
   324                          ;		--------------------------------------- Screen Input 2
   325                          
   326  e144 a900               Screen_Input2	LDA #0
   327  e146 85ac               		STA CRSW				; Flag: INPUT or GET from Keyboard
   328  e148 a90d               		LDA #13
   329  e14a a6af               		LDX DFLTN				; Default Input Device (0)
   330  e14c e003               		CPX #3
   331  e14e f006               		BEQ SI_SKIP4
   332  e150 a6b0               		LDX DFLTO				; Default Output (CMD) Device (3)
   333  e152 e003               		CPX #3
   334  e154 f003               		BEQ SI_SKIP5
   335  e156 2002e2             SI_SKIP4	JSR CHROUT_SCREEN			; Output to Screen
   336  e159 a90d               SI_SKIP5	LDA #13
   337  e15b 85d9               SI_SKIP6	STA DATAX				; Current Character to Print
   338  e15d 68                 		PLA
   339  e15e aa                 		TAX
   340  e15f 68                 		PLA
   341  e160 a8                 		TAY
   342  e161 a5d9               		LDA DATAX				; Current Character to Print
   343  e163 c9de               		CMP #$de				; PI symbol
   344  e165 d002               		BNE SI_DONE
   345  e167 a9ff               		LDA #$ff				; replace with $FF (PI in alt set)
   346  e169 60                 SI_DONE 	RTS
   347                          
   348                          ;[E16A]		--------------------------------------- Check Quote Mode
   349                          
   350  e16a c922               CheckQuote	CMP #$22 				; Is it <QUOTE>?
   351  e16c d008               		BNE CQ_DONE				; No, we're done
   352  e16e a5cd               		LDA QuoteMode				; Flag: Editor in Quote Mode, $00 = NO
   353  e170 4901               		EOR #1					; toggle the BIT
   354  e172 85cd               		STA QuoteMode				; Flag: Editor in Quote Mode, $00 = NO
   355  e174 a922               		LDA #$22 				; reload the <QUOTE>
   356  e176 60                 CQ_DONE		RTS
   357                          
   358                          ;*********************************************************************************************************
   359                          ;** CHAR_TO_SCREEN  [E177]
   360                          ;** This puts a character in 'A' to screen. The character is handled differently according to the entry
   361                          ;** point. For example, when QUOTE mode is ON special characters are printed in RVS using CHAR_TO_SCREEN3
   362                          ;*********************************************************************************************************
   363                          
   364  e177 0940               CHAR_TO_SCREEN	ORA #$40 				; '@'
   365  e179 a69f               CHAR_TO_SCREEN2 LDX ReverseFlag				; Flag: Print Reverse Chars. -1=Yes
   366  e17b f002               		BEQ CTS_SKIP1
   367                          
   368  e17d 0980               CHAR_TO_SCREEN3	ORA #$80				; Toggle the upper bit (reverse characters)
   369                          
   370  e17f a6dc               CTS_SKIP1	LDX INSRT				; Flag: Insert Mode, >0 = # INSTs
   371  e181 f002               		BEQ CTS_SKIP2
   372  e183 c6dc               		DEC INSRT				; Flag: Insert Mode, >0 = # INSTs
   373                          CTS_SKIP2
   374                          
   375                          !IF COLOURPET=0 {
   376  e185 2006e6             		JSR RESTORE_CHR_AT_CRSR			; Put character on screen
   377                          } ELSE {
   378                          		JSR Put_ColourChar_at_Cursor		; Put character AND Colour on screen
   379                          }
   380                          ;		--------------------------------------- Handle screen wrap
   381                          
   382  e188 e6c6               		INC CursorCol				; Cursor Column on Current Line
   383  e18a a4d5               		LDY RightMargin				; Physical Screen Line Length
   384  e18c c4c6               		CPY CursorCol				; Is it at RIGHT margin?
   385  e18e b009               		BCS IRQ_EPILOG				; No, we're done
   386  e190 a6d8               		LDX CursorRow				; Yes, prepare to wrap to next line
   387  e192 20a1e3             CHAR_TO_SCREEN4	JSR CURSOR_DOWN				; Go to next line
   388  e195 a4e2               		LDY LeftMargin				; Get column for Left Margin of window
   389  e197 84c6               		STY CursorCol				; Set Cursor Column on Current Line
   390                          
   391                          ;*********************************************************************************************************
   392                          ;** IRQ_EPILOG  [E199]
   393                          ;** IRQ Completion. We jump here when printing is complete.
   394                          ;*********************************************************************************************************
   395                          
   396  e199 a900               IRQ_EPILOG	LDA #0
   397  e19b 85e8               		STA HOMECT				; Home Count
   398  e19d 68                 IRQ_EPILOG2 	PLA
   399  e19e a8                 		TAY
   400  e19f a5dc               		LDA INSRT				; Flag: Insert Mode, >0 = # INSTs
   401  e1a1 f002               		BEQ IRQE_SKIP
   402  e1a3 46cd               		LSR QuoteMode				; Flag: Editor in Quote Mode, $00 = NO
   403  e1a5 68                 IRQE_SKIP	PLA
   404  e1a6 aa                 		TAX
   405  e1a7 68                 		PLA
   406  e1a8 58                 		CLI					; Allow interrupts again
   407  e1a9 60                 		RTS
   408                          
   409                          ;*********************************************************************************************************
   410                          ;** CURSOR_TO_EOPL  [E1AA]
   411                          ;** Move Cursor to End of Previous Line
   412                          ;*********************************************************************************************************
   413                          
   414  e1aa a4d5               CURSOR_TO_EOPL	LDY RightMargin				; Physical Screen Line Length
   415  e1ac a6e0               		LDX TopMargin
   416  e1ae e4d8               		CPX CursorRow				; Current Cursor Physical Line Number
   417  e1b0 9008               		BCC CEPL_SKIP
   418  e1b2 a4e2               		LDY LeftMargin				; First column of window
   419  e1b4 84c6               		STY CursorCol				; Cursor Column on Current Line
   420  e1b6 68                 		PLA
   421  e1b7 68                 		PLA
   422  e1b8 d0df               		BNE IRQ_EPILOG
   423  e1ba c6d8               CEPL_SKIP	DEC CursorRow				; Current Cursor Physical Line Number
   424  e1bc 84c6               		STY CursorCol				; Cursor Column on Current Line
   425  e1be 4c67e0             		JMP UPDATE_CURSOR_ROW			; Set Screen Pointers
   426                          
   427                          ;*********************************************************************************************************
   428                          ;** ERASE_TO_ELO  [E1C1] 
   429                          ;** Erases from cursor to end of line
   430                          ;** Called from WIN_CLEAR. This routine is relocated/updated for COLOURPET
   431                          ;*********************************************************************************************************
   432                          
   433                          !IF COLOURPET=0 {
   434                          ERASE_TO_EOL
   435  e1c1 a920               		LDA #$20 				; <SPACE>
   436  e1c3 c8                 EEOL_LOOP	INY
   437  e1c4 91c4               		STA (ScrPtr),Y				; Pointer: Current Screen Line Address
   438  e1c6 c4d5               		CPY RightMargin
   439  e1c8 90f9               		BCC EEOL_LOOP
   440  e1ca 60                 		RTS
   441                          }
   442                          
   443                          ;*********************************************************************************************************
   444                          ;** CURSOR_TO_LM / ESCAPE_J  [E1CB]
   445                          ;** Move Cursor to Left Margin
   446                          ;*********************************************************************************************************
   447                          
   448                          ESCAPE_J
   449                          CURSOR_TO_LM
   450  e1cb a4e2               		LDY LeftMargin				; First column of window
   451  e1cd 84c6               		STY CursorCol				; Cursor Column on Current Line
   452  e1cf a000               		LDY #0
   453  e1d1 60                 		RTS
   454                          
   455                          ;*********************************************************************************************************
   456                          ;** FULL_SCREEN  [E1D2]
   457                          ;** Set Full Screen (Exit Window). This routine set the screen to full size.
   458                          ;** OPTIONS: 'COLUMNS' determines 40 or 80 column screen
   459                          ;**          'SS40'    when COLUMNS=80 uses col size determined by Soft40 'SCNWIDTH' memory location
   460                          ;** Note: Changing SCNWIDTH does not change CRTC parameters. Use the ESC-X command!!!
   461                          ;*********************************************************************************************************
   462                          
   463  e1d2 a900               FULL_SCREEN	LDA #0					; Top/Left=0
   464  e1d4 aa                 		TAX
   465  e1d5 20e1e1             		JSR WIN_SET_TOP				; Set Window Top
   466                          
   467  e1d8 a918               		LDA #ROWS-1				; Number of Hard-coded Screen Rows - Nomally 25 (0-24). 32+ for 8296 only
   468                          
   469  e1da a6f0               !IF SS40=1 {	LDX SCNWIDTH				; Current SS40 screen width
   470                             } ELSE {	LDX #COLUMNS-1 				; Hard-coded Screen Width (Normally 0-79)
   471                          }
   472                          
   473                          ;*********************************************************************************************************
   474                          ;** WIN_SET_BOT  [E1DC]
   475                          ;** Set Bottom Right Corner of Window
   476                          ;*********************************************************************************************************
   477                          
   478  e1dc 85e1               WIN_SET_BOT	STA BotMargin				; Last line of window
   479  e1de 86d5               		STX RightMargin				; Physical Screen Line Length
   480  e1e0 60                 		RTS
   481                          
   482                          ;*********************************************************************************************************
   483                          ;** WIN_SET_TOP  [E1E1]
   484                          ;** Set Top Left Corner of Window
   485                          ;*********************************************************************************************************
   486                          
   487  e1e1 85e0               WIN_SET_TOP	STA TopMargin				; First line of window
   488  e1e3 86e2               		STX LeftMargin				; First column of window
   489  e1e5 60                 		RTS
   490                          
   491                          ;*********************************************************************************************************
   492                          ;** CHROUT_SCREEN  [E202]  (Called from Jump Table)
   493                          ;** $E202 - FIXED ENTRY POINT! Some BASIC/KERNAL bypass the Jump Table and jump directly here
   494                          ;** Output Character to Screen Dispatch 
   495                          ;*********************************************************************************************************
   496                          
   497  e1e6 aaaaaaaaaaaaaaaa...		!IF NOFILL=0 { !FILL $e202-*,$aa }	; FIXED ENTRY POINT! This must not move!
   498                          
   499                          ;#########################################################################################################
   500                          
   501  e202 48                 CHROUT_SCREEN	PHA
   502  e203 85d9               		STA DATAX				; Current Character to Print
   503  e205 8a                 		TXA
   504  e206 48                 		PHA
   505  e207 98                 		TYA
   506  e208 48                 		PHA
   507  e209 6ceb00             		JMP (SCROV) 				; Via Screen Output Vector (normally 'CHROUT_NORMAL')
   508                          
   509                          ;*********************************************************************************************************
   510                          ;** CHROUT_NORMAL  [E20C]
   511                          ;** Output Character to Screen. Character to print must be in DATAX.
   512                          ;** SCROV vector normally points here
   513                          ;*********************************************************************************************************
   514                          
   515  e20c a900               CHROUT_NORMAL	LDA #0
   516  e20e 85ac               		STA CRSW				; Flag: INPUT or GET from Keyboard
   517                          
   518  e210 a4c6               		LDY CursorCol				; Cursor Column on Current Line
   519  e212 a5d9               		LDA DATAX				; Current Character to Print
   520  e214 297f               		AND #$7F				; Strip off top bit (REVERSE)
   521                          
   522                          ;[PATCH]	--------------------------------------- Check for ESC Character
   523                          
   524                          !IF ESCCODES=1 {
   525  e216 4c2ceb             		JMP CheckESC				; Check for ESC as last Char, then ESC as current Char. If so, perform it.
   526  e219 85f1               ESC_DONE	STA LASTCHAR				; Save the character
   527                          
   528                          } ELSE {
   529                          		CMP #$1B				; <ESC>	key? **** Also SHIFT-ESC $9B (Conflicts with COLOUR CODE!)
   530                          		BNE CHROUT_CHECK
   531                          		JMP ESCAPE				; Cancel RVS/INS/QUOTE modes
   532                          }
   533                          ESC_DONE2
   534                          
   535                          ;[E21D]		--------------------------------------- Reload character and check high bit
   536                          
   537  e21b a5d9               CHROUT_CHECK	LDA DATAX				; Current Character to Print
   538                          !IF COLOURPET=1 { JSR CheckColourCodes }		; Check table of color values @@@@@@@@@@@@@@@@ COLOURPET
   539  e21d 1003               		BPL CHROUT_LO				; Is top bit CLEAR? Yes, handle UNSHIFTED Character
   540  e21f 4cf2e2             		JMP CHROUT_HI				; No, Handle SHIFTED Character
   541                          
   542                          ;*********************************************************************************************************
   543                          ;** Character Output with High Bit CLEAR  [E224]
   544                          ;** This section checks characters in the range 0 to 127.
   545                          ;** UN-SHIFTED character have the HI BIT is CLEAR
   546                          ;*********************************************************************************************************
   547                          
   548                          ;		--------------------------------------- Check for RETURN
   549                          
   550  e222 c90d               CHROUT_LO	CMP #$0D 				; Is it <RETURN>?
   551  e224 d003               		BNE Be22b				; No, skip to next check
   552  e226 4cb4e3             		JMP CURSOR_RETURN			; Yes, Handle <RETURN>
   553                          
   554                          ;		--------------------------------------- Check for Control Codes Range (0-31)
   555                          
   556  e229 c920               Be22b		CMP #$20 				; <SPACE>
   557  e22b 9008               		BCC Be237 				; -> Control code
   558  e22d 293f               		AND #$3f 				; '?'
   559  e22f 206ae1             		JSR CheckQuote				; Check For Quotes
   560  e232 4c79e1             		JMP CHAR_TO_SCREEN2			; -> Print to screen
   561                          
   562  e235 a6dc               Be237		LDX INSRT				; Flag: Insert Mode, >0 = # INSTs
   563  e237 f003               		BEQ Be23e				; Is FLAG=0? Yes, skip ahead
   564  e239 4c7de1             		JMP CHAR_TO_SCREEN3			; -> Print reverse to screen
   565                          
   566                          ;		--------------------------------------- Check for DELETE
   567                          
   568  e23c c914               Be23e		CMP #$14 				; Is it <DEL>?
   569  e23e d020               		BNE Be262				; No, skip ahead
   570                          
   571                          ;		--------------------------------------- DELETE - Check if it would wrap to previous line
   572                          
   573  e240 a4e2               		LDY LeftMargin				; Get left margin
   574  e242 c4c6               		CPY CursorCol				; Is it cursor at left margin?
   575  e244 9005               		BCC Be24d				; No, skip ahead
   576  e246 20aae1             		JSR CURSOR_TO_EOPL			; Yes, move to previous line
   577  e249 d00f               		BNE Be25c				; Skip ahead if we are at the top line (Was: BPL Be25c)
   578                          
   579                          ;		--------------------------------------- Perform DELETE
   580                          
   581  e24b c6c6               Be24d		DEC CursorCol				; Move cursor one position to the LEFT
   582  e24d a4c6               		LDY CursorCol				; Get the new cursor position
   583                          
   584                          !IF COLOURPET=0 {
   585  e24f c8                 Be251		INY					; LOOP[
   586  e250 b1c4               		LDA (ScrPtr),Y				;   Read Character from Screen RAM
   587  e252 88                 		DEY					;   move to the left
   588  e253 91c4               		STA (ScrPtr),Y				;   Write Character to Screen RAM
   589  e255 c8                 		INY					;   Next column
   590  e256 c4d5               		CPY RightMargin				;   Is it at the Right margin?
   591  e258 d0f5               		BNE Be251				; ] No, so go back for more
   592                          } ELSE {
   593                          		JSR ColourPET_Scroll_Left		; Scroll both Screen and Colour LEFT	@@@@@@@@@@@@@@ ColourPET
   594                          }
   595                          
   596                          ;[E25C]		--------------------------------------- Entry point for "80240.PRG"
   597                          
   598  e25a a920               Be25c		LDA #$20 				; <SPACE>
   599  e25c 91c4               		STA (ScrPtr),Y				; put it on the screen!
   600                          !IF COLOURPET=1 {
   601                          		LDA COLOURV				; Get the current Colour	@@@@@@@@@@@@@@@ ColourPET
   602                          		STA (COLOURPTR),Y			; put it to Colour MEM		@@@@@@@@@@@@@@@ ColourPET
   603                          }
   604  e25e d037               		BNE Be299
   605                          
   606  e260 a6cd               Be262		LDX QuoteMode				; Flag: Editor in Quote Mode, $00 = NO
   607  e262 f003               		BEQ Be269				; Quote mode OFF, so we need to action the character
   608  e264 4c7de1             		JMP CHAR_TO_SCREEN3			; Quote mode ON, so we need to print the QUOTEMODE version
   609                          
   610                          ;		--------------------------------------- Check for RVS
   611                          
   612  e267 c912               Be269		CMP #$12 				; Is it <RVS>?
   613  e269 d002               		BNE Be26f				; No, skip ahead
   614  e26b 859f               		STA ReverseFlag				; Yes, Set RVS flag
   615                          
   616                          ;		--------------------------------------- Check for HOME and HOME-HOME
   617                          
   618  e26d c913               Be26f		CMP #$13 				; Is it <HOME>?
   619  e26f d010               		BNE Be283				; No, skip ahead
   620  e271 a5e8               		LDA HOMECT 				; Is Home Count=0 (<HOME><HOME> sets window to full screen)
   621  e273 1004               		BPL Be27b				; Yes, skip ahead
   622  e275 20d2e1             		JSR FULL_SCREEN				; Set to full screen (remove any window)
   623  e278 18                 		CLC
   624  e279 66e8               Be27b		ROR HOMECT				; Reset Home Count
   625  e27b 205fe0             		JSR CURSOR_HOME				; Home the cursor
   626  e27e 4c9de1             		JMP IRQ_EPILOG2
   627                          
   628                          ;		--------------------------------------- Check for CURSOR RIGHT
   629                          
   630  e281 c91d               Be283		CMP #$1d 				; Is it <CURSOR RIGHT>?
   631  e283 d00b               		BNE Be292				; No, skip ahead
   632  e285 c8                 		INY					; Yes, increment column
   633  e286 84c6               		STY CursorCol				; Update Column
   634  e288 88                 		DEY					; Go back
   635  e289 c4d5               		CPY RightMargin				; Is it at Right Margin?
   636  e28b 900a               		BCC Be299				; No, skip ahead
   637  e28d 4c92e1             		JMP CHAR_TO_SCREEN4			; Yes
   638                          
   639                          ;		--------------------------------------- Check for CURSOR DOWN
   640                          
   641  e290 c911               Be292		CMP #$11 				; Is it <CURSOR DOWN>?
   642  e292 d006               		BNE Be29c				; No, skip ahead
   643  e294 20a1e3             		JSR CURSOR_DOWN				; Go to next line
   644  e297 4c99e1             Be299		JMP IRQ_EPILOG
   645                          
   646                          ;		--------------------------------------- Check for TAB
   647                          
   648  e29a c909               Be29c		CMP #9 					; Is it <TAB>?
   649  e29c d030               		BNE Be2d0				; No, skip to next check (see [BUG?]
   650                          
   651  e29e 2075e5             		JSR JUMP_TO_TAB				; Perform <TAB>
   652  e2a1 ac3a03             Be2a3		LDY NextTab				; LOOP[
   653  e2a4 ee3a03             		INC NextTab
   654  e2a7 c4d5               		CPY RightMargin				;   Physical Screen Line Length
   655  e2a9 9009               		BCC Be2b6				;   
   656  e2ab a5d5               		LDA RightMargin				;   Physical Screen Line Length
   657  e2ad 85c6               		STA CursorCol				;   Cursor Column on Current Line
   658  e2af ce3a03             		DEC NextTab				;   temp var
   659  e2b2 d0e3               		BNE Be299				;   Exit
   660  e2b4 0e3e03             Be2b6		ASL DOS_Syntax				;   temp var
   661  e2b7 d00a               		BNE Be2c5
   662  e2b9 e8                 		INX
   663  e2ba e00a               		CPX #10					;   Have we reached end of tab table?
   664  e2bc f0d9               		BEQ Be299				;   Yes, so no tab found. Exit.
   665  e2be a901               		LDA #1
   666  e2c0 8d3e03             		STA DOS_Syntax				;   temp var
   667  e2c3 bdee03             Be2c5		LDA TABS_SET,X				;   Get TAB from table
   668  e2c6 2d3e03             		AND DOS_Syntax				;   temp var
   669  e2c9 f0d6               		BEQ Be2a3				; ]LOOP
   670  e2cb c8                 		INY
   671  e2cc 84c6               		STY CursorCol				; Set cursor column to new position
   672                          
   673                          ;[BUG?]		Why does this routine drop into the CTRL-V check? It should do JMP IRQ_EPILOG here
   674                          
   675                          ;[E2D0]		--------------------------------------- Check for Erase to End of line
   676                          
   677  e2ce c916               Be2d0		CMP #$16 				; Is it <Ctrl V>? - Erase to EOL? NOTE: 40-col code has BUG here
   678  e2d0 d00c               		BNE Be2e0				; No, skip ahead
   679                          
   680                          ;[E2D4]		--------------------------------------- Erase to End of Line
   681                          
   682  e2d2 a920               		LDA #$20				; <SPACE>
   683  e2d4 88                 		DEY
   684                          
   685  e2d5 c8                 Be2d7		INY
   686  e2d6 91c4               		STA (ScrPtr),Y				; Write it to the screen
   687                          !IF COLOURPET=1 {
   688                          		PHA
   689                          		LDA COLOURV				; Current Colour		@@@@@@@@@@@@@@ COLOURPET
   690                          		STA (COLOURPTR),Y			; Write it to Colour RAM	@@@@@@@@@@@@@@ COLOURPET
   691                          		PLA
   692                          }
   693  e2d8 c4d5               		CPY RightMargin				; are we at right margin?
   694  e2da 90f9               		BCC Be2d7
   695                          
   696  e2dc b0b9               		BCS Be299
   697                          
   698                          ;[E2E0]		--------------------------------------- Check for Delete Line
   699                          ;
   700                          
   701  e2de c915               Be2e0		CMP #$15				; Is it <Ctrl U>? - DELETE LINE
   702  e2e0 f003               		BEQ DELETE_LINE				; Yes, go do it
   703  e2e2 4c96e5             		JMP Scroll_Or_Select_Charset		; No, skip ahead
   704                          
   705                          ;[E2E7]		--------------------------------------- Delete Line
   706                          
   707                          ESCAPE_D						; Esc-d Delete Line
   708                          DELETE_LINE
   709  e2e5 a5e0               		LDA TopMargin				; Top Line of Window
   710  e2e7 48                 		PHA
   711  e2e8 a5d8               		LDA CursorRow				; Current Cursor Physical Line Number
   712  e2ea 85e0               		STA TopMargin				; Top Line of Window
   713  e2ec 20e1e3             		JSR WIN_SCROLL_UP			; Scroll window up
   714  e2ef 4ccfe5             		JMP Me5ca
   715                          
   716                          ;*********************************************************************************************************
   717                          ;** CHROUT_HI  [E2F4]
   718                          ;** Character Output when High Bit SET (characters in the range 128 to 255).
   719                          ;** Handles: RETURN,INS,CRSR-UP,
   720                          ;*********************************************************************************************************
   721                          
   722  e2f2 297f               CHROUT_HI	AND #$7f				; strip off top bit
   723  e2f4 c97f               		CMP #$7f				; special case: code for PI (7F)
   724  e2f6 d002               		BNE COH_SKIP1
   725  e2f8 a95e               		LDA #$5e 				; replace with screen code 5E
   726                          
   727  e2fa c920               COH_SKIP1	CMP #$20 				; Is it a Control Character?
   728  e2fc 9003                          	BCC COH_SKIP2				; Yes, skip ahead to check
   729  e2fe 4c77e1                        	JMP CHAR_TO_SCREEN			; No, so just jump to print it as-is
   730                          
   731                          ;		--------------------------------------- Check for SHIFT-RETURN
   732                          
   733  e301 c90d               COH_SKIP2     	CMP #$0D 				; Is it <SHIFT><RETURN>?
   734  e303 d003                          	BNE COH_SKIP3				; No, skip ahead
   735  e305 4cb4e3             		JMP CURSOR_RETURN			; Yes, handle it
   736                          
   737                          ;		--------------------------------------- Check Quote Mode
   738                          
   739  e308 a6cd               COH_SKIP3	LDX QuoteMode				; Is QUOTE MODE on?
   740  e30a d034               		BNE COH_SKIP6				; No, skip ahead
   741                          
   742                          ;		--------------------------------------- Check for INSERT
   743                          
   744  e30c c914               		CMP #$14 				; Is it <INS>? (Shift-DEL)
   745  e30e d02c                          	BNE COH_SKIP5				; No, skip ahead
   746                          
   747                          ;		--------------------------------------- Check if INSERT is possible
   748                          
   749  e310 a4d5               CHECK_INSERT	LDY RightMargin				; Right margin
   750  e312 b1c4                          	LDA (ScrPtr),Y				; Read the character at the end of the line
   751  e314 c920                          	CMP #$20 				; Is it <SPACE>?
   752  e316 d072               		BNE Be38c				; No, so no room to insert. Skip ahead
   753                          
   754  e318 c4c6               COH_SKIP4	CPY CursorCol				; There is a space, but are we at end of line?
   755  e31a 906e               		BCC Be38c				; Yes, so cancel insert
   756  e31c f06c               		BEQ Be38c				; Yes, so cancel insert
   757                          
   758                          ;		---------------------------------------- Do INSERT
   759                          
   760  e31e a4d5               DO_INSERT	LDY RightMargin
   761                          
   762                          !IF COLOURPET=0 {
   763  e320 88                 INS_LOOP1	DEY
   764  e321 b1c4               		LDA (ScrPtr),Y				; Read it from the Screen
   765  e323 c8                 		INY
   766  e324 91c4               		STA (ScrPtr),Y				; Write it to the Screen
   767  e326 88                 		DEY
   768  e327 c4c6               		CPY CursorCol
   769  e329 d0f5               		BNE INS_LOOP1
   770                          } ELSE {
   771                          		JSR ColourPET_Insert
   772                          }
   773  e32b a920               		LDA #$20 				; <SPACE>
   774  e32d 91c4               		STA (ScrPtr),Y				; Write it to the Screen
   775                          
   776  e32f a5d5               		LDA RightMargin				; Physical Screen Line Length
   777  e331 38                 		SEC
   778  e332 e5c6               		SBC CursorCol				; Cursor Column on Current Line
   779  e334 e5dc               		SBC INSRT				; Flag: Insert Mode, >0 = # INSTs
   780  e336 3052               		BMI Be38c
   781  e338 e6dc               		INC INSRT				; Flag: Insert Mode, >0 = # INSTs
   782  e33a d04e               		BNE Be38c
   783                          
   784                          ;		--------------------------------------- Check for INSERT in QUOTE MODE
   785                          
   786  e33c a6dc               COH_SKIP5	LDX INSRT				; Flag: Insert Mode, >0 = # INSTs
   787  e33e f005               		BEQ COH_CHECK1
   788                          
   789  e340 0940               COH_SKIP6	ORA #$40 				; '@'
   790  e342 4c7de1             		JMP CHAR_TO_SCREEN3
   791                          
   792                          ;		--------------------------------------- Check for CURSOR UP
   793                          
   794  e345 c911               COH_CHECK1	CMP #$11 				; Is it <CRSR-UP>? (SHIFT-CRSR-DOWN)
   795  e347 d00d               		BNE Be358				; No, skip ahead
   796                          
   797                          ;		--------------------------------------- Do Cursor UP
   798  e349 a6e0               		LDX TopMargin
   799  e34b e4d8               		CPX CursorRow
   800  e34d b03b               		BCS Be38c	
   801  e34f c6d8               		DEC CursorRow
   802  e351 2067e0             		JSR UPDATE_CURSOR_ROW
   803  e354 d034               		BNE Be38c
   804                          
   805                          ;		--------------------------------------- Check for RVS OFF
   806                          
   807  e356 c912               Be358		CMP #$12 				; Is it <OFF>?  (SHIFT-RVS)
   808  e358 d004               		BNE Be360				; No, skip ahead
   809  e35a a900               		LDA #0					; Set RVS OFF
   810  e35c 859f               		STA ReverseFlag				; Store it
   811                          
   812                          ;		--------------------------------------- Check for CURSOR LEFT
   813                          
   814  e35e c91d               Be360		CMP #$1d 				; Is it <LEFT>? (Shift-Cursor RIGHT)
   815  e360 d00f               		BNE Be373				; No, skip ahead
   816  e362 a4e2               		LDY LeftMargin			
   817  e364 c4c6               		CPY CursorCol				; Are we at the left margin already?
   818  e366 9005               		BCC Be36f 				; No, skip ahead         	@@@@@@@@@@@@@@@ was: BNE $E38C
   819  e368 20aae1             		JSR CURSOR_TO_EOPL			; Yes, go to end previous line
   820  e36b d01d               		BNE Be38c				;				@@@@@@@@@@@@@@@ was: BPL Be38c
   821  e36d c6c6               Be36f		DEC CursorCol				; Move one position LEFT
   822  e36f 1019               		BPL Be38c				;				@@@@@@@@@@@@@@@ was: BNE Be38c
   823                          
   824                          ;		--------------------------------------- Check for CLEAR SCREEN
   825                          
   826  e371 c913               Be373		CMP #$13 				; Is it <CLR>? (SHIFT-HOME)
   827  e373 d005               		BNE Be37c				; No, skip ahead
   828  e375 2051e0             		JSR WIN_CLEAR				; Yes, clear the screen/window
   829  e378 d010               		BNE Be38c				; Finish Up
   830                          
   831                          ;		--------------------------------------- Check for SET TAB
   832                          
   833  e37a c909               Be37c		CMP #9 					; Is it <SET-TAB>? (SHIFT-TAB)
   834  e37c d00f               		BNE Be38f				; No, skip ahead
   835                          
   836                          ;		--------------------------------------- Set a TAB STOP HERE
   837                          
   838  e37e 2075e5             		JSR JUMP_TO_TAB
   839  e381 bdee03             		LDA TABS_SET,X
   840  e384 4d3e03             		EOR DOS_Syntax
   841  e387 9dee03             		STA TABS_SET,X
   842  e38a 4c99e1             Be38c		JMP IRQ_EPILOG
   843                          
   844                          ;		--------------------------------------- Check for ERASE TO START OF LINE
   845                          
   846  e38d c916               Be38f		CMP #$16 				; Is it <SHIFT>CTRL-V?  (Conflicts with COLOURPET!
   847                          !IF COLOURPET=0 {
   848  e38f f003               		BEQ ERASE_TO_SOL			; Remove Conflict			
   849                          }
   850  e391 4cc1e5             		JMP ProcControl_A
   851                          
   852                          ;*********************************************************************************************************
   853                          ;** ERASE_TO_SOL / ESCAPE_P [E396]
   854                          ;** Erases from cursor to Start of Line
   855                          ;*********************************************************************************************************
   856                          
   857                          ESCAPE_P
   858  e394 a920               ERASE_TO_SOL	LDA #$20 				; <SPACE>
   859  e396 a4e2               		LDY LeftMargin				; Start at Left Margin
   860  e398 c4c6               ESOL_LOOP	CPY CursorCol				; LOOP[ Have we reached the cursor position?
   861  e39a b0ee               		BCS Be38c				;   Yes, skip ahead
   862  e39c 91c4               		STA (ScrPtr),Y				;   No, Write it to the screen
   863                          !IF COLOURPET=1 {
   864                          		LDA COLOURV				;   Current Colour
   865                          		STA (COLOURPTR),Y			;   Write Current Colour to colour RAM
   866                          }
   867  e39e c8                 		INY					;   Move to next column
   868  e39f d0f7               		BNE ESOL_LOOP				; ] Loop back for more
   869                          
   870                          ;*********************************************************************************************************
   871                          ;** CURSOR_DOWN [E3A3]
   872                          ;** Do Cursor DOWN, Go to next line. If at bottom of window SCROLL UP.
   873                          ;*********************************************************************************************************
   874                          
   875  e3a1 46a3               CURSOR_DOWN	LSR InputRow
   876  e3a3 a6d8               		LDX CursorRow
   877  e3a5 e4e1               		CPX BotMargin
   878  e3a7 9006               		BCC Be3b1
   879  e3a9 20e1e3             		JSR WIN_SCROLL_UP
   880  e3ac 4c67e0             		JMP UPDATE_CURSOR_ROW
   881  e3af e6d8               Be3b1		INC CursorRow
   882  e3b1 4c67e0             		JMP UPDATE_CURSOR_ROW
   883                          
   884                          ;*********************************************************************************************************
   885                          ;** CURSOR_RETURN [E3B6]
   886                          ;** Cursor to start of line, then CURSOR DOWN. Also performs ESCAPE
   887                          ;*********************************************************************************************************
   888                          
   889  e3b4 a4e2               CURSOR_RETURN	LDY LeftMargin
   890  e3b6 84c6               		STY CursorCol
   891  e3b8 20a1e3             		JSR CURSOR_DOWN
   892                          
   893                          ;*********************************************************************************************************
   894                          ;** ESCAPE / ESCAPE_O [E3BD]
   895                          ;** Cancels Insert, Reverse and Quote modes
   896                          ;*********************************************************************************************************
   897                          
   898                          ESCAPE_O
   899  e3bb a900               ESCAPE		LDA #0
   900  e3bd 85dc               		STA INSRT
   901  e3bf 859f               		STA ReverseFlag
   902  e3c1 85cd               		STA QuoteMode
   903                          
   904  e3c3 85f1               !IF ESCCODES = 1 { STA LASTCHAR }
   905                          
   906  e3c5 4c99e1             		JMP IRQ_EPILOG
   907                          
   908                          ;*********************************************************************************************************
   909                          ;** WIN_SCROLL_DN / ESCAPE_W  [E3C8] (Called from Jump Table)
   910                          ;** Scrolls the current Window DOWN 
   911                          ;*********************************************************************************************************
   912                          
   913                          ESCAPE_W
   914  e3c8 a6e1               WIN_SCROLL_DN	LDX BotMargin
   915  e3ca e8                 		INX
   916  e3cb ca                 Be3cb		DEX
   917  e3cc 206ce0             		JSR UPDATE_CURSOR_R2			;@@@@@@@@@@ was: JSR CURSOR_LM	; Was: Cursor_BOL
   918  e3cf e4e0               		CPX TopMargin
   919  e3d1 f027               		BEQ Be3fe
   920                          
   921                          !IF COLOURPET=0 {
   922                          	!IF SS40=0 {
   923                          		LDA Line_Addr_Lo-1,X    		; Screen Line address table LO - 1
   924                          		STA SAL					; Pointer: Tape Buffer/ Screen Scrolling
   925                          		LDA Line_Addr_Hi-1,X 			; Screen Line address table HI - 1
   926                          		STA SAL+1
   927                          	} ELSE {
   928  e3d3 20cced             		JSR SS40_SyncPointers2
   929                          	}
   930                          } ELSE {
   931                          		JSR ColourPET_SyncPointers2 		; Synchronize Pointers	@@@@@@@@@@@@@@@ COLOURPET
   932                          }
   933                          
   934  e3d6 c8                 Be3d8		INY
   935                          !IF COLOURPET=0 {
   936                          
   937  e3d7 b1c7               		LDA (SAL),Y				; Read Character from Screen SOURCE
   938  e3d9 91c4               		STA (ScrPtr),Y				; Write it to Screen DESTINATION
   939                          } ELSE {
   940                          		JSR ColourPET_Scroll_Dest
   941                          }
   942  e3db c4d5               		CPY RightMargin
   943  e3dd 90f7               		BCC Be3d8
   944  e3df b0ea               		BCS Be3cb
   945                          
   946                          ;*********************************************************************************************************
   947                          ;** WIN_SCROLL_UP / ESCAPE_V  [E3E8] (Called from Jump Table)
   948                          ;** Scrolls current Window UP 
   949                          ;*********************************************************************************************************
   950                          
   951                          ESCAPE_V						; ESC-V Scroll Up
   952                          WIN_SCROLL_UP
   953  e3e1 a6e0               		LDX TopMargin
   954  e3e3 ca                 		DEX
   955  e3e4 e8                 Be3e6		INX
   956  e3e5 206ce0             		JSR UPDATE_CURSOR_R2			;@@@@@@@@@@@@@@ was: CURSOR_LM			; Was: Cursor_BOL
   957  e3e8 e4e1               		CPX BotMargin
   958  e3ea b00e               		BCS Be3fe
   959                          
   960                          !IF COLOURPET=0 {
   961                          	!IF SS40=0 {	
   962                          		LDA Line_Addr_Lo+1,X			; Screen line address table LO + 1
   963                          		STA SAL					; Pointer: Tape Buffer/ Screen Scrolling
   964                          		LDA Line_Addr_Hi+1,X			; Screen line address table HI + 1
   965                          		STA SAL+1				; Pointer: Tape Buffer/ Screen Scrolling
   966                          	} ELSE {
   967  e3ec 20b0ed             		JSR SS40_SyncPointers
   968                          	}
   969                          } ELSE {
   970                          		JSR ColourPET_SyncPointers		; Synchronize Pointers	@@@@@@@@@@@@@@@ COLOURPET
   971                          }
   972                          
   973  e3ef c8                 Be3f3		INY
   974                          !IF COLOURPET=0 {
   975  e3f0 b1c7               		LDA (SAL),Y				; Read Character from Screen SOURCE
   976  e3f2 91c4               		STA (ScrPtr),Y				; Write to Screen DESTINATION
   977                          } ELSE {
   978                          		JSR ColourPET_Scroll_Dest		; Scroll Character and Colour RAM	
   979                          }
   980  e3f4 c4d5               		CPY RightMargin
   981  e3f6 90f7               		BCC Be3f3
   982  e3f8 b0ea               		BCS Be3e6
   983                          
   984  e3fa 20c1e1             Be3fe		JSR ERASE_TO_EOL			; Clear the bottom line
   985                          
   986                          ;*********************************************************************************************************
   987                          ;** Check Keyboard Scroll Control E40B]
   988                          ;*********************************************************************************************************
   989                          

; ******** Source: scrollpause-b.asm
     1                          ; PET/CBM EDIT ROM - Scroll Pause/Resume Control - B
     2                          ; ================
     3                          
     4                          ;--------------- Check Keyboard Scroll Control
     5                          
     6  e3fd ad12e8             iE40B		LDA PIA1_Port_B		; PIA#1, Register 2 - Keyboard COL input
     7  e400 c9fe               iE40E		CMP #$FE        	; Is BIT 0 set? ie: key held down?
     8  e402 d00e               iE410		BNE iE420       	; no, skip scroll delay loop
     9                          
    10                          ;--------------- Scroll Delay and Pause
    11                          
    12  e404 a000               iE412		LDY #$00       		; Scroll delay
    13  e406 ea                 iE414		NOP
    14  e407 ca                 		DEX
    15  e408 d0fc               		BNE iE414       	; Loop back
    16  e40a 88                 		DEY
    17  e40b d0f9               		BNE iE414       	; Loop back
    18                          
    19  e40d a000               iE41B		LDY #$00        	; Clear keyboard buffer
    20  e40f 849e               		STY CharsInBuffer	; No. of Chars. in Keyboard Buffer (Queue)
    21  e411 60                 iE41F		RTS
    22                          
    23  e412 c9df               iE420		CMP #$DF        	; Is BIT 1 set? key held down?
    24  e414 d0fb               		BNE iE41F       	; no, return
    25  e416 ad12e8             iE424		LDA PIA1_Port_B		; PIA#1, Register 2 - Keyboard ROW input
    26  e419 c9df               		CMP #$DF        	; Is BIT 1 set? key held down?
    27  e41b f0f9               		BEQ iE424       	; yes, loop back
    28  e41d c9ff               		CMP #$FF        	; no keys?
    29  e41f f0f5               		BEQ iE424       	; yes, loop back
    30  e421 d0ea               		BNE iE41B       	; return back up to clear buffer

; ******** Source: editrom80.asm
   990                          
   991                          
   992                          ;*********************************************************************************************************
   993                          ;** Jiffy Clock Timer Correction Patch [E431]
   994                          ;*********************************************************************************************************
   995                          

; ******** Source: jiffyfix.asm
     1                          ; PET/CBM EDIT ROM - Jiffy Clock Timer Fix
     2                          ; ================
     3                          
     4                          ;************** Correct Jiffy Clock Timer
     5                          ; Patch for 50 Hz
     6                          ; TODO: Analyze JIFFY CLOCK differences from older ROMs
     7                          ; TODO: make selectable
     8                          
     9                          !if CODEBASE<2 {
    10                          ADVANCE_TIMER
    11  e423 20eaff             		JSR UDTIME			; Update System Jiffy Clock. KERNAL routine $FFEA
    12  e426 e6f8               		INC JIFFY6DIV5			; Counter to speed TI by 6/5
    13  e428 a5f8               		LDA JIFFY6DIV5			; Counter to speed TI by 6/5
    14  e42a c906               		CMP #$06			; every 6 IRQ's
    15  e42c d02a               		BNE IRQ_NORMAL2			; no, jump back to IRQ routine
    16  e42e a900               		LDA #$00      			; yes, reset counter
    17  e430 85f8               		STA JIFFY6DIV5			; Counter to speed TI by 6/5
    18  e432 f0ef               		BEQ ADVANCE_TIMER		; re-do jiffy clock update
    19                          } ELSE {
    20                          
    21                          ADVANCE_TIMER_CORR
    22                          		LDA #6
    23                          		STA JIFFY6DIV5
    24                          ADVANCE_TIMER
    25                          		JSR ADVANCE_JIFFY_CLOCK		; In EDITROMEXT file
    26                          		DEC JIFFY6DIV5
    27                          		BEQ ADVANCE_TIMER_CORR
    28                          		RTS
    29                          }

; ******** Source: editrom80.asm
   996                          
   997                          
   998                          ;*********************************************************************************************************
   999                          ;** MAIN IRQ ENTRY [E442][E455] (Called from Jump Table) - FIXED ENTRY POINT!
  1000                          ;** This entry point must not move! It is called directly from KERNAL
  1001                          ;** The CRTC chip's V-Sync line is fed to a VIA to generate IRQ's. When an IRQ is triggered, the
  1002                          ;** Clock is updated, the keyboard scanned, ieee polled and tape monitored.
  1003                          ;*********************************************************************************************************
  1004                          
  1005  e434 aaaaaaaaaaaaaaaa...		!IF NOFILL=0 { !FILL $e442-*,$aa }	; FIXED ENTRY POINT! This routine must not move!
  1006                          
  1007                          ;#########################################################################################################
  1008                          

; ******** Source: irq.asm
     1                          ; PET/CBM EDIT ROM - IRQ Handler Routines
     2                          ; ================
     3                          ; The IRQ does the work of updating the clock/timer, checking interrupts and calling the keyboard scanner.
     4                          
     5                          
     6                          IRQ_MAIN
     7  e442 48                 		PHA
     8  e443 8a                 		TXA
     9  e444 48                 		PHA
    10  e445 98                 		TYA
    11  e446 48                 		PHA
    12  e447 ba                 		TSX
    13  e448 bd0401             		LDA STACK+4,X
    14  e44b 2910               		AND #16
    15  e44d f003               		BEQ Be452
    16  e44f 6c9200             		JMP (CBINV)	; Vector: BRK Instr. Interrupt [D478]
    17  e452 6c9000             Be452		JMP (CINV)	; Vector: Hardware Interrupt   [E455] Points to 'IRQ_NORMAL'
    18                          
    19                          ;*********************************************************************************************************
    20                          ;** IRQ_NORMAL [$E455]
    21                          ;*********************************************************************************************************
    22                          
    23                          ;************** IRQ (Called from Jump Table)
    24                          ; The IRQ is fired when the CRTC chip does a VSYNC, so the timing is
    25                          ; dependent on the CRTC configuration.
    26                          ; Normally: $E455
    27                          
    28                          IRQ_NORMAL
    29                          		!IF IRQFIX=1 {
    30                          			!IF CODEBASE=0 { JMP ADVANCE_TIMER }
    31                          			!IF CODEBASE=1 { JMP ADVANCE_TIMER }
    32                          			!IF CODEBASE=2 { JSR ADVANCE_TIMER }
    33                          		} ELSE {
    34  e455 20eaff             			JSR UDTIME			; Update System Jiffy Clock. KERNAL routine $FFEA 			
    35                          		}
    36                          
    37                          ;		--------------------------------------- Blink the cursor
    38                          
    39                          IRQ_NORMAL2						; ie458
    40  e458 a5a7               		LDA Blink				; Cursor Blink enable: 0 = Flash Cursor
    41  e45a d018               		BNE Be474				; skip it
    42  e45c c6a8               		DEC BLNCT				; Timer: Countdown to Toggle Cursor
    43  e45e d014               		BNE Be474				; skip it
    44                          
    45  e460 a914               		LDA #$14				; default cursor blink rate (20)
    46                          !if REPEATOPT = 1 {
    47                          		BIT RPTFLG				; check repeat flag
    48                          		BPL ie468				; skip if not enabled
    49                          		LDA #2					; make cursor blink immediately
    50                          }
    51  e462 85a8               ie468		STA BLNCT				; store to blink countdown counter
    52  e464 a4c6               		LDY CursorCol				; Column where cursor lives
    53  e466 46aa               		LSR BlinkPhase				; Is it blinking?
    54  e468 b1c4               		LDA (ScrPtr),Y				; Get character from the screen
    55  e46a b004               		BCS Be470				; Yes, skip
    56  e46c e6aa               		INC BlinkPhase				; count
    57  e46e 85a9               		STA CursorChar				; Remember the character at cursor (to be restored when cursor moves)
    58  e470 4980               Be470		EOR #$80				; Flip the reverse bit
    59  e472 91c4               		STA (ScrPtr),Y				; Put it back on the screen
    60                          
    61                          ;		--------------------------------------- Prep for keyboard scanning [$E47B]
    62                          
    63  e474 a000               Be474		LDY #0
    64  e476 ad10e8             		LDA PIA1_Port_A 			; Keyboard ROW select - PIA#1, Register 0
    65                          							; Upper bits: IEEE and Cassette
    66                          							; Lower bits: Keyboard ROW select
    67                          !if CODEBASE<2 {
    68  e479 29f0               		AND #$F0				; Mask off lower 4 bits (reset keyboard scan row)
    69  e47b 8d10e8             		STA PIA1_Port_A				; Keyboard ROW select - PIA#1, Register 0				CHIP
    70  e47e ad10e8             		LDA PIA1_Port_A				; Keyboard ROW select - PIA#1, Register 0				CHIP
    71                          } 
    72                          
    73                          ;		--------------------------------------- Check IEEE and Cassette status
    74                          
    75  e481 0a                 		ASL					; Shift upper bits to lower 
    76  e482 0a                 		ASL 
    77  e483 0a                 		ASL 
    78  e484 1009               		BPL Be487				; Is CASSETTE#1 Sense? No, skip
    79                          
    80  e486 84f9               		STY CAS1				; Yes, Tape Motor Interlock #1
    81  e488 ad13e8             		LDA PIA1_Cont_B				; PIA#1 Register 13 (Retrace flag and interrupt
    82  e48b 0908               		ORA #8					; Is CASSETTE#2 Sense?
    83  e48d d009               		BNE Be490				; No, skip
    84                          
    85  e48f a5f9               Be487		LDA CAS1				; Yes, Tape Motor Interlock #1
    86  e491 d008               		BNE Be493				; No, skip
    87                          
    88  e493 ad13e8             		LDA PIA1_Cont_B				; PIA#1 Register 13 (Retrace flag and interrupt)
    89  e496 29f7               		AND #$f7				; Mask off bit 4
    90  e498 8d13e8             Be490		STA PIA1_Cont_B				; PIA#1 Register 13 (Retrace flag and interrupt)
    91  e49b 9009               Be493		BCC Be49e
    92                          
    93  e49d 84fa               		STY CAS2				; Tape Motor Interlock #2
    94  e49f ad40e8             		LDA VIA_Port_B				; VIA Register 0 (flags)
    95  e4a2 0910               		ORA #16
    96  e4a4 d009               		BNE Be4a7
    97  e4a6 a5fa               Be49e		LDA CAS2				; Tape Motor Interlock #2
    98  e4a8 d008               		BNE Be4aa
    99  e4aa ad40e8             		LDA VIA_Port_B				; VIA Register 0 (flags)
   100  e4ad 29ef               		AND #$ef
   101  e4af 8d40e8             Be4a7		STA VIA_Port_B				; VIA Register 0 (flags)
   102  e4b2 20b8e4             Be4aa		JSR SCAN_KEYBOARD			; Scan the keyboard
   103                          
   104                          !IF KEYRESET=1 {  JSR CheckReboot }			; Check for soft reset ******* should this go above Be474 ?????????????????
   105                          
   106  e4b5 4c00e6             		JMP IRQ_END				; Return from Interrupt
   107                          

; ******** Source: editrom80.asm
  1009                          
  1010                          ;!IF DEBUG=0 { !FILL $e4be-*,$aa }			;#################################################
  1011                          
  1012                          ;*********************************************************************************************************
  1013                          ;** KEYBOARD SCANNER  [E4BE]
  1014                          ;** The Keyboard is scanned during the IRQ and one keystroke is stored to KEYD. Other routines transfer
  1015                          ;** this keystroke to or from a small 10-byte buffer. The keyboard scanner does the actual interfacing to
  1016                          ;** the hardware to read the rows and columns of the keyboard matrix. When a key is pressed it gets the
  1017                          ;** keycode from the keyboard matrix table. If no key is pressed, then $FF is returned.
  1018                          ;*********************************************************************************************************
  1019                          
  1020                          !IF KEYSCAN=0 { !SOURCE "keyscan-g.asm" }		; Graphic Keyboard

; ******** Source: keyscan-b.asm
     1                          ; PET/CBM EDIT ROM - Keyboard Scan - Business Keyboards
     2                          ; ================
     3                          ; Standard Business Keyboard scanner. Requires one keyboard table.
     4                          ;
     5                          ; OPTIONS: KEYBOARD=7 modifies scanner for CBM-II keyboard (16x6 matrix)
     6                          
     7                          ;--------------- Scan Keyboard (scnkey)
     8                          ; NOTE: The keyboard ROW select is reset to zero in IRQ routine
     9                          
    10                          SCAN_KEYBOARD
    11                          ;!if DEBUG = 1 { INC DBLINE+5 }		; DEBUG - 6th character on top line
    12                          
    13  e4b8 a0ff               		LDY #$FF		; No Key
    14  e4ba 84a6               		STY Key_Image		; Key Image
    15  e4bc c8                 		INY
    16  e4bd 8498               		STY KEYFLAGS		; Store 0 in KEYFLAGS
    17  e4bf a5e4               		LDA RPTFLG		; Get Repeat Flag     : REPEAT Key Used, $80 = Repeat, $40 = disable
    18  e4c1 297f               		AND #$7F		; Clear all bits except HI bit
    19  e4c3 85e4               		STA RPTFLG		; Write it back       : REPEAT Key Used, $80 = Repeat, $40 = disable
    20                          
    21                          		!IF KEYBOARD=7 {
    22                          			LDX #$60	; 96 bytes in table. X is used as offset into the table (CBM-II keyboard)
    23                          		} ELSE {
    24  e4c5 a250               			LDX #$50	; 80 bytes in table. X is used as offset into the table (normal keyboards)
    25                          		}
    26                          
    27                          SCAN_ROW
    28                          		!IF KEYBOARD=7 {
    29                          			 LDY #$06	; Number of Columns to check = 6 (CBM-II keyboard only)
    30                          		} ELSE {
    31  e4c7 a008               			 LDY #$08	; Number of Columns to check = 8 (normal keyboards)
    32                          		}
    33                          
    34  e4c9 ad12e8             		LDA PIA1_Port_B 	; Keyboard COL result
    35  e4cc cd12e8             		CMP PIA1_Port_B 	; Keyboard COL result
    36  e4cf d0f6               		BNE SCAN_ROW		; Debounce
    37                          
    38  e4d1 4a                 SCAN_COL	LSR			; Shift the value right
    39  e4d2 b01f               		BCS SCAN_NEXT2		; If the bit was "1" then key is NOT down. Skip
    40                          
    41                          ;-------------- We have a key press. Look it up in the keyboard matrix
    42                          
    43  e4d4 48                 		PHA			; Save for later
    44  e4d5 bde3e6             		LDA KEYBOARD_NORMAL-1,X	; Read Keyboard Matrix (X is offset)
    45  e4d8 d006               		BNE SCAN_NOSH		; Is it SHIFT key? No, skip
    46                          
    47                          ;-------------- SHIFT key Detected
    48                          
    49  e4da a901               		LDA #$01		; Set the SHIFT flag
    50  e4dc 8598               		STA KEYFLAGS		; Flag: Print Shifted Chars.
    51  e4de d012               		BNE SCAN_NEXT		; No, skip
    52                          
    53                          ;-------------- Check REPEAT key
    54                          
    55  e4e0 c910               SCAN_NOSH	CMP #$10		; Is it REPEAT?
    56  e4e2 d008               		BNE SCAN_NORPT		; No, skip
    57                          
    58                          ;-------------- Turn on REPEAT Mode
    59                          
    60  e4e4 a5e4               		LDA RPTFLG		; Flag: REPEAT Key Used, $80 = Repeat, $40 = disable
    61  e4e6 0980               		ORA #$80
    62  e4e8 85e4               		STA RPTFLG		; Flag: REPEAT Key Used, $80 = Repeat, $40 = disable
    63  e4ea 3006               		BMI SCAN_NEXT
    64                          
    65                          ;-------------- Repeat is OFF
    66                          
    67  e4ec c9ff               SCAN_NORPT	CMP #$FF		; Is it "no key"?
    68  e4ee f002               		BEQ SCAN_NEXT		; Yes, skip
    69                          
    70                          ;-------------- Normal key
    71                          
    72  e4f0 85a6               		STA Key_Image		; Store the key
    73                          
    74  e4f2 68                 SCAN_NEXT	PLA			; Restore value from keyboard scan for next loop
    75  e4f3 ca                 SCAN_NEXT2	DEX			; Decrement keyboard table offset
    76  e4f4 f008               		BEQ SCAN_GOT		; If 0 we have completed the entire matrix...Process Key Image
    77                          
    78  e4f6 88                 		DEY			; Next COLUMN
    79  e4f7 d0d8               		BNE SCAN_COL		; Go back up for next column bit
    80                          
    81                          ;-------------- Completed all bits in ROW, Increment ROW
    82                          
    83  e4f9 ee10e8             		INC PIA1_Port_A		; Next Keyboard ROW
    84  e4fc d0c9               		BNE SCAN_ROW		; More? Yes, loop back
    85                          
    86                          ;-------------- Process Key Image
    87                          
    88  e4fe a5a6               SCAN_GOT	LDA Key_Image		; Key Image
    89  e500 c597               		CMP KEYPRESSED		; Current Key Pressed: 255 = No Key
    90  e502 f006               		BEQ SCAN_PRESS		; If key is the same then it's being held down
    91                          
    92  e504 a210               		LDX #$10
    93  e506 86e6               		STX DELAY		; Repeat Delay Counter
    94  e508 d02f               		BNE SCAN_REC
    95                          
    96  e50a 24e4               SCAN_PRESS	BIT RPTFLG		; Check Repeat Flag: $80 = Repeat, $40 = disable
    97  e50c 301e               		BMI SCAN_DELAY2		; Repeat not set, so skip
    98  e50e 7064               		BVS SCAN_OUT		; Exit
    99                          
   100  e510 c9ff               		CMP #$FF		; Was it a key?
   101  e512 f060               		BEQ SCAN_OUT		; No, Exit
   102                          
   103  e514 c914               		CMP #$14		; Yes, check for auto-repeat keys. Is it <DEL>?
   104  e516 f00c               		BEQ SCAN_DELAY
   105  e518 c920               		CMP #$20		; Is it <SPACE>?
   106  e51a f008               		BEQ SCAN_DELAY
   107  e51c c91d               		CMP #$1D		; Is it <RIGHT>?
   108  e51e f004               		BEQ SCAN_DELAY
   109  e520 c911               		CMP #$11		; Is it <DOWN>?
   110  e522 d050               		BNE SCAN_OUT		; No auto-repeat keys so exit
   111                          
   112                          ;-------------- Found a repeating key. Set Delay counters
   113                          
   114  e524 a6e6               SCAN_DELAY	LDX DELAY		; Repeat Delay Counter
   115  e526 f004               		BEQ SCAN_DELAY2
   116  e528 c6e6               		DEC DELAY		; Repeat Delay Counter
   117  e52a d048               		BNE SCAN_OUT		; Exit
   118                          
   119  e52c c6e5               SCAN_DELAY2	DEC KOUNT		; Repeat Speed Counter
   120  e52e d044               		BNE SCAN_OUT		; Exit
   121  e530 a204               		LDX #$04
   122  e532 86e5               		STX KOUNT		; Repeat Speed Counter
   123  e534 a69e               		LDX CharsInBuffer	; No. of Chars. in Keyboard Buffer (Queue)
   124  e536 ca                 		DEX			; One less
   125  e537 103b               		BPL SCAN_OUT		; Exit
   126                          
   127                          ;-------------- Record the Keypress
   128                          
   129  e539 8597               SCAN_REC	STA KEYPRESSED		; Current Key Pressed: 255 = No Key
   130  e53b c9ff               		CMP #$FF		; No Key?
   131  e53d f035                		BEQ SCAN_OUT		; Yes, exit
   132                          
   133  e53f aa                 		TAX
   134  e540 08                 		PHP
   135  e541 297f               		AND #$7F		; Mask off upper bit (non-shiftable flag in key matrix byte)
   136  e543 28                 		PLP
   137  e544 3017               		BMI SCAN_NORM
   138                          
   139                          ;-------------- Process SHIFT key flag with Numeric Keys or Graphic keys
   140                          
   141  e546 4698               		LSR KEYFLAGS		; Check for SHIFT
   142  e548 9013               		BCC SCAN_NORM		; No, store as-is
   143  e54a c92c               		CMP #$2C		; Is it less than 2C? 
   144  e54c 900d               		BCC SCAN_SHIFT		; Yes, skip
   145  e54e c93c               		CMP #$3C		; Is it greater than 3C?
   146  e550 b009               		BCS SCAN_SHIFT		; Yes, skip
   147  e552 e90f               		SBC #$0F		; No, it must be Numeric so subtract 15
   148  e554 c920               		CMP #$20		; Is it above <SPACE>
   149  e556 b005               		BCS SCAN_NORM		; Yes
   150                          
   151  e558 6920               		ADC #$20		; Add 32 to convert to shifted symbol on number key
   152  e55a 2c                 		!byte $2C		; Hide the next instruction trick
   153                          
   154  e55b 0980               SCAN_SHIFT	ORA #$80		; Set upper bit for Graphics Symbol
   155                          
   156                          ;-------------- Put the KEY into the Buffer (Key in accumulator)
   157                          
   158                          SCAN_NORM
   159                          
   160  e55d 4cb9ec             !IF ESCCODES=1 { JMP EUROSWAP }		; Check if Eurokeys need swapping
   161                          
   162  e560 a69e               SCAN_NORM2	LDX CharsInBuffer	; No. of Chars. in Keyboard Buffer (Queue)
   163  e562 e4e3               		CPX XMAX		; Size of Keyboard Buffer
   164  e564 b00e               		BCS SCAN_OUT		; Exit if buffer full
   165  e566 9d6f02             		STA KEYD,X		; Put the key into the buffer
   166                          !IF BACKARROW=0 {
   167                          		INX			; Increment character count
   168                          		STX CharsInBuffer	; No. of Chars. in Keyboard Buffer (Queue)
   169                          } ELSE {
   170  e569 209ae7             		JSR TestBackArrow	; Patch/Hack to use SHIFT-BACKARROW as screen mode toggle (text/graphic)
   171                          }
   172                          
   173                          ;-------------- STOP KEY FIX
   174                          ; In the PET KERNAL there is code to check for the STOP key but is hard coded for N and B keyboards.
   175                          ; This fix puts the proper value ($EF) into STKEY ($9B) when the relocated STOP key is pressed.
   176                          ; NOTE: Must investigate further!
   177                          
   178                          !if KEYBOARD > 1 {
   179                          ;		Compensate for STOP key not in standard position
   180  e56c c903               		CMP #3			; Is keycode "3" (STOP key)?
   181  e56e d004               		BNE SCAN_OUT
   182  e570 a9ef               		LDA #$EF		; fool kernal into thinking STOP is pressed
   183  e572 859b               		STA STKEY		; store it
   184                          }

; ******** Source: editrom80.asm
  1021  e574 60                 }		; Business Keyboard
  1022                          !IF KEYSCAN=2 { !SOURCE "keyscan-din.asm" }		; German DIN Keyboard
  1023                          !IF KEYSCAN=3 { !SOURCE "keyscan-c64.asm" }		; C64 Keyboard
  1024                          !IF KEYSCAN=4 { !SOURCE "keyscan-cbm2.asm" }		; CBM2 Keyboard (future implementation)
  1025                          
  1026                          ;*********************************************************************************************************
  1027                          ;** JUMP_TO_TAB  [E570]
  1028                          ;** Tab positions are stored in a table of 80 bits (10 bytes). This routine
  1029                          ;*********************************************************************************************************
  1030                          
  1031  e575 a5c6               JUMP_TO_TAB	LDA CursorCol				; Get Cursor column on current line
  1032  e577 29f8               		AND #$f8				; mask off upper 5 bits
  1033  e579 8d3a03             		STA NextTab				; This will be the new column to jump to
  1034  e57c 4a                 		LSR					; shift right 3 bits (divide by 8)
  1035  e57d 4a                 		LSR
  1036  e57e 4a                 		LSR
  1037  e57f aa                 		TAX
  1038  e580 a901               		LDA #1					; Set bit 0 to 1
  1039  e582 8d3e03             		STA DOS_Syntax				; temp storage
  1040  e585 a4c6               		LDY CursorCol				; Get Cursor column on current line
  1041  e587 cc3a03             JTTAB1 		CPY NextTab				; LOOP[ Is 
  1042  e58a f009               		BEQ JTTABDONE				;   Yes, exit out
  1043  e58c 0e3e03             		ASL DOS_Syntax				;   No, Move the "1" bit forward
  1044  e58f ee3a03             		INC NextTab				;   Move ahead one column
  1045  e592 4c87e5             		JMP JTTAB1				; ] Loop back for more
  1046  e595 60                 JTTABDONE	RTS
  1047                          
  1048                          ;		--------------------------------------- Check for CTRL-Y
  1049                          
  1050                          Scroll_Or_Select_Charset
  1051                          
  1052  e596 c919               		CMP #$19 				; Is it CTRL-Y? (Scroll window up)
  1053  e598 d006               		BNE Be59b				; No, skip ahead
  1054  e59a 20e1e3             		JSR WIN_SCROLL_UP 			; Yes, Window Scroll Up
  1055  e59d 4cdee5             		JMP Me5d9
  1056                          
  1057                          ;		--------------------------------------- Check for CTRL-O
  1058                          
  1059  e5a0 c90f               Be59b		CMP #15 				; Is it CTRL-O (Set Window Top-Left)
  1060  e5a2 d00b               		BNE Be5aa				; No, skip ahead
  1061                          
  1062                          ;*********************************************************************************************************
  1063                          ;** ESCAPE_T
  1064                          ;** This sets the Window's Top-Left corner to the current cursor position
  1065                          ;*********************************************************************************************************
  1066                          
  1067  e5a4 a5d8               ESCAPE_T	LDA CursorRow				; Get current cursor ROW
  1068  e5a6 85e0               		STA TopMargin				; Store it as the TOP
  1069  e5a8 a5c6               		LDA CursorCol				; Get current cursor COL
  1070  e5aa 85e2               		STA LeftMargin				; Store it as the LEFT
  1071  e5ac 4c99e1             Be5a7		JMP IRQ_EPILOG
  1072                          
  1073                          ;		--------------------------------------- Check for CTRL-N
  1074                          
  1075  e5af c90e               Be5aa		CMP #14 				; Is it CTRL-N? (Text mode)
  1076  e5b1 d005               		BNE Be5b3				; No, skip ahead
  1077  e5b3 2076e0             		JSR CRT_SET_TEXT			; Yes, do it
  1078  e5b6 30f4               		BMI Be5a7
  1079                          
  1080                          ;		--------------------------------------- Check for CTRL-G
  1081                          
  1082  e5b8 c907               Be5b3		CMP #7 					; Is it CTRL-G? (Ring Bell)
  1083  e5ba d0f0               		BNE Be5a7				; No, skip ahead
  1084  e5bc 20b5e6             		JSR BEEP				; Yes, do BEEP
  1085  e5bf f0eb               		BEQ Be5a7
  1086                          
  1087                          ;*********************************************************************************************************
  1088                          ;** ProcControl_A  [E5BC]
  1089                          ;** Continue checking codes.
  1090                          ;*********************************************************************************************************
  1091                          
  1092                          ProcControl_A
  1093                          !IF COLOURPET=0 {
  1094  e5c1 c915               		CMP #$15 				; Is it CTRL-SHIFT-U? (Insert Line) - CONFLICT with colour code = DK YELLOW					
  1095  e5c3 d012               		BNE ProcControl_C			; @@@@@@ Was: BNE ProcControl_B
  1096                          } ELSE {
  1097                          		JMP ProcControl_C
  1098                          }
  1099                          
  1100                          ;*********************************************************************************************************
  1101                          ;** ESCAPE_I
  1102                          ;** Insert a blank line at current cursor position
  1103                          ;*********************************************************************************************************
  1104                          
  1105  e5c5 a5e0               ESCAPE_I	LDA TopMargin
  1106  e5c7 48                 		PHA
  1107  e5c8 a5d8               		LDA CursorRow
  1108  e5ca 85e0               		STA TopMargin
  1109  e5cc 20c8e3             		JSR WIN_SCROLL_DN			; Scroll Window Down
  1110  e5cf 68                 Me5ca		PLA
  1111  e5d0 85e0               		STA TopMargin
  1112  e5d2 2063e0             		JSR CURSOR_LM
  1113  e5d5 d018               		BNE EB_DONE
  1114                          
  1115                          ;[E5D2]		--------------------------------------- Check for CTRL-SHIFT-Y
  1116                          
  1117  e5d7 c919               ProcControl_C	CMP #$19 				; Is it CTRL-SHIFT-Y? (Scroll window up)
  1118  e5d9 d008               		BNE Be5de				; No, skip ahead
  1119                          
  1120                          !IF COLOURPET=0 {
  1121  e5db 20c8e3             		JSR WIN_SCROLL_DN			; CONFLICT with colour code = LT GREEN
  1122                          }
  1123  e5de 2067e0             Me5d9		JSR UPDATE_CURSOR_ROW
  1124  e5e1 d00c               		BNE EB_DONE
  1125                          
  1126                          ;[E5DE]		--------------------------------------- Check for CTRL-SHIFT-O
  1127                          
  1128  e5e3 c90f               Be5de		CMP #15 				; Is it CTRL-SHIFT-O? (Set Window Bottom)
  1129  e5e5 d00b               		BNE Be5ed				; No, skip ahead
  1130                          
  1131                          
  1132                          ;*********************************************************************************************************
  1133                          ;** ESCAPE_B
  1134                          ;** Set Windos Bottom-Left
  1135                          ;*********************************************************************************************************
  1136                          
  1137  e5e7 a5d8               ESCAPE_B	LDA CursorRow
  1138  e5e9 85e1               		STA BotMargin
  1139  e5eb a5c6               		LDA CursorCol
  1140  e5ed 85d5               		STA RightMargin
  1141  e5ef 4c99e1             EB_DONE		JMP IRQ_EPILOG
  1142                          
  1143                          ;[E5ED]		--------------------------------------- Check for CTRL-SHIFT-N
  1144                          
  1145  e5f2 c90e               Be5ed		CMP #14 				; Is it CTRL-SHIFT-N? (Graphics mode)
  1146  e5f4 d0c2               		BNE Be5b3				; No, skip ahead
  1147  e5f6 2079e0             		JSR CRT_SET_GRAPHICS			; Yes, do it
  1148  e5f9 30f4               		BMI EB_DONE
  1149                          
  1150                          ;*********************************************************************************************************
  1151                          ;** IRQ_END  [E600]  (Called from Jump Table) - FIXED ENTRY POINT!
  1152                          ;** The IRQ routine jumps here when completed. Do not modify this routine!
  1153                          ;*********************************************************************************************************
  1154                          
  1155  e5fb aaaaaaaaaa         		!IF NOFILL=0 { !FILL $e600-*,$aa }	;FIXED ENTRY POINT! This routine must not move! It is called directly from KERNAL
  1156                          
  1157                          ;#########################################################################################################
  1158                          
  1159  e600 68                 IRQ_END		PLA
  1160  e601 a8                 		TAY
  1161  e602 68                 		PLA
  1162  e603 aa                 		TAX
  1163  e604 68                 		PLA
  1164  e605 40                 		RTI
  1165                          
  1166                          ;*********************************************************************************************************
  1167                          ;** RESTORE_CHR_AT_CRSR  [E606]
  1168                          ;** This routine is called to put the character back at the cursor position.
  1169                          ;** It is called to put the initial character on the screen and as part of the cursor blinking routine.
  1170                          ;** NOTE: ColourPET: DOES NOT set/change COLOUR ATTRIBUTE!
  1171                          ;*********************************************************************************************************
  1172                          
  1173                          RESTORE_CHR_AT_CRSR
  1174  e606 a4c6               		LDY CursorCol				; Cursor Column on Current Line		
  1175  e608 91c4               		STA (ScrPtr),Y				; Put the character on the screen!!!!!!!!!!!!!!!!!!!!! 
  1176  e60a a902               		LDA #2					; Set blink count so cursor appears immediately
  1177  e60c 85a8               		STA BLNCT				; Timer: Countdown to Toggle Cursor
  1178  e60e 60                 		RTS
  1179                          
  1180                          ;*********************************************************************************************************
  1181                          ;** INIT_EDITOR  [E60F]
  1182                          ;** Initializes the Editor. Clears Clock. Sets IRQ Vector. Sets Keyboard buffer size. Clears TABs.
  1183                          ;** Sets zero-page locations. And finally, chimes the BELL.
  1184                          ;*********************************************************************************************************
  1185                          
  1186  e60f a97f               INIT_EDITOR	LDA #$7f
  1187  e611 8d4ee8             		STA VIA_IER				; VIA, Register E - I/O Timers
  1188  e614 a26d               		LDX #$6d
  1189  e616 a900               		LDA #0
  1190  e618 85e8               		STA HOMECT				; Clear Home Count (80-col)
  1191                          	
  1192                          !IF REPEATOPT = 1 { STA RPTFLG }			; Clear REPEAT ($80 = Repeat, $40 = disable)
  1193                          
  1194  e61a 958d               INITED1		STA JIFFY_CLOCK,X			; Clear Real-Time Jiffy Clock (approx) 1/60 Sec
  1195  e61c ca                 		DEX
  1196  e61d 10fb               		BPL INITED1
  1197  e61f 8698               		STX KEYFLAGS 				; $FF = Clear all flags
  1198                          
  1199                          ;		--------------------------------------- Set IRQ Vector - Normally $E455 or $E900 for Execudesk
  1200                          
  1201                          !IF EXECUDESK=1 {
  1202                          		LDA #<IRQ_EDESK				; Execudesk IRQ Vector LO
  1203                          		STA CINV
  1204                          		LDA #>IRQ_EDESK				; Execudesk IRQ Vector HI
  1205                          		STA CINV+1
  1206                          } ELSE {
  1207  e621 a955               		LDA #<IRQ_NORMAL			; Normal IRQ Vector LO
  1208  e623 8590               		STA CINV
  1209  e625 a9e4               		LDA #>IRQ_NORMAL			; Normal IRQ Vector HI
  1210  e627 8591               		STA CINV+1
  1211                          }
  1212                          
  1213                          ;		--------------------------------------- Init SS40
  1214                          
  1215                          !IF SS40=1 {
  1216                          	!IF HARD4080=1 {
  1217  e629 a901               		LDA #1					; 40/80 Switcher board INSTALLED
  1218  e62b 85f4               		STA SCN4080BOARD
  1219                          	} ELSE {
  1220                          		LDA #0					; 40/80 Switcher board NOT installed
  1221                          		STA SCN4080BOARD	
  1222                          	}
  1223                          
  1224                          	!IF SS40MODE=80 {
  1225  e62d 2002ed             		JSR SS40_INIT80				; Initialize Switchable Soft-40 to 80 columns
  1226                          	} ELSE {
  1227                          		JSR SS40_INIT40				; Initialize Switchable Soft-40 to 40 columns
  1228                          	}
  1229                          }
  1230                          ;		--------------------------------------- Continue
  1231                          
  1232  e630 a909               		LDA #$09
  1233  e632 85e3               		STA XMAX				; Size of Keyboard Buffer
  1234  e634 a903               		LDA #$03
  1235  e636 85b0               		STA DFLTO				; Default Output (CMD) Device (3)
  1236  e638 a90f               		LDA #15
  1237  e63a 8d10e8             		STA PIA1_Port_A 			; Keyboard ROW select
  1238  e63d 0a                 		ASL 
  1239  e63e 8d40e8             		STA VIA_Port_B
  1240  e641 8d42e8             		STA VIA_DDR_B
  1241  e644 8e22e8             		STX PIA2_Port_B
  1242  e647 8e45e8             		STX VIA_Timer_1_Hi
  1243  e64a a93d               		LDA #$3d
  1244  e64c 8d13e8             		STA PIA1_Cont_B
  1245  e64f 2c12e8             		BIT PIA1_Port_B 			; Keyboard COL read
  1246  e652 a93c               		LDA #$3c
  1247  e654 8d21e8             		STA PIA2_Cont_A
  1248  e657 8d23e8             		STA PIA2_Cont_B
  1249  e65a 8d11e8             		STA PIA1_Cont_A
  1250  e65d 8e22e8             		STX PIA2_Port_B
  1251  e660 a90e               		LDA #14
  1252  e662 85a8               		STA BLNCT				; Timer: Countdown to Toggle Cursor
  1253  e664 85a7               		STA Blink				; Cursor Blink enable: 0 = Flash Cursor
  1254  e666 85e6               		STA DELAY				; Repeat Delay Counter
  1255  e668 85e5               		STA KOUNT				; Repeat Speed Counter
  1256  e66a 8d4ee8             		STA VIA_IER
  1257  e66d 20d2e1             		JSR FULL_SCREEN				; Exit Window - Set screen size (ie: 80x25)
  1258                          
  1259                          ;[E669]		--------------------------------------- Clear Tab Stops (80 bits) 
  1260                          
  1261  e670 a20c               CLEAR_TABS	LDX #12					; 12 bytes (10 bytes plus?)
  1262  e672 a900               		LDA #0					; To Clear the table
  1263  e674 9dee03             CT_LOOP		STA TABS_SET,X				; LOOP[  Table of 80 bits to set TABs
  1264  e677 ca                 		DEX					;   next byte
  1265  e678 10fa               		BPL CT_LOOP				; ] Loop back for more
  1266                          
  1267                          ;		--------------------------------------- Set Screen Input and Output Vectors
  1268                          
  1269  e67a a91d               		LDA #<DEFAULT_SCREEN_VECTOR		; LO Address of Screen Input vector (from E006)
  1270  e67c a2e1               		LDX #>DEFAULT_SCREEN_VECTOR		; HI 
  1271  e67e 85e9               		STA SCRIV				; Input from screen vector (from E006)
  1272  e680 86ea               		STX SCRIV+1				; Input from screen vector (from E006)
  1273                          
  1274  e682 a90c               		LDA #<CHROUT_NORMAL
  1275  e684 a2e2               		LDX #>CHROUT_NORMAL
  1276  e686 85eb               		STA SCROV				; Print to screen vector (from E009)
  1277  e688 86ec               		STX SCROV+1				; Print to screen vector (from E009)
  1278                          
  1279  e68a a910               		LDA #$10
  1280  e68c 85e7               		STA CHIME
  1281                          
  1282                          ;		--------------------------------------- Patches for new features here
  1283                          
  1284                          !IF ESCCODES=1 {
  1285  e68e a901               		LDA #1					; 1=Enabled
  1286  e690 85f2               		STA BELLMODE				; Flag to Enable BELL
  1287                          }
  1288  e692 2012e9             !IF AUTORUN=1 {	JSR AUTOSTART }				; Do Auto Run Prep
  1289                          
  1290                          ;		--------------------------------------- Finish up by ringing BELL 4 times
  1291                          
  1292  e695 20b2e6             		JSR BEEP_BEEP				; Power-up chimes
  1293  e698 f018               		BEQ BEEP_BEEP				; More chimes (4 total)
  1294                          
  1295                          
  1296                          ;*********************************************************************************************************
  1297                          ;** ChrOutMarginBeep  [E68C]
  1298                          ;** Checks the cursor position and rings the BELL if near the end of the line
  1299                          ;*********************************************************************************************************
  1300                          
  1301                          ChrOutMarginBeep
  1302  e69a 2002e2             		JSR CHROUT_SCREEN			; Output to Screen
  1303  e69d aa                 		TAX
  1304  e69e a5d5               		LDA RightMargin				; Physical Screen Line Length
  1305  e6a0 38                 		SEC
  1306  e6a1 e5c6               		SBC CursorCol				; Cursor Column on Current Line
  1307  e6a3 c905               		CMP #5					; 5 characters from end of line
  1308  e6a5 d03c               		BNE BELLDONE
  1309  e6a7 8a                 		TXA
  1310  e6a8 c91d               		CMP #$1d 				; <Cursor Right> ?
  1311  e6aa f006               		BEQ BEEP_BEEP				; Ring BELL
  1312  e6ac 297f               		AND #$7f
  1313  e6ae c920               		CMP #$20 				; <SPACE>
  1314  e6b0 9031               		BCC BELLDONE
  1315                          
  1316                          ;*********************************************************************************************************
  1317                          ;** BEEP / BEEP_BEEP  [E6A7]
  1318                          ;** Rings the BELL
  1319                          ;*********************************************************************************************************
  1320                          
  1321  e6b2 20b5e6             BEEP_BEEP	JSR BEEP				; Double BEEP
  1322                          BEEP							; Single BEEP
  1323                          
  1324                          !IF SILENT=0 {
  1325  e6b5 a4e7               		LDY CHIME				; Chime Time FLAG
  1326                          } ELSE {
  1327                          		!IF CRUNCH=0 { NOP }			; To keep code aligned
  1328                          		RTS
  1329                          }
  1330                          
  1331                          !IF ESCCODES=1 {
  1332  e6b7 a5f2               		LDA BELLMODE
  1333  e6b9 1001               		BPL BELLENABLED
  1334  e6bb 60                 		RTS
  1335                          }
  1336  e6bc f025               BELLENABLED	BEQ BELLDONE
  1337  e6be a910               		LDA #16
  1338  e6c0 8d4be8             		STA VIA_ACR
  1339  e6c3 a90f               		LDA #15
  1340  e6c5 8d4ae8             		STA VIA_Shift
  1341  e6c8 a207               		LDX #7
  1342  e6ca bd60e7             BELLOOP1	LDA SOUND_TAB-1,X
  1343  e6cd 8d48e8             		STA VIA_Timer_2_Lo
  1344  e6d0 a5e7               		LDA CHIME				; Chime Time
  1345                          
  1346  e6d2 88                 BELLOOP2	DEY
  1347  e6d3 d0fd               		BNE BELLOOP2				; Delay loop
  1348  e6d5 38                 		SEC
  1349  e6d6 e901               		SBC #1
  1350  e6d8 d0f8               		BNE BELLOOP2				; Delay loop
  1351  e6da ca                 		DEX
  1352  e6db d0ed               		BNE BELLOOP1				; Delay loop
  1353  e6dd 8e4ae8             		STX VIA_Shift
  1354  e6e0 8e4be8             		STX VIA_ACR
  1355  e6e3 60                 BELLDONE	RTS
  1356                          
  1357                          ;*********************************************************************************************************
  1358                          ;** Keyboard Decoding Table  [E6D1]
  1359                          ;*********************************************************************************************************
  1360                          

; ******** Source: keyboard.asm
     1                          ; PET/CBM EDIT ROM - Keyboard Matrix Selection
     2                          ; ================
     3                          ; This adds the appropriate keyboard matrix or matrices depending on options:
     4                          ; KEYSCAN=n  -- which keyboard scanning routine is used
     5                          ; KEYBOARD=n -- to select the matrix layout
     6                          ;
     7                          ; Note: Not all keyboards are defined for all options! Please check source
     8                          ;------------------------------------------------------------------------------
     9                          
    10                          !if KEYSCAN=0 { !source "keyboard-tables1.asm" }	; Graphic (Normal) Keyboard Scanner - Simple

; ******** Source: keyboard-tables1.asm
     1                          ; PET/CBM EDIT ROM - Keyboard Matrix Tables for KEYSCAN-N, KEYSCAN-B scanner code
     2                          ; ================
     3                          ; 
     4                          ; Notes:
     5                          ;	Modifier Keys: 00 = Shift, 10 = Repeat, 80 = CTRL
     6                          ;	Special Codes: Bit 7 set (+$80) = Unshiftable, FF = No Key
     7                          ;       Labelling:
     8                          ;	   KP = Keypad, S- = Shift , GR- = Graphic Code, NONE = No Key
     9                          ;          CTRL- = CTRL+key , SHC- = Shift-CTRL+key, A- = Accent
    10                          ;
    11                          ; STOP KEY:
    12                          ; The normal EDITROM N/B scanner scans the keyboard from ROW9 to ROW0. ROW0 is left selected when complete.
    13                          ; The KERNAL has a routine at $F7A1 that scans the last selected ROW, which is ROW0 and puts it in STKEY ($9B).
    14                          ; Then the routine at $F335 checks for STOP by looking in $9B for a zero in BIT4. On N/B this at: ROW X, COL 2.
    15                          ; If the STOP key is relocated, the key at ROW0/COL3 will trigger STOP.
    16                          
    17                          KEYBOARD_NORMAL
    18                          
    19                          ;---------- Normal/Graphic Keyboard - QWERTY Layout (chicklet or standard type)
    20                          ;
    21                          !IF KEYBOARD=0 {
    22                          ;     C0  C1  C2  C3  C4  C5  C6  C7    COL0   COL1   COL2   COL3   COL4   COL5   COL6   COL7   NOTES 
    23                          ;     === === === === === === === ===   ====== ====== ====== ====== ====== ====== ====== ====== =====
    24                          !byte $3d,$2e,$10,$03,$3c,$20,$5b,$12 ; KP =   KP .   CTRL-P STOP   <      SPACE  [      RVS    ROW0/A  STOP is in DEFAULT location
    25                          !byte $2d,$30,$00,$3e,$ff,$5d,$40,$00 ; KP -   KP 0   SHIFT  >      NONE   ]      @      SHIFT  ROW1/B
    26                          !byte $2b,$32,$ff,$3f,$2c,$4e,$56,$58 ; KP +   KP 2   NONE   ?      ,      n      v      x      ROW2/C
    27                          !byte $33,$31,$0d,$3b,$4d,$42,$43,$5a ; KP 3   KP 1   RETURN ;      m      b      c      z      ROW3/D
    28                          !byte $2a,$35,$ff,$3a,$4b,$48,$46,$53 ; KP *   KP 5   NONE   :      k      h      f      s      ROW4/E
    29                          !byte $36,$34,$ff,$4c,$4a,$47,$44,$41 ; KP 6   KP 4   NONE   l      j      g      d      a      ROW5/F
    30                          !byte $2f,$38,$ff,$50,$49,$59,$52,$57 ; KP /   KP 8   NONE   p      i      y      r      w      ROW6/G
    31                          !byte $39,$37,$5e,$4f,$55,$54,$45,$51 ; KP 9   KP 7   UP-ARR o      u      t      e      q      ROW7/H
    32                          !byte $14,$11,$09,$29,$5c,$27,$24,$22 ; DEL    DOWN   TAB??? )      \      '      $      "      ROW8/I
    33                          !byte $1d,$13,$5f,$28,$26,$25,$23,$21 ; RIGHT  HOME   BK-ARR (      &      %      #      !      ROW9/J
    34                          }
    35                          
    36                          ;---------- Business Keyboard - QWERTY Layout
    37                          ;
    38                          !IF KEYBOARD=1 {
    39                          ;     C0  C1  C2  C3  C4  C5  C6  C7    COL0   COL1   COL2   COL3   COL4   COL5   COL6   COL7   NOTES 
    40                          ;     === === === === === === === ===   ====== ====== ====== ====== ====== ====== ====== ====== =====
    41                          !byte $16,$04,$3A,$03,$39,$36,$33,$DF ; CTRL-V CTRL-D :      STOP   9      6      3      BK-ARR ROW0/A  STOP is in DEFAULT location
    42                          !byte $B1,$2F,$15,$13,$4D,$20,$58,$12 ; KP 1   /      CTRL-U HOME   m      SPACE  x      RVS    ROW1/B
    43                          !byte $B2,$10,$0F,$B0,$2C,$4E,$56,$5A ; KP 2   RPT    CTRL-O KP 0   ,      n      v      z      ROW2/C 
    44                          !byte $B3,$00,$19,$AE,$2E,$42,$43,$00 ; KP 3   SHIFT  CTRL-Y KP .   .      b      c      SHIFT  ROW3/D
    45                          !byte $B4,$DB,$4F,$11,$55,$54,$45,$51 ; KP 4   [      o      DOWN   u      t      e      q      ROW4/E 
    46                          !byte $14,$50,$49,$DC,$59,$52,$57,$09 ; DEL    p      i      \      y      r      w      TAB    ROW5/F 
    47                          !byte $B6,$C0,$4C,$0D,$4A,$47,$44,$41 ; KP 6   @      l      RETURN j      g      d      a      ROW6/G
    48                          !byte $B5,$3B,$4B,$DD,$48,$46,$53,$9B ; KP 5   ;      k      ]      h      f      s      ESC    ROW7/H
    49                          !byte $B9,$06,$DE,$B7,$B0,$37,$34,$31 ; KP 9   CTRL-F UP-ARR KP 7   0      7      4      1      ROW8/I
    50                          !byte $05,$0E,$1D,$B8,$2D,$38,$35,$32 ; CTRL-E CTRL-N RIGHT  KP 8   -      8      5      2      ROW9/J
    51                          }
    52                          
    53                          ;---------- Business Keyboard - German DIN, QWERTZ (Version 1) Layout
    54                          ;
    55                          !IF KEYBOARD=2 {
    56                          ;     C0  C1  C2  C3  C4  C5  C6  C7    COL0   COL1   COL2   COL3   COL4   COL5   COL6   COL7   NOTES
    57                          ;     === === === === === === === ===   ====== ====== ====== ====== ====== ====== ====== ====== =====
    58                          !byte $16,$04,$40,$03,$39,$36,$33,$5F ; CTRL-V CTRL-D @      STOP   9      6      3      BK-ARR ROW0/A  ..x....x  STOP is in DEFAULT location
    59                          !byte $B1,$2F,$15,$13,$4D,$20,$58,$12 ; KP 1   /      CTRL-U HOME   M      SPACE  x      RVS    ROW1/B  ........
    60                          !byte $B2,$80,$0F,$01,$2C,$4E,$56,$59 ; KP 2   CTRL   CTRL-O KP 0   ,      n      v      y      ROW2/C  .x.x...x <- $80=CTRL (was $10=REPEAT)
    61                          !byte $B3,$00,$19,$AE,$2E,$42,$43,$00 ; KP 3   SHIFT  CTRL-Y KP .   .      b      c      SHIFT  ROW3/D  ........ <- $00=SHIFT
    62                          !byte $B4,$5B,$4F,$11,$55,$54,$45,$51 ; KP 4   [      o      DOWN   u      t      e      q      ROW4/E  .x......
    63                          !byte $14,$50,$49,$3A,$5A,$52,$57,$09 ; DEL    p      i      :      z      r      w      TAB    ROW5/F  ...xx...
    64                          !byte $B6,$5D,$4C,$0D,$4A,$47,$44,$41 ; KP 6   ]      l      RETURN j      g      d      a      ROW6/G  .x......
    65                          !byte $B5,$5C,$4B,$3B,$48,$46,$53,$1B ; KP 5   \      k      ;      h      f      s      ESC    ROW7/H  .......x
    66                          !byte $B9,$06,$5E,$B7,$B0,$37,$34,$31 ; KP 9   CTRL-F UP-ARR KP 7   0      7      4      1      ROW8/I  ..x.....
    67                          !byte $05,$0E,$1D,$B8,$2D,$38,$35,$32 ; CTRL-E CTRL-N RIGHT  KP 8   -      8      5      2      ROW9/J  ........
    68                          }
    69                          
    70                          ;---------- C64/VIC-20 Keyboard
    71                          ;
    72                          ; Keyboard will plug directly into the PET keyboard connector.
    73                          ; It is electrically compatible, but only uses an 8x8 matrix of keys.
    74                          ; Due to the nature of the keyboard and different labelling, the following changes are made:
    75                          ;
    76                          ; * Code Change: SHIFT=01 with 00
    77                          ; * Reassign   : POUND as \=5C, CTRL as RVS=12, C= as ESC=9B
    78                          ; * Reassign   : F1 as TEXT=0E, F3 as DELETE LINE=15, F5 as ERASE TO START=16, F7 as SCROLL DOWN=19
    79                          
    80                          !IF KEYBOARD=3 {
    81                          ;     C0  C1  C2  C3  C4  C5  C6  C7    COL0   COL1   COL2   COL3   COL4   COL5   COL6   COL7   NOTES 
    82                          ;     === === === === === === === ===   ====== ====== ====== ====== ====== ====== ====== ====== =====
    83  e6e4 ffffffffffffffff   !byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF ; NONE   NONE   NONE   NONE   NONE   NONE   NONE   NONE   ROW0/A  STOP is RELOCATED!
    84  e6ec ffffffffffffffff   !byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF ; NONE   NONE   NONE   NONE   NONE   NONE   NONE   NONE   ROW1/B
    85  e6f4 19132d3038363432   !byte $19,$13,$2D,$30,$38,$36,$34,$32 ; F7     HOME   -      0      8      6      4      2      ROW2/C
    86  e6fc 165e404f55544551   !byte $16,$5E,$40,$4F,$55,$54,$45,$51 ; F5     UP-ARR @      O      U      T      E      Q      ROW3/D
    87  e704 153d3a4b4846539b   !byte $15,$3D,$3A,$4B,$48,$46,$53,$9B ; F3     =      :      K      H      F      S      C=     ROW4/E
    88  e70c 0e002e4d42435a20   !byte $0E,$00,$2E,$4D,$42,$43,$5A,$20 ; F1     SHIFT  .      M      B      C      Z      SPACE  ROW5/F
    89  e714 112f2c4e56580003   !byte $11,$2F,$2C,$4E,$56,$58,$00,$03 ; DOWN   /      ,      N      V      X      SHIFT  STOP   ROW6/G <- to here
    90  e71c 1d3b4c4a47444112   !byte $1D,$3B,$4C,$4A,$47,$44,$41,$12 ; RIGHT  ;      L      J      G      D      A      CTRL   ROW7/H
    91  e724 0d2a5049595257df   !byte $0D,$2A,$50,$49,$59,$52,$57,$DF ; RETURN *      P      I      Y      R      W      BK-ARR ROW8/I
    92  e72c 145c2b3937353331   !byte $14,$5C,$2B,$39,$37,$35,$33,$31 ; DEL    POUND  +      9      7      5      3      1      ROW9/J
    93                          }
    94                          
    95                          ;---------- Business Keyboard - Modified QWERTY Layout - BSJG
    96                          ;
    97                          ; This is a B keyboard with re-arranged layout to make it closer to C64 keyboard
    98                          ; ESC moved to top left. Cursor keys to bottom CLR/HOME and INS/DEL moved to top row
    99                          ; REPEAT moved to bottom left.
   100                          ;
   101                          !IF KEYBOARD=4 {
   102                          ;     C0  C1  C2  C3  C4  C5  C6  C7    COL0   COL1   COL2   COL3   COL4   COL5   COL6   COL7   NOTES 
   103                          ;     === === === === === === === ===   ====== ====== ====== ====== ====== ====== ====== ====== ======
   104                          !byte $16,$04,$3A,$14,$39,$36,$33,$9B ; CTRL-V CTRL-D :      DEL    9      6      3      ESC    ROW0/A  STOP is RELOCATED!
   105                          !byte $B1,$2F,$15,$1D,$4D,$20,$58,$10 ; KP 1   /      CTRL-U RIGHT  m      SPACE  x      REPT   ROW1/B 
   106                          !byte $B2,$11,$0F,$B0,$2C,$4E,$56,$5A ; KP 2   DOWN   CTRL-O KP 0   ,      n      v      z      ROW2/C
   107                          !byte $B3,$00,$19,$AE,$2E,$42,$43,$00 ; KP 3   SHIFT  CTRL-Y KP .   .      n      c      SHIFT  ROW3/D
   108                          !byte $B4,$DB,$4F,$DF,$55,$54,$45,$51 ; KP 4   [      o      BK-ARR u      t      e      q      ROW4/E
   109                          !byte $DE,$50,$49,$DD,$59,$52,$57,$09 ; UP-ARR p      i      ]      y      r      w      TAB    ROW5/F
   110                          !byte $B6,$C0,$4C,$0D,$4A,$47,$44,$41 ; KP 6   @      l      RETURN j      g      d      a      ROW6/G
   111                          !byte $B5,$3B,$4B,$DC,$48,$46,$53,$03 ; KP 5   ;      k      \      h      f      s      STOP   ROW7/H <- to here
   112                          !byte $B9,$06,$12,$B7,$B0,$37,$34,$31 ; KP     CTRL-F RVS    KP 7   0      7      4      1      ROW8/I
   113                          !byte $05,$0E,$13,$B8,$2D,$38,$35,$32 ; CTRL-E CTRL-N HOME   KP 8   -      8      5      2      ROW9/J
   114                          }
   115                          
   116                          ;---------- Graphic Keyboard - Modified QWERTY Layout - NSJG
   117                          ;
   118                          ; In order to use ESC codes, the keyboard must have an ESC key. The standard Graphic keyboard has none,
   119                          ; so the "@" key is used instead as it occupies the position an ESC key would normally be. The BACKARROW
   120                          ; key will become the "@" symbol so that the DOS wedge is usable (BACKARROW is rarely used).
   121                          ;
   122                          !IF KEYBOARD=5 {
   123                          ;     C0  C1  C2  C3  C4  C5  C6  C7    COL0   COL1   COL2   COL3   COL4   COL5   COL6   COL7   NOTES 
   124                          ;     === === === === === === === ===   ====== ====== ====== ====== ====== ====== ====== ====== =====
   125                          !byte $3d,$2e,$10,$03,$3c,$20,$5b,$12 ; KP =   KP .   CTRL-P STOP   <      SPACE  [      RVS    ROW0/A  STOP is in DEFAULT location
   126                          !byte $2d,$30,$00,$3e,$ff,$5d,$9b,$00 ; KP -   KP 0   SHIFT  >      NONE   ]      ESC    SHIFT  ROW1/B  @ replaced with ESC
   127                          !byte $2b,$32,$ff,$3f,$2c,$4e,$56,$58 ; KP +   KP 2   NONE   ?      ,      n      v      x      ROW2/C
   128                          !byte $33,$31,$0d,$3b,$4d,$42,$43,$5a ; KP 3   KP 1   RETURN ;      m      b      c      z      ROW3/D
   129                          !byte $2a,$35,$ff,$3a,$4b,$48,$46,$53 ; KP *   KP 5   NONE   :      k      h      f      s      ROW4/E
   130                          !byte $36,$34,$ff,$4c,$4a,$47,$44,$41 ; KP 6   KP 4   NONE   l      j      g      d      a      ROW5/F
   131                          !byte $2f,$38,$ff,$50,$49,$59,$52,$57 ; KP /   KP 8   NONE   p      i      y      r      w      ROW6/G
   132                          !byte $39,$37,$5e,$4f,$55,$54,$45,$51 ; KP 9   KP 7   UP-ARR o      u      t      e      q      ROW7/H
   133                          !byte $14,$11,$09,$29,$5c,$27,$24,$22 ; DEL    DOWN   TAB??? )      \      '      $      "      ROW8/I
   134                          !byte $1d,$13,$40,$28,$26,$25,$23,$21 ; RIGHT  HOME   @      (      &      %      #      !      ROW9/J  BACKARROW replaced by @
   135                          }
   136                          
   137                          ;---------- Business Keyboard - QWERTZ Layout
   138                          ;
   139                          !IF KEYBOARD=6 {
   140                          ;     C0  C1  C2  C3  C4  C5  C6  C7    COL0   COL1   COL2   COL3   COL4   COL5   COL6   COL7   NOTES 
   141                          ;     === === === === === === === ===   ====== ====== ====== ====== ====== ====== ====== ====== =====
   142                          !byte $16,$04,$3A,$03,$39,$36,$33,$DF ; CTRL-V CTRL-D :      STOP   9      6      3      BK-ARR ROW0/A  STOP is in DEFAULT location 
   143                          !byte $B1,$2F,$15,$13,$4D,$20,$58,$12 ; KP 1   /      CTRL-U HOME   m      SPACE  x      RVS    ROW1/B 
   144                          !byte $B2,$10,$0F,$B0,$2C,$4E,$56,$59 ; KP 2   RPT    CTRL-O KP 0   ,      n      v      y      ROW2/C 
   145                          !byte $B3,$00,$19,$AE,$2E,$42,$43,$00 ; KP 3   SHIFT  CTRL-Y KP .   .      b      c      SHIFT  ROW3/D
   146                          !byte $B4,$DB,$4F,$11,$55,$54,$45,$51 ; KP 4   ]      o      DOWN   u      t      e      q      ROW4/E
   147                          !byte $14,$50,$49,$DC,$5A,$52,$57,$09 ; DEL    p      i      @      z      r      w      TAB    ROW5/F
   148                          !byte $B6,$C0,$4C,$0D,$4A,$47,$44,$41 ; KP 6   [      l      RETURN j      g      d      a      ROW6/G
   149                          !byte $B5,$3B,$4B,$DD,$48,$46,$53,$9B ; KP 5   \      k      ;      h      f      s      ESC    ROW7/H
   150                          !byte $B9,$06,$DE,$B7,$B0,$37,$34,$31 ; KP 9   CTRL-F UP-ARR KP 7   0      7      4      1      ROW8/I
   151                          !byte $05,$0E,$1D,$B8,$2D,$38,$35,$32 ; CTRL-E CTRL-N RIGHT  KP 8   -      8      5      2      ROW9/J
   152                          }
   153                          
   154                          ;----------- Business Keyboard - French AZERTY Layout
   155                          ;
   156                          !IF KEYBOARD=7 {
   157                          ;     C0  C1  C2  C3  C4  C5  C6  C7    COL0   COL1   COL2   COL3   COL4   COL5   COL6   COL7   NOTES 
   158                          ;     === === === === === === === ===   ====== ====== ====== ====== ====== ====== ====== ====== =====
   159                          !byte $16,$04,$3A,$03,$39,$36,$33,$DF ; CTRL-V CTRL-D :      STOP   9      6      3      BK-ARR ROW0/A  STOP is in DEFAULT location
   160                          !byte $B1,$2F,$15,$13,$4D,$20,$58,$12 ; KP 1   /      CTRL-U HOME   m      SPACE  x      RVS    ROW1/B
   161                          !byte $B2,$10,$0F,$B0,$2C,$4E,$56,$5A ; KP 2   RPT    CTRL-O KP 0   ,      n      v      z      ROW2/C 
   162                          !byte $B3,$00,$19,$AE,$2E,$42,$43,$00 ; KP 3   SHIFT  CTRL-Y KP .   .      b      c      SHIFT  ROW3/D
   163                          !byte $B4,$DB,$4F,$11,$55,$54,$45,$51 ; KP 4   [      o      DOWN   u      t      e      q      ROW4/E 
   164                          !byte $14,$50,$49,$DC,$59,$52,$57,$09 ; DEL    p      i      \      y      r      w      TAB    ROW5/F 
   165                          !byte $B6,$C0,$4C,$0D,$4A,$47,$44,$41 ; KP 6   @      l      RETURN j      g      d      a      ROW6/G
   166                          !byte $B5,$3B,$4B,$DD,$48,$46,$53,$9B ; KP 5   ;      k      ]      h      f      s      ESC    ROW7/H
   167                          !byte $B9,$06,$DE,$B7,$B0,$37,$34,$31 ; KP 9   CTRL-F UP-ARR KP 7   0      7      4      1      ROW8/I
   168                          !byte $05,$0E,$1D,$B8,$2D,$38,$35,$32 ; CTRL-E CTRL-N RIGHT  KP 8   -      8      5      2      ROW9/J
   169                          }
   170                          
   171                          ;----------- CBM-II (B-Series, P-Series) - QWERTY Layout
   172                          ;
   173                          ; The CBM-II keyboard has a 16*6 matrix, so it requires a hardware modification to work on the PET,
   174                          ; and a small modification to the keyboard scanning routine.
   175                          ; It also has many extra keys with no equivilent function, and so will have some non-functioning keys.
   176                          ;
   177                          ; *** WORK IN PROGRESS!!!!!!!
   178                          ;
   179                          !IF KEYBOARD=8 {
   180                          ;     C0  C1  C2  C3  C4  C5    COL0   COL1   COL2   COL3   COL4   COL5   NOTES 
   181                          ;     === === === === === ===   ====== ====== ====== ====== ====== ====== =====
   182                          !BYTE $E0,$1B,$09,$FF,$00,$01 ; F1     ESCAPE TAB    NONE   SHIFT  CTRL   ROW0/A
   183                          !BYTE $E1,$31,$51,$41,$5A,$FF ; F2     1      Q      A      Z      NONE   ROW1/B
   184                          !BYTE $E2,$32,$57,$53,$58,$43 ; F3     2      W      S      X      C      ROW2/C
   185                          !BYTE $E3,$33,$45,$44,$46,$56 ; F4     3      E      D      F      V      ROW3/D
   186                          !BYTE $E4,$34,$52,$54,$47,$42 ; F5     4      R      T      G      B      ROW4/E
   187                          !BYTE $E5,$35,$36,$59,$48,$4E ; F6     5      6      Y      H      N      ROW5/F
   188                          !BYTE $E6,$37,$55,$4A,$4D,$20 ; F7     7      U      J      M      SPACE  ROW6/G
   189                          !BYTE $E7,$38,$49,$4B,$2C,$2E ; F8     8      I      K      ,      .      ROW7/H
   190                          !BYTE $E8,$39,$4F,$4C,$3B,$2F ; F9     9      O      L      ;      /      ROW8/I
   191                          !BYTE $E9,$30,$2D,$50,$5B,$27 ; F10    0      -      P      [      '      ROW9/J
   192                          !BYTE $11,$3D,$5F,$5D,$0D,$DE ; DOWN   =      _      ]      RETURN PI     ROW10/K
   193                          !BYTE $91,$9D,$1D,$14,$02,$FF ; UP     LEFT   RIGHT  DEL    CMDR   NONE   ROW11/L
   194                          !BYTE $13,$3F,$37,$34,$31,$30 ; HOME   ?      7      4      1      0      ROW12/M
   195                          !BYTE $12,$04,$38,$35,$32,$2E ; RVS    CE     8      5      2      .      ROW13/N
   196                          !BYTE $8E,$2A,$39,$36,$33,$30 ; GRAPH  *      9      6      3      00     ROW14/O
   197                          !BYTE $03,$2F,$2D,$2B,$0D,$FF ; STOP   /      -      +      ENTER  NONE   ROW15/P
   198                          }
   199                          
   200                          ;----------- Normal/Graphic Keyboard - Modified QWERTY Layout with [ESC] modification
   201                          ;
   202                          ; In order to use ESC codes, the keyboard must have an ESC key. The standard Graphic keyboard has none.
   203                          ; This layout changes the BACKARROW to ESC.
   204                          ;
   205                          !IF KEYBOARD=9 {
   206                          ;     C0  C1  C2  C3  C4  C5  C6  C7    COL0   COL1   COL2   COL3   COL4   COL5   COL6   COL7   NOTES 
   207                          ;     === === === === === === === ===   ====== ====== ====== ====== ====== ====== ====== ====== =====
   208                          !byte $3d,$2e,$10,$03,$3c,$20,$5b,$12 ; KP =   KP .   CTRL-P STOP   <      SPACE  [      RVS    ROW0/A  STOP is in DEFAULT location
   209                          !byte $2d,$30,$00,$3e,$ff,$5d,$40,$00 ; KP -   KP 0   SHIFT  >      NONE   ]      @      SHIFT  ROW1/B
   210                          !byte $2b,$32,$ff,$3f,$2c,$4e,$56,$58 ; KP +   KP 2   NONE   ?      ,      n      v      x      ROW2/C
   211                          !byte $33,$31,$0d,$3b,$4d,$42,$43,$5a ; KP 3   KP 1   RETURN ;      m      b      c      z      ROW3/D
   212                          !byte $2a,$35,$ff,$3a,$4b,$48,$46,$53 ; KP *   KP 5   NONE   :      k      h      f      s      ROW4/E
   213                          !byte $36,$34,$ff,$4c,$4a,$47,$44,$41 ; KP 6   KP 4   NONE   l      j      g      d      a      ROW5/F
   214                          !byte $2f,$38,$ff,$50,$49,$59,$52,$57 ; KP /   KP 8   NONE   p      i      y      r      w      ROW6/G
   215                          !byte $39,$37,$5e,$4f,$55,$54,$45,$51 ; KP 9   KP 7   UP-ARR o      u      t      e      q      ROW7/H
   216                          !byte $14,$11,$09,$29,$5c,$27,$24,$22 ; DEL    DOWN   TAB??? )      \      '      $      "      ROW8/I
   217                          !byte $1d,$13,$1b,$28,$26,$25,$23,$21 ; RIGHT  HOME   BK-ARR (      &      %      #      !      ROW9/J   BACKARROW replaced by @
   218                          }
   219                          
   220                          ;----------- TED Series (C116/C16/Plus4) QWERTY Layout
   221                          ;
   222                          ; The TED keyboards have different connectors depending on model. Also, the pinouts
   223                          ; do not group the ROWs and COLs so you will need to make an adapter cable.
   224                          ; TED keyboards have 4 separate cursor keys meaning no SHIFT is needed. This will likely
   225                          ; conflict with the keyboard scanner which uses the TOP BIT of the character to indicate
   226                          ; it cannot be shifted. Cursor UP and LEFT are normally shifted.
   227                          ;
   228                          ; Due to the nature of the keyboard and different labelling, the following changes are made:
   229                          ;
   230                          ; * Code Change: SHIFT=01 with 00, CTRL with 80
   231                          ; * Reassign   : POUND as \=5C, C= as TEXT/GRAPHICS mode
   232                          ; * Reassign   : F1 as TEXT=0E, F2 as DELETE LINE=15, F3 as ERASE TO START=16, HELP as SCROLL DOWN=19
   233                          ;
   234                          ; NOTE: Pin 3=LED, Pin 4=GND
   235                          ; *** THIS KEYBOARD MATRIX HAS NOT BEEN TESTED!!!!
   236                          ;
   237                          !IF KEYBOARD=11 {
   238                          ;PIN: 17  14  13  2   6   8   9   16
   239                          ;     C0  C1  C2  C3  C4  C5  C6  C7    COL0   COL1   COL2   COL3   COL4   COL5   COL6   COL7   NOTES  PIN
   240                          ;     === === === === === === === ===   ====== ====== ====== ====== ====== ====== ====== ====== =====  ===
   241                          !byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF ; NONE   NONE   NONE   NONE   NONE   NONE   NONE   NONE   ROW0/A -    STOP is RELOCATED
   242                          !byte $FF,$FF,$FF,$FF,$FF,$FF,$FF,$FF ; NONE   NONE   NONE   NONE   NONE   NONE   NONE   NONE   ROW1/B -
   243                          !byte $31,$13,$00,$03,$20,$0E,$51,$32 ;	1      CLR    CTRL   STOP   SPACE  C=     Q      2      ROW2/C 5 
   244                          !byte $33,$57,$41,$00,$5A,$53,$45,$34 ; 3      W      A      SHIFT  Z      S      E      4      ROW3/D 7
   245                          !byte $35,$52,$44,$58,$43,$46,$54,$36 ; 5      R      D      X      C      F      T      6      ROW4/E 11
   246                          !byte $37,$59,$47,$56,$42,$48,$55,$38 ; 7      Y      G      V      B      H      U      8      ROW5/F 10
   247                          !byte $39,$49,$4A,$4E,$4D,$4B,$4F,$30 ; 9      I      J      N      M      K      O      0      ROW6/G 12
   248                          !byte $11,$50,$4C,$2C,$2E,$3B,$2D,$91 ; DOWN   P      L      ,      .      :      -      UP     ROW7/H 1
   249                          !byte $9D,$2A,$3B,$2F,$1B,$3D,$2B,$1D ; LEFT   *      ;      /      ESC    =      +      RIGHT  ROW8/I 15
   250                          !byte $14,$0D,$5C,$40,$0E,$15,$16,$19 ; DEL    RETURN POUND  @      F1     F2     F3     HELP   ROW9/J 18
   251                          }
   252                          
   253                          ;----------- C128 Keyboard - Requires hardware mod for larger matrix
   254                          ;
   255                          ; This table is taken from a C128 ROM disassembly and re-formatted
   256                          ; This has not been tested! It looks like the ROWS and COLUMNS are
   257                          ; reversed compared to the PET/CBM keyboard scanner. This will either
   258                          ; require re-ordering the matrix, or re-wiring/adapting the connector.
   259                          ;
   260                          ; CHANGES:
   261                          ;           SHIFT ($01) to SHIFT ($00)
   262                          ;           CTRL  ($04) to CTRL  ($80)
   263                          ;           ALT   ($08) to SHIFT ($00)
   264                          ;           NOSCRL($FF) to SHIFT ($00)
   265                          ; PIN
   266                          ; 1   GROUND
   267                          ; 2   NO PIN (keyed)
   268                          ; 4   +5V
   269                          ; 
   270                          ; Keys not in matrix:
   271                          ;    RESTORE  = pin 1 and pin 3
   272                          ;    40/80    = pin 1 and pin 24
   273                          ;    CAPS LOCK= pin 1 and pin 25
   274                          ;
   275                          ; *** THIS KEYBOARD MATRIX HAS NOT BEEN TESTED!!!!
   276                          ;
   277                          !IF KEYBOARD=12 {
   278                          
   279                          ;PIN: 12  11  10  5   8   7   6   9
   280                          ;     C0  C1  C2  C3  C4  C5  C6  C7    COL0   COL1   COL2   COL3   COL4   COL5   COL6   COL7   NOTES  PIN
   281                          ;     === === === === === === === ===   ====== ====== ====== ====== ====== ====== ====== ====== =====  ===
   282                          !byte $14,$0D,$1D,$88,$85,$86,$87,$11 ; DEL    RETURN RIGHT  .      .      .      .      DOWN   ROW0   13  STOP is RELOCATED
   283                          !byte $33,$57,$41,$34,$5A,$53,$45,$00 ; 3      w      a      4      z      s      e      SHIFT  ROW1   19
   284                          !byte $35,$52,$44,$36,$43,$46,$54,$58 ; 5      r      d      6      c      f      t      x      ROW2   18
   285                          !byte $37,$59,$47,$38,$42,$48,$55,$56 ; 7      y      g      8      b      h      u      v      ROW3   17
   286                          !byte $39,$49,$4A,$30,$4D,$4B,$4F,$4E ; 9      i      j      0      m      k      o      n      ROW4   16
   287                          !byte $2B,$50,$4C,$2D,$2E,$3A,$40,$2C ; +      p      l      -      .      :      @      ,      ROW5   15
   288                          !byte $5C,$2A,$3B,$13,$00,$3D,$5E,$2F ; \      *      ;      HOME   SHIFT  =      ^      /      ROW6   14
   289                          !byte $31,$5F,$80,$32,$20,$02,$51,$03 ; 1      BARROW CTRL   2      SPACE  CBM    q      STOP   ROW7   20
   290                          !byte $84,$38,$35,$09,$32,$34,$37,$31 ; HELP   8      5      TAB    2      4      7      1      ROW8   21
   291                          !byte $1B,$2B,$2D,$0A,$0D,$36,$39,$33 ; ESC    +      -      LF     ENTER  6      9      3      ROW9   22
   292                          !byte $08,$30,$2E,$91,$11,$9D,$1D,$00 ; ALT    0      .      UP     DOWN   LEFT   RIGHT  NOSCRL ROW10  23
   293                          }

; ******** Source: keyboard.asm
    11                          }	; Business Keyboard Scanner - Simple with code for specific shifted keys
    12                          !if KEYSCAN=2 { !source "keyboard-tables2.asm" }	; Extended Keyboard Scanner - Two Tables (Normal and Shifted)
    13                          !if ((CODEBASE>0) & (KEYSCAN=3)) { 
    14                          		!source "keyboard-tables3.asm" }	; C64 keyboard tables (only on newer codebases; put in ext space on codebase 0)

; ******** Source: editrom80.asm
  1361                          
  1362                          
  1363                          ;*********************************************************************************************************
  1364                          ;** SHIFT RUN/STOP string  [E721]
  1365                          ;*********************************************************************************************************
  1366                          
  1367  e734 44cc222a0d         RUN_STRING	!byte $44,$cc,$22,$2a,$0d		; dL"*<RETURN>
  1368  e739 52554e0d           		!byte $52,$55,$4e,$0d			; run<RETURN>
  1369                          
  1370                          ;*********************************************************************************************************
  1371                          ;** CRTC Chip Register Setup Tables (2K ROMs) [E72A]
  1372                          ;*********************************************************************************************************
  1373                          

; ******** Source: crtc-tables.asm
     1                          ; PET/CBM EDIT ROM - CRTC Register Table Selection
     2                          ; ================
     3                          ; Sets the CRTC Table depending on options
     4                          ; COLUMNS ---- 40 or 80 column hardware (with special cases 90 and 32)
     5                          ; SOFT40 ----- Software Defined 40-column modes
     6                          
     7                          
     8                          !IF COLUMNS=40 {
     9                          	!IF SOFT40=0 { !SOURCE "crtc-reg-normal.asm" }
    10                          	!IF SOFT40=1 { !SOURCE "crtc-reg-soft40.asm" }
    11                          } ELSE {

; ******** Source: crtc-reg-normal.asm
     1                          ; PET/CBM EDIT ROM - CRTC Register Tables
     2                          ; ================
     3                          ; For "normal" configurations (ie: for single main screen)
     4                          ; Sets the CRTC Table depending on options:
     5                          ; COLUMNS = 32,40,64,80,90
     6                          ;
     7                          ;======================================
     8                          ; NORMAL 4000/8000/8296/SuperPET MODELS
     9                          ;======================================
    10                          ; Common settings for "normal" machines (4000,8000,8296,SuperPET) with 12" monitor
    11                          ; NOTE: The 8296D uses a different monitor than the 8296 and requires a different register table (see below)
    12                          
    13                          ; REGISTER#->>>      DECIMAL: 00  01  02  03  04  05  06  07  08  09  10  11  12  13  14  15  16  17
    14                          ;                        HEX: 00  01  02  03  04  05  06  07  08  09  0A  0B  0C  0D  0E  0F  10  11  
    15                          ;                             ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==  ==
    16                          ;
    17                          ;---------------------- 40/80x25, 50 Hz, 20 kHz for 12" Internal Monitor (inverted video R12=$10)
    18                          !IF REFRESH=0 {
    19                          CRT_CONFIG_TEXT:	!byte $31,$28,$29,$0f,$27,$00,$19,$20,$00,$09,$00,$00,$10,$00,$00,$00,$00,$00 
    20                          CRT_CONFIG_GRAPHICS:	!byte $31,$28,$29,$0f,$31,$00,$19,$25,$00,$07,$00,$00,$10,$00,$00,$00,$00,$00
    21                          }
    22                          
    23                          ;---------------------- 40/80x25, 60 Hz, 20 kHz for 12" Internal Monitor (inverted video)
    24                          !IF REFRESH=1 {
    25  e73d 3128290f2003191d...CRT_CONFIG_TEXT:	!byte $31,$28,$29,$0f,$20,$03,$19,$1d,$00,$09,$00,$00,$10,$00,$00,$00,$00,$00 
    26  e74f 3128290f28051921...CRT_CONFIG_GRAPHICS:	!byte $31,$28,$29,$0f,$28,$05,$19,$21,$00,$07,$00,$00,$10,$00,$00,$00,$00,$00
    27                          }
    28                          
    29                          ;---------------------- 40/80x25, 50 Hz, 15.625 kHz (PAL)  for External Monitor (inverted video)
    30                          !IF REFRESH=2 {
    31                          CRT_CONFIG_TEXT:	!byte $3f,$28,$2f,$14,$24,$7b,$19,$20,$00,$07,$00,$00,$10,$00,$00,$00,$00,$00 
    32                          CRT_CONFIG_GRAPHICS:	!byte $3f,$28,$2f,$14,$24,$7b,$19,$20,$00,$07,$00,$00,$10,$00,$00,$00,$00,$00
    33                          }
    34                          
    35                          ;---------------------- 40/80x25, 60 Hz, 15.748 kHz (NTSC) for External Monitor (inverted video)
    36                          !IF REFRESH=3 {
    37                          CRT_CONFIG_TEXT:	!byte $3f,$28,$32,$12,$1e,$06,$19,$1C,$00,$07,$00,$00,$10,$00,$00,$00,$00,$00 
    38                          CRT_CONFIG_GRAPHICS:	!byte $3f,$28,$32,$12,$1e,$06,$19,$1C,$00,$07,$00,$00,$10,$00,$00,$00,$00,$00
    39                          }
    40                          
    41                          ;---------------------- 40/80x25, 50 Hz, 15 kHz for 9" Internal Monitor (non-inverted video)
    42                          !IF REFRESH=4 {
    43                          CRT_CONFIG_TEXT:	!byte $3F,$28,$30,$8E,$20,$00,$19,$1C,$00,$09,$00,$00,$00,$00,$00,$00,$00,$00 
    44                          CRT_CONFIG_GRAPHICS:	!byte $3F,$28,$30,$8E,$20,$00,$19,$1C,$00,$07,$00,$00,$00,$00,$00,$00,$00,$00 
    45                          }
    46                          
    47                          ;---------------------- 40/80x25, 60 Hz, 15 kHz for 9" Internal Monitor (non-inverted video)
    48                          !IF REFRESH=5 {
    49                          CRT_CONFIG_TEXT:	!byte $3F,$28,$30,$8E,$20,$00,$19,$1C,$00,$09,$00,$00,$00,$00,$00,$00,$00,$00 
    50                          CRT_CONFIG_GRAPHICS:	!byte $3F,$28,$30,$8E,$20,$00,$19,$1C,$00,$07,$00,$00,$00,$00,$00,$00,$00,$00 
    51                          }
    52                          
    53                          ;===============
    54                          ; 8296D MACHINES
    55                          ;===============
    56                          ; The 8296D has a different monitor than standard machines and requires slightly modified timing
    57                          
    58                          ;---------------------- 40/80x25, 50 Hz, 16.949 kHz for 12" Internal 8296D Monitor (V1)
    59                          !IF REFRESH=82 {
    60                          CRT_CONFIG_TEXT:	!byte $3A,$28,$2C,$08,$20,$09,$19,$1D,$00,$09,$00,$00,$10,$00,$00,$00,$00,$00
    61                          CRT_CONFIG_GRAPHICS:	!byte $3A,$28,$2C,$08,$29,$03,$19,$22,$00,$07,$00,$00,$10,$00,$00,$00,$00,$00
    62                          }
    63                          
    64                          ;---------------------- 40/80x25, 50 Hz, 16.949 kHz for 12" Internal 8296D Monitor (V2)
    65                          !IF REFRESH=83 {
    66                          CRT_CONFIG_TEXT:	!byte $32,$28,$28,$08,$26,$02,$19,$20,$00,$09,$00,$00,$10,$00,$00,$00,$00,$00
    67                          CRT_CONFIG_GRAPHICS:	!byte $32,$28,$28,$08,$30,$00,$19,$25,$00,$07,$00,$00,$10,$00,$00,$00,$00,$00
    68                          }
    69                          
    70                          
    71                          ;======================
    72                          ; Extended/Experimental
    73                          ;======================
    74                          ; NOTE: Screens larger than 25 lines are for 8296 ONLY!!! The 8296 has additional screen RAM.
    75                          ;       These settings push the monitor to it's maximum possible resolution. Because of this you loose
    76                          ;       the ability to expand the line height in 'text' mode.
    77                          
    78                          ;---------------------- 40/80x32, 60 Hz, ?? kHz for 12" Internal Monitor (8296 ONLY!!!!)
    79                          !IF REFRESH=90 {
    80                          CRT_CONFIG_TEXT:	!byte 47,40,41,15,40,7,32,39,0,7,0,0,16,0,0,0,0,0 
    81                          CRT_CONFIG_GRAPHICS:	!byte 47,40,41,15,40,7,32,39,0,7,0,0,16,0,0,0,0,0 
    82                          }
    83                          
    84                          ;---------------------- 40/80x35, 60 Hz, ?? kHz for 12" Internal Monitor (8296 ONLY!!!!)
    85                          !IF REFRESH=91 {
    86                          CRT_CONFIG_TEXT:	!byte 47,40,41,15,40,7,35,39,0,7,0,0,16,0,0,0,0,0 
    87                          CRT_CONFIG_GRAPHICS:	!byte 47,40,41,15,40,7,35,39,0,7,0,0,16,0,0,0,0,0 
    88                          }
    89                          
    90                          ;---------------------- 45/90x35, 60 Hz, ?? kHz for 12" Internal Monitor (8296 ONLY!!!!)
    91                          !IF REFRESH=92 {
    92                          CRT_CONFIG_TEXT:	!byte 52,45,45,12,40,17,35,39,0,7,0,0,16,0,0,0,0,0 
    93                          CRT_CONFIG_GRAPHICS:	!byte 52,45,45,12,40,17,35,39,0,7,0,0,16,0,0,0,0,0 
    94                          }
    95                          
    96                          ;=======================
    97                          ; CUSTOM - You Define It
    98                          ;=======================
    99                          
   100                          ;---------------------- CUSTOM - Your parameters here!
   101                          !IF REFRESH=99 {
   102                          CRT_CONFIG_TEXT:	!byte $3e,$28,$32,$12,$1e,$06,$19,$1C,$00,$07,$00,$00,$10,$00,$00,$00,$00,$00 
   103                          CRT_CONFIG_GRAPHICS:	!byte $3e,$28,$32,$12,$1e,$06,$19,$1C,$00,$07,$00,$00,$10,$00,$00,$00,$00,$00
   104                          }
   105                          

; ******** Source: crtc-tables.asm
    12                          

; ******** Source: editrom80.asm
  1374                          
  1375                          
  1376                          ;*********************************************************************************************************
  1377                          ;** BELL Sound Table  [E74D]
  1378                          ;*********************************************************************************************************
  1379                          
  1380  e761 0e1e3e7e3e1e0e     SOUND_TAB	!byte $0e,$1e,$3e,$7e,$3e,$1e,$0e	; BELL chime values
  1381                          
  1382                          ;*********************************************************************************************************
  1383                          ;** Screen Line Address Tables  [E755][E76E]
  1384                          ;*********************************************************************************************************
  1385                          

; ******** Source: screen1v.asm
     1                          ; PET/CBM EDIT ROM - Screen line address table - Screen 1 @ $8000 Video (characters)
     2                          ; ================
     3                          ; Variables: ROWS,COLUMNS
     4                          ; These tables are used to calculate the starting address of each line on the screen.
     5                          ; The standard screens are 40x25 and 80x25. Experimental screens can be up to 90x35.
     6                          ; 32 and 64 are included for future support of non-cbm type screens.
     7                          ; When ROWS>25 it assumes maximum 35 rows although less are supported as well.
     8                          
     9                          ;---------- 32 characters wide (32x32 = 1K RAM)
    10                          !IF COLUMNS=32 {
    11                          Line_Addr_Lo	!byte $00,$20,$40,$60,$80,$A0,$C0,$E0,$00,$20,$40,$60,$80,$A0,$C0,$E0
    12                          		!byte $00,$20,$40,$60,$80,$A0,$C0,$E0,$00,$20,$40,$60,$80,$A0,$C0,$E0
    13                          Line_Addr_Hi	!byte $80,$80,$80,$80,$80,$80,$80,$80,$81,$81,$81,$81,$81,$81,$81,$81
    14                          		!byte $82,$82,$82,$82,$82,$82,$82,$82,$83,$83,$83,$83,$83,$83,$83,$83
    15                          }
    16                          
    17                          ;---------- 40 characters wide 
    18                          !IF COLUMNS=40 {
    19                          Line_Addr_Lo	!byte $00,$28,$50,$78,$a0,$c8,$f0,$18,$40,$68,$90,$b8,$e0,$08,$30,$58
    20                          		!byte $80,$a8,$d0,$f8,$20,$48,$70,$98,$c0
    21                          !if ROWS>25 {	!byte $e8,$10,$38,$60,$88,$b0,$d8,$00,$28,$50 }
    22                          
    23                          Line_Addr_Hi	!byte $80,$80,$80,$80,$80,$80,$80,$81,$81,$81
    24                          		!byte $81,$81,$81,$82,$82,$82,$82,$82,$82,$82
    25                          		!byte $83,$83,$83,$83,$83
    26                          !if ROWS>25 {	!byte $83,$84,$84,$84,$84,$84,$84,$85,$85,$85 }
    27                          }
    28                          
    29                          ;---------- 64 characters wide (64x32 = 2K RAM)
    30                          !IF COLUMNS=64 {
    31                          Line_Addr_Lo	!byte $00,$40,$80,$C0,$00,$40,$80,$C0,$00,$40,$80,$C0,$00,$40,$80,$C0
    32                          		!byte $00,$40,$80,$C0,$00,$40,$80,$C0,$00,$40,$80,$C0,$00,$40,$80,$C0
    33                          Line_Addr_Hi	!byte $80,$80,$80,$80,$81,$81,$81,$81,$82,$82,$82,$82,$83,$83,$83,$83
    34                          		!byte $84,$84,$84,$84,$85,$85,$85,$85,$86,$86,$86,$86,$87,$87,$87,$87
    35                          }
    36                          
    37                          ;---------- 80 characters wide 
    38                          !IF COLUMNS=80 {
    39  e768 0050a0f04090e030...Line_Addr_Lo	!byte $00,$50,$a0,$f0,$40,$90,$e0,$30,$80,$d0
    40  e772 2070c01060b00050...		!byte $20,$70,$c0,$10,$60,$b0,$00,$50,$a0,$f0
    41  e77c 4090e03080         		!byte $40,$90,$e0,$30,$80
    42                          !if ROWS>25 {	!byte $d0,$20,$70,$c0,$10,$60,$b0,$00,$50,$a0,$f0 }
    43                          
    44  e781 8080808081818182...Line_Addr_Hi	!byte $80,$80,$80,$80,$81,$81,$81,$82,$82,$82
    45  e78b 8383838484848585...		!byte $83,$83,$83,$84,$84,$84,$85,$85,$85,$85
    46  e795 8686868787         		!byte $86,$86,$86,$87,$87
    47                          !if ROWS>25 {	!byte $87,$88,$88,$88,$89,$89,$89,$8a,$8a,$8a,$8a }
    48                          }
    49                          
    50                          ;---------- 90 characters wide
    51                          !IF COLUMNS=90 {
    52                          Line_Addr_Lo	!byte $00,$5a,$b4,$0e,$68,$c2,$1c,$76,$d0,$2a,$84,$de,$38,$92,$ec,$46
    53                          		!byte $a0,$fa,$54,$ea,$08,$62,$bc,$16,$70,$ca,$24,$7e,$d8,$32,$8c,$e6
    54                          		!byte $40,$9a,$f4
    55                          Line_Addr_Hi	!byte $80,$80,$80,$81,$81,$81,$82,$82,$82,$83,$83,$83,$84,$84,$84,$85
    56                          		!byte $85,$85,$86,$86,$87,$87,$87,$88,$88,$88,$89,$89,$89,$8a,$8a,$8a
    57                          		!byte $8b,$8b,$8b
    58                          }

; ******** Source: editrom80.asm
  1386                          					; Screen RAM address table
  1387                          		!IF COLOURPET > 0 { !SOURCE "screen1c.asm" }			; Colour address table (future hardware)
  1388                          
  1389                          ;*********************************************************************************************************
  1390                          ;** Small patches here  [E787]
  1391                          ;*********************************************************************************************************
  1392                          

; ******** Source: editbarrow.asm
     1                          ; PET/CBM EDIT ROM - BackArrow Hack/Patch
     2                          ; ================ - Adapted from 8096 edit rom found at World of Commodore 2015
     3                          ;
     4                          ; The BACKACTION variable determines which action code is included:
     5                          ; 0=Toggle Screen Text/Graphic Font
     6                          ; 1=Toggle 40/80 Column Mode (either soft40 or hardware 40/80)
     7                          
     8                          TestBackArrow
     9                          !IF KEYBOARD=0 {                        ; Graphics keyboard -> "@" as top left key
    10                                                                  ; Note: scanner clears KEYFLAGS, so can only be seen on bit 7 set
    11                          		CMP #$c0		; Is it (shifted) "@" key? (top left key).
    12                          					; NOTE: this is a graphics character. It will get discarded!
    13                          
    14                          } ELSE {
    15                                                        		; others use left arrow as top left key
    16  e79a a498               		LDY KEYFLAGS		; Is it a Shifted Char?
    17  e79c f004               		BEQ TestBAExit		; No, so exit and store key
    18  e79e c95f               		CMP #$5F		; Is it BackArrow key?
    19                          }
    20  e7a0 f004               		BEQ DoBackArrow		; Yes, perform the action then RETURN (do not store key!)
    21                          
    22  e7a2 e8                 TestBAExit	INX			; No, treat it as a normal key and store it, then increment char count
    23  e7a3 869e               		STX CharsInBuffer	; Num Chars in Keyboard Buffer
    24  e7a5 60                 		RTS
    25                          
    26                          ;---------------------------------------- Do the action
    27                          ; BACKACTION=0 to toggle Text/Graphics mode
    28                          ; BACKACTION=1 to toggle 40/80 column
    29                          
    30                          DoBackArrow:
    31                          
    32                          !IF BACKACTION=0 {
    33  e7a6 ad4ce8             		LDA VIA_PCR 		; VIA PCR - Reg#C
    34  e7a9 4902               		EOR #$02		; toggle bit 1 (graphic/text mode bit)
    35  e7ab 8d4ce8             		STA VIA_PCR 		; VIA PCR - Reg#C
    36  e7ae 60                 		RTS
    37                          }
    38                          
    39                          !IF BACKACTION=1 {
    40                          		JMP SS40_SwapModes	; Swap 40/80 mode
    41                          }

; ******** Source: editrom80.asm
  1393                          }		; Patch for BackArrow toggling of screen mode
  1394                          
  1395                          ;#########################################################################################################
  1396  e7af cd                 !IF CRUNCH=0 {	!byte $cd }		; to match 901474-04
  1397                          
  1398                          ;*********************************************************************************************************
  1399                          ;** FILLER
  1400                          ;*********************************************************************************************************
  1401                          
  1402  e7b0 aaaaaaaaaaaaaaaa...		!IF NOFILL=0 { !FILL $e800-*,$aa }	; 78 bytes - Fill to end of 2K
  1403                          
  1404                          ;#########################################################################################################
  1405                          ;END! DO NOT ADD ANYTHING BELOW THIS LINE!!!!!!!!

; ******** Source: editrom.asm
    39                          			; 80-column CODEBASE
    40                          	!IF CODEBASE=2 {!SOURCE "editrom82.asm"}			; 80-column EXTENDED CODEBASE
    41                          
    42                          ;=======================================================================
    43                          ; Determine if we need to assemble a 4K ROM
    44                          ;=======================================================================
    45                          ; We must include this area if:
    46                          ;   1) We are using CODEBASE 2
    47                          ;   2) Certain EXTended features are enabled
    48                          ;   3) BACKARROW feature needs relocating.
    49                          
    50                          	!IF ((CODEBASE=2) | ((COLOURPET + ESCCODES + WEDGE + EXECUDESK + SS40 + AUTORUN + KEYRESET) > 0) | (BACKARROW=2) | (CODEBASE=0 & KEYSCAN=3)) {

; ******** Source: editrom_hi.asm
     1                          ; PET/CBM EDIT ROM - Extended ROM Code (only if needed)
     2                          ; ================
     3                          ; $E800-EFFF for Extended ROM start address. Includes two sections:
     4                          ;   1) $E800-E8FF - IO Area
     5                          ;   3) $E900-EFFF - Extended area (Codebase 2 if required, New code)
     6                           
     7                          ;*=e800
     8                          
     9                          ;=======================================================================
    10                          ; IO Area
    11                          ;=======================================================================
    12                          ; $E800-E8FF is not visible to the PET cpu as I/O is in this space.
    13                          ; When not tring to duplicate existing code binaries, the IO.ASM file can
    14                          ; be used to place comments here that will be readable in the ROM via
    15                          ; binary viewers.
    16                          
    17                          	!IF OPTROM=0 {
    18                          		!IF CODEBASE=2 {
    19                          			!SOURCE "io_euro-4v4e.asm"			; Use Commodore's info block	
    20                          			!IF NOFILL=0 { !FILL $e900-*,$ff }		; pad with $FF as per Commodore ROMS
    21                          		} ELSE {

; ******** Source: io.asm
     1                          ; IO - This part of the ROM is not visible since IO is mapped here, so we will fill it
     2                          ; ==   with a decription of the editrom features and options.
     3                          
     4  e800 2a2a43424d204544...!text "**CBM EDIT ROM**"
     5  e810 5b                 !text "["
     6  e811 323032352d30382d...+DATE
     7                          
     8  e81b 5d20434f44454241...!text "] CODEBASE="
     9                          !IF CODEBASE=0 { !text "0" }
    10  e826 31                 !IF CODEBASE=1 { !text "1" }
    11                          !IF CODEBASE=2 { !text "2" }
    12                          
    13                          !IF COLOURPET = 1 {
    14                          	!text " COLOURPET-"
    15                          	!if COLOURVER=0 { !text "beta" }
    16                          	!if COLOURVER=1 { !text "release" }
    17                          }
    18                          
    19  e827 204b4559424f4152...!text " KEYBOARD="
    20                          	!if KEYBOARD= 0 { !text "n-qwerty" }
    21                          	!if KEYBOARD= 1 { !text "b-qwerty" }	; QWERTY layout
    22                          	!if KEYBOARD= 2 { !text "din" }
    23  e831 6336342f766963     	!if KEYBOARD= 3 { !text "c64/vic" }
    24                          	!if KEYBOARD= 4 { !text "b-sjg" }	; Modified layout - cursor keys, esc etc
    25                          	!if KEYBOARD= 5 { !text "n-sjg" }	; Modified layout - @ replaced with ESC, backarrow becomes @
    26                          	!if KEYBOARD= 6 { !text "b-qwertz" }	; QWERTZ layout
    27                          	!if KEYBOARD= 7 { !text "b-azerty" }	; AZERTY layout
    28                          	!if KEYBOARD= 8 { !text "cbm-ii" }	; CBM-II keyboard (requires hardware mod)
    29                          	!if KEYBOARD= 9 { !text "n-sjg2" }	; Modified layout - backarrow replaced with ESC
    30                          	!if KEYBOARD=11 { !text "ted" }		; TED series (C16,C116,Plus/4 etc)
    31                          
    32  e838 2053435245454e3d   !text " SCREEN="
    33                          	!if COLUMNS=32  { !text "32" }
    34                          	!if COLUMNS=40  { !text "40" }
    35  e840 3830               	!if COLUMNS=80  { !text "80" }
    36                          	!if COLUMNS=90  { !text "90" }
    37                          	!if ROWS=16     { !text "x16" }
    38  e842 783235             	!if ROWS=25     { !text "x25" }
    39                          	!if ROWS=32     { !text "x32" }
    40                          	!if ROWS=35     { !text "x35" }
    41                          	!if SOFT40=1    { !text " (soft40)" }
    42                          	!if SS40=1      {
    43  e845 2028               		!pet " ("
    44  e847 6873               		!if HARD4080=1  { !text "hs" } else { !text "ss" }
    45                          		!if SS40MODE=40 { !text "40)" }
    46  e849 383029             		!if SS40MODE=80 { !text "80)" }
    47                          	}
    48                          
    49  e84c 20484552545a3d     !text " HERTZ="
    50                          	!if HERTZ=50 { !text "50" }
    51  e853 3630               	!if HERTZ=60 { !text "60" }
    52                          
    53  e855 2052454652455348...!text " REFRESH="
    54                          	!if REFRESH= 0 { !text "euro" }
    55  e85e 6e2e616d65726963...	!if REFRESH= 1 { !text "n.america" }
    56                          	!if REFRESH= 2 { !text "pal" }
    57                          	!if REFRESH= 3 { !text "ntsc" }
    58                          	!if REFRESH= 4 { !text "9inch" }
    59                          	!if REFRESH=82 { !text "8296d-v1" }
    60                          	!if REFRESH=83 { !text "8296d-v2" }
    61                          	!if REFRESH=90 { !text "8296(d)-n.a." }
    62                          	!if REFRESH=91 { !text "8296(d)-n.a." }
    63                          	!if REFRESH=92 { !text "8296(d)-n.a." }
    64                          	!if REFRESH=98 { !text "special" }
    65                          	!if REFRESH=99 { !text "custom" }
    66                          
    67  e867 2046454154555245...!text " FEATURES="
    68  e871 6573632d636f6465...!if ESCCODES=1  { !text "esc-codes" }
    69  e87a 2c6175746f72756e   !if AUTORUN=1   { !text ",autorun" }
    70                          !if BYPASS=1    { !text "+bypass" }
    71  e882 2c62616e6e6572     !if BANNER>0    { !text ",banner" }
    72  e889 2c7765646765       !if WEDGE=1     { !text ",wedge" }
    73                          !if KEYRESET=1  { !text ",keyreset" }
    74                          !if DISKBOOT=1  { !text ",disk boot" }
    75                          !if EXECUDESK=1 { !text ",execudesk" }
    76  e88f 2c6261636b617272...!if BACKARROW>0 { !text ",backarrow" }
    77                          !if SILENT=1    { !text ",silent" }
    78                          !if CRUNCH=1    { !text ",crunch" }
    79                          !if MOT6845=1   { !text ",mot6845" }
    80                          !if DEBUG=1     { !text ",debug" }
    81  e899 2e20434f4d4d454e...!text ". COMMENT="
    82  e8a3 534a472d45444954...+COMMENT
    83                          

; ******** Source: editrom_hi.asm
    22                          			; Filler not visible due to I/O space!
    23  e8ae 2020202020202020...			!IF NOFILL=0 { !FILL $E900-*,$20 }		; pad with SPACES for non-cbm
    24                          		}
    25                          	}
    26                          
    27                          ;=======================================================================
    28                          ; EXTENDED Area
    29                          ;=======================================================================
    30                          ;*=e900
    31                          
    32                          ;=======================================================================
    33                          ; CODEBASE 2 Code
    34                          ;=======================================================================
    35                          ; This code is included only for Codebase 2
    36                          
    37                          	!IF CODEBASE = 2 {!SOURCE "editrom82ext.asm" }
    38                          
    39                          ;=======================================================================
    40                          ; NEW Code
    41                          ;=======================================================================
    42                          ; The EXTended features will go here. This is NEW code that has been added,
    43                          ; or code that must be RELOCATED due to lack of space in the 2K area 
    44                          ; due to restrictions of HARDCODED entrypoints.
    45                          ;
    46                          ; It is very likely that CODEBASE 2 will not have enough space for many of
    47                          ; these additions.
    48                          ;
    49                          ; If OPTROM is greater than 0 then this code will be put in the OPTION ROM space.
    50                          
    51                          	;----- If OPTION ROM then adjust Code assembly address
    52                          	
    53                          	!IF OPTROM=1 { *=$9000 }  				; Assemble to option ROM at $9000
    54                          	!IF OPTROM=2 { *=$A000 }  				; Assemble to option ROM at $A000
    55                          	!IF OPTROM=99 {!SOURCE "io.asm"}			; Special case for development purposes
    56                          
    57                          	;----- These features require AUTORUN
    58                          
    59                          	!IF AUTORUN = 1 {

; ******** Source: editautorun.asm
     1                          ; PET/CBM EDIT ROM - Auto Run
     2                          ; ================
     3                          ;
     4                          ; This module controls auto running tasks after PET has booted. It does this by
     5                          ; stuffing the keyboard buffer with a SYS command. We need to do this because
     6                          ; the editrom code runs before basic and zero-page are initialized.
     7                          ;
     8                          ; The SYS command will automatically be erased.
     9                          ;
    10                          ;-------------- Autostart Dispatch
    11                          ; This should assemble to the $E900,$9000, or $A000 depending on OPTROM setting.
    12                          ; The SYS points to here.
    13                          ; We check options to see what needs to Auto Run.
    14                          
    15                          AUTODISPATCH
    16  e900 200ae9             		JSR ERASE_SYS
    17  e903 204ce9             		!IF BANNER > 0   { JSR SHOW_BANNER   }		; Display Custom Banner Message
    18  e906 207ce9             		!IF WEDGE  > 0   { JSR INSTALL_WEDGE }		; Install DOS Wedge
    19                          		!IF EXECUDESK =2 { JSR EDESKMENU }		; Run Execudesk Menu
    20                          		!IF DISKBOOT > 0 { JSR DOBOOT }			; Do Disk Boot
    21  e909 60                 		RTS
    22                          
    23                          ERASE_SYS
    24  e90a a92c               		LDA #<ERASE_TXT			; pointer to erase text string
    25  e90c a0e9               		LDY #>ERASE_TXT
    26  e90e 201dbb             		JSR STROUTZ			; print it
    27  e911 60                 		RTS
    28                          
    29                          ;-------------- Wedge Prep (1st Step)
    30                          ; We jump to here in the Editor ROM Init code, near the end.
    31                          ; If BYPASS=1 then we check for a key on ROW0 (which is ROW9 in the keyboard table)
    32                          
    33                          AUTOSTART
    34                          
    35                          !IF BYPASS=1 {
    36                          		LDA PIA1_Port_A 		; Keyboard ROW select - PIA#1, Register 0
    37                          						; Upper bits: IEEE and Cassette
    38                          						; Lower bits: Keyboard ROW select
    39                          		AND #$F0			; Mask off lower 4 bits (reset keyboard scan row)
    40                          		STA PIA1_Port_A			; Keyboard ROW select - PIA#1, Register 0				CHIP
    41                          		LDA PIA1_Port_B			; Keyboard COL result							CHIP
    42                          		CMP #$FF			; Are any keys pressed?  (FF=No keys down)
    43                          		BEQ AUTO_GO			; No, so do Auto Run
    44                          
    45                          !IF COLOURPET > 0 {
    46                          						; For ColourPET we can change the colours to indicate no wedge installed
    47                          		LDA #BYPASSFG			; ColourPET Foreground for Wedge Bypass
    48                          		STA COLOURFG
    49                          		LDA #BYPASSBG 			; ColourPET Background for Wedge Bypass
    50                          		STA COLOURBG
    51                          		}
    52                          
    53                          		RTS				; Exit without activating wedge sys
    54                          }
    55                          
    56                          ;-------------- Stuff Keyboard
    57                          AUTO_GO
    58  e912 a209               		LDX #9				; Length of string
    59                          
    60  e914 bd22e9             AUTO_LOOP	LDA AUTO_SYS,X			; Get a key from table
    61  e917 9d6f02             		STA KEYD,X 			; put it in the Keyboard Buffer
    62  e91a ca                 		DEX
    63  e91b 10f7               		BPL AUTO_LOOP			; loop until done
    64                          
    65  e91d a909               		LDA #9				; Length of string
    66  e91f 859e               		STA CharsInBuffer		; Set characters in keyboard buffer 
    67  e921 60                 AUTO_DONE	RTS
    68                          
    69                          ;-------------- TEXT to stuff into keyboard buffer
    70                          
    71                          AUTO_SYS
    72  e922 5359533539363438   		!IF OPTROM=0 {!text "SYS59648"}		; Autostart is located at $E900!
    73                          		!IF OPTROM=1 {!text "SYS36864"}		; Autostart is located at $9000!
    74                          		!IF OPTROM=2 {!text "SYS40960"}		; Autostart is located at $A000!
    75  e92a 0d00               		!byte $0D,0				; <CR> and zero pad byte
    76                          
    77                          ;-------------- TEXT to erase SYS and READY from screen
    78                          
    79                          ERASE_TXT
    80  e92c 91                 		!byte $91			; <UP>
    81  e92d 2020202020202020...		!text "            "		; erase "SYS" message
    82  e939 0d                 		!byte $0D			; <CR>
    83  e93a 2020202020202020...		!text "            "		; erase "READY" message
    84  e946 0d                 		!byte $0D			; <CR>
    85  e947 91919191           		!byte $91,$91,$91,$91		; <UP><UP><UP><UP>
    86  e94b 00                 		!byte 0
    87                          
    88                          ;============================================================================================
    89                          ; DISK AUTOBOOT
    90                          ;============================================================================================
    91                          ; This puts the SHIFT RUN/STOP code into the keyboard buffer and the system
    92                          ; will take care of the rest!
    93                          
    94                          !IF DISKBOOT >0 {
    95                          DOBOOT
    96                          		LDA #$83			; SHIFT RUN/STOP
    97                          		STA KEYD			; First position of Keyboard Input Buffer
    98                          		LDA #1				; One character
    99                          		STA $9E				; Set number of characters in keyboard buffer
   100                          		RTS
   101                          }

; ******** Source: editrom_hi.asm
    60                          

; ******** Source: editbanner.asm
     1                          ; PET/CBM EDIT ROM - Custom Banner
     2                          ; ================
     3                          ;
     4                          ; You can display a custom banner message when the machine is turned on. This could be a simple
     5                          ; welcome message, or a completely new message. By including CLS, HOME or CURSOR characters you
     6                          ; can overwrite the PET's normal power-up banner with anything you like.
     7                          ;
     8                          ; NOTES:
     9                          ; - The default banner "*** COMMODORE BASIC 4.0 ***"  (27 characters wide) is located in the
    10                          ;   BASIC ROM so we cannot change it, but we can clear or overwrite it.
    11                          ; - Be sure to use proper cursoring so that the "READY" prompt is positioned correctly!
    12                          ; - If you clear the screen you will lose the "xxxxx BYTES FREE" message.
    13                          ; - For ColourPET, if you set the initial FG and BG colours to be the same then the PET banner
    14                          ;   will be invisible. Be sure to set the colour before printing your custom message.
    15                          
    16                          ;-------------- Display the Banner
    17                          
    18                          SHOW_BANNER
    19  e94c a954               		lda #<BANNER_TXT		; pointer to BANNER text string
    20  e94e a0e9               		ldy #>BANNER_TXT
    21  e950 201dbb             		jsr STROUTZ			; print it
    22  e953 60                 		rts
    23                          
    24                          ;-------------- Include the Banner text
    25                          
    26                          BANNER_TXT

; ******** Source: banner.asm
     1                          ; PET/CBM EDIT ROM - Custom Banner (Power-on) Messages
     2                          ; ================
     3                          
     4                          ; You can display a custom banner message when the machine is turned on. This could be a simple
     5                          ; welcome message, or a completely new message. By including CLS, HOME or CURSOR characters you
     6                          ; can overwrite the PET's normal power-up banner with anything you like.
     7                          ;
     8                          ; NOTES:
     9                          ; - The default banner "*** COMMODORE BASIC 4.0 ***"  (27 characters wide) is located in the
    10                          ;   BASIC ROM so we cannot change it, but we can clear or overwrite it.
    11                          ; - Be sure to use proper cursoring so that the "READY" prompt is positioned correctly!
    12                          ; - If you clear the screen you will lose the "xxxxx BYTES FREE" message.
    13                          ; - For ColourPET, if you set the initial FG and BG colours to be the same then the PET banner
    14                          ;   will be invisible. Be sure to set the colour before printing your custom message.
    15                          ;
    16                          ; Currently the following are available:
    17                          ;
    18                          ; ##  MODEL  MODE   TYPE MESSAGE / DESCRIPTION                   40                                      80
    19                          ; --  -----  ----   ---- "---------!---------!---------!---------!---------!---------!---------!---------!"
    20                          ;  1  CPET   GRAPH  OVER "COMMODORE COLOURPET"
    21                          ;  2  CPET   TEXT   OVER "ColourPET BASIC4 + Wedge"
    22                          ;  3  80COL  TEXT   OVER "Commodore EDITROM Project - Wedge/ESC/SS40"
    23                          ;  4  ANY    GRAPH  OVER "CBM BASIC 4 WITH WEDGE"
    24                          ;  5  CPET   GRAPH  FULL C65-like screen with colour bars
    25                          ;  6  80COL  ANY    OVER "*** commodore basic 4.0 with wedge/esc/ss40"
    26                          ;  7  80COL  ANY    OVER "*** commodore basic 4.0 with wedge,esc,reboot,40/80 switcher"
    27                          ;  8  8296   ANY    OVER "*** commodore 8296 basic 4.0 with wedge,esc,reboot,80x35 screen"
    28                          ;  9  8296   ANY    OVER "*** commodore 8296 basic 4.0 with wedge,esc,reboot,extended screen"
    29                          ; 10  80COL  ANY    OVER "*** commodore basic 4.0 with wedge,esc,reboot,ss40, execudesk"
    30                          ; 11  80COL  ANY    OVER "*** commodore basic 4.0 with enhanced editor and wedge"
    31                          ; 12  40COL  ANY    OVER "*** cbm basic 4 plus editor+wedge ***"
    32                          ; 13  8296D  ANY    OVER "*** commodore 8296 basic 4.0 with wedge,reboot, backarrow ***"
    33                          ; 14  8296D  ANY    OVER "*** commodore 8296 basic 4.0 with custom editor rom ***"
    34                          ; 15  8296D  ANY    OVER "*** commodore 8296d basic 4.0 with custom editor rom ***"
    35                          ; 16  80COL  ANY    OVER "*** commodore basic 4.0 with custom editor rom ***"
    36                          ; 17  40COL  ANY    OVER "*** cbm basic 4 custom editrom ***"
    37                          ; 18  40COL  ANY    OVER "*** commodore basic 4.0 *** hard40/80,n"
    38                          ; 19  40COL  ANY    OVER "*** commodore basic 4.0 *** disk boot"
    39                          ; 20  40COL  ANY    OVER "*** commodore basic 4.0 *** sjg-edit"
    40                          ; 21  80COL  ANY    OVER "*** commodore basic 4.0 *** + wedge/esc/backarrow/ss40"
    41                          ; 22  80COL  ANY    OVER "*** commodore basic 4.0 *** + wedge,esc,backarrow,hs40/80"
    42                          ; 98  ANY    ANY    ADD  Show DATE and COMMENT for debug purposes
    43                          ; 99  CUSTOM ...    ...  Your own banner text
    44                          ;
    45                          ; TYPE: FULL = Replaces all, OVER = Overwrites part, ADD = Adds additional text
    46                          ;
    47                          ;-----------------------------------------------
    48                          ; CUSTOM BANNER
    49                          ;-----------------------------------------------
    50                          !IF BANNER=99 {
    51                          		!byte $13
    52                          ;Screen columns:      44444444444444444444444444v44444444444448888888888888888888888888888888888888888
    53                          		!pet "*** commodore basic 4.0 *** hard40/80,n",$0D
    54                          		!pet "waltermixx edition!"
    55                          		!byte $0D      			; <CR><CR><CR>
    56                          }
    57                          
    58                          ;-----------------------------------------------
    59                          ; DEBUG BANNER
    60                          ;-----------------------------------------------
    61                          
    62                          !IF BANNER=98 {	!pet "date: "
    63                          		+DATE
    64                          		!byte $0D
    65                          		!pet "comment: "
    66                          		+COMMENT
    67                          		!byte $0D				
    68                          }
    69                          
    70                          !IF BANNER=22 {	!byte $13
    71                          		!pet "*** commodore basic 4.0 *** + wedge,esc,backarrow,hs40/80"
    72                          		!byte $0D,$0D,$0D      		; <CR><CR><CR>
    73                          }
    74                          
    75                          !IF BANNER=21 {	!byte $13
    76                          		!pet "*** commodore basic 4.0 *** + wedge/esc/backarrow/ss40"
    77                          		!byte $0D,$0D,$0D      		; <CR><CR><CR>
    78                          }
    79                          
    80                          
    81                          !IF BANNER=20 {	!byte $13
    82                          		!pet "*** commodore basic 4.0 *** sjg-edit"
    83                          		!byte $0D,$0D,$0D      		; <CR><CR><CR>
    84                          }
    85                          
    86                          !IF BANNER=19 {	!byte $13
    87                          		!pet "*** commodore basic 4.0 *** disk boot"
    88                          		!byte $0D,$0D,$0D      		; <CR><CR><CR>
    89                          }
    90                          
    91                          !IF BANNER=18 {	!byte $13
    92                          		!pet "*** commodore basic 4.0 *** hard40/80,n"
    93                          		!byte $0D,$0D,$0D      		; <CR><CR><CR>
    94                          }
    95                          
    96                          !if BANNER=17 { !byte $13            		; <HOME> 
    97                                   	!pet "*** cbm basic 4 with custom editrom ***"
    98                                   	!byte $0D,$0D,$0D      		; <CR><CR><CR>
    99                          }
   100                          
   101                          !if BANNER=16 { !byte $13            		; <HOME> 
   102                                   	!pet "*** commodore basic 4.0 with custom editor rom ***"
   103                                   	!byte $0D,$0D,$0D      		; <CR><CR><CR>
   104                          }
   105                          
   106                          !if BANNER=15 { !byte $13            		; <HOME> 
   107                                   	!pet "*** commodore 8296d basic 4.0 with custom editor rom ***"
   108                                   	!byte $0D,$0D,$0D      		; <CR><CR><CR>
   109                          }
   110                          
   111                          !if BANNER=14 { !byte $13            		; <HOME> 
   112                                   	!pet "*** commodore 8296 basic 4.0 with custom editor rom ***"
   113                                   	!byte $0D,$0D,$0D      		; <CR><CR><CR>
   114                          }
   115                          
   116                          !if BANNER=13 { !byte $13            		; <HOME> 
   117                                   	!pet "*** commodore 8296d basic 4.0 with wedge,reboot,din ***"
   118                                   	!byte $0D,$0D,$0D      		; <CR><CR><CR>
   119                          }
   120                          
   121                          !if BANNER=12 {	!byte $13            		; <HOME> 
   122                                   	!pet "*** cbm basic 4 plus editor+wedge ***"
   123                                   	!byte $0D,$0D,$0D      		; <CR><CR><CR>
   124                          }
   125                          
   126                          !if BANNER=11 {	!byte $13            		; <HOME> 
   127                                   	!pet "*** commodore basic 4.0 with enhanced editor and wedge ***"
   128                                   	!byte $0D,$0D,$0D      		; <CR><CR><CR>
   129                          }
   130                          
   131                          !if BANNER=10 {	!byte $13            		; <HOME> 
   132                                   	!pet "*** commodore basic 4.0 with wedge,esc,reboot,ss40, execudesk ***"
   133                                   	!byte $0D,$0D,$0D      		; <CR><CR><CR>
   134                          }
   135                          
   136                          !if BANNER=9 {	!byte $13            		; <HOME> 
   137                                   	!pet "*** commodore 8296 basic 4.0 with wedge,esc,reboot,extended screen ***"
   138                                   	!byte $0D,$0D,$0D      		; <CR><CR><CR>
   139                          }
   140                          
   141                          !if BANNER=8 {	!byte $13            		; <HOME> 
   142                                   	!pet "*** commodore 8296 basic 4.0 with wedge,esc,reboot,80x35 screen ***"
   143                                   	!byte $0D,$0D,$0D      		; <CR><CR><CR>
   144                          }
   145                          
   146                          !if BANNER=7 {	!byte $13            		; <HOME> 
   147                                   	!pet "*** commodore basic 4.0 with wedge,esc,reboot,40/80 switcher ***"
   148                                   	!byte $0D,$0D,$0D      		; <CR><CR><CR>
   149                          }
   150                          
   151                          !if BANNER=6 {	!byte $13            		; <HOME> 
   152                                   	!pet "*** commodore basic 4.0 with wedge/esc/ss40 ***"
   153                                   	!byte $0D,$0D,$0D      		; <CR><CR><CR>
   154                          }
   155                          
   156                          ;-----------------------------------------------
   157                          ; Custom ColourPET-40 C65-like startup screen with colour bars
   158                          ; TIP: Set foreground and background colour to <BLUE> to hide initial banner message
   159                          ;-----------------------------------------------
   160                          !IF BANNER=5 {
   161                          		!byte $5,$1F,$93,142		; <WHT><BLUE><CLS><GRAPHICS>
   162                          		
   163                          		;-- line 1		
   164                          		!byte $1C,$12			;<RED><RVS>
   165                          		!pet "         "		; bar
   166                          		!byte $92,$E9,$5		; <OFF><diag block><WHT>
   167                          
   168                          !IF UPET=1 {
   169                          		!pet "  the ultra-pet prototype"
   170                          } ELSE {
   171                          		!pet "  the commodore colourpet"
   172                          }
   173                          
   174                          		!byte $0D			; <CR>
   175                          
   176                          		;-- line 2
   177                          		!byte $96,$12			; <LT RED><RVS>
   178                          		!pet "       "			; bar
   179                          		!byte $92,$E9,$0D		; <OFF><diag block><CR>
   180                          
   181                          		;-- line 3
   182                          		!byte $9E,$12			; <YEL><RVS>
   183                          		!pet "     "                    ; bar
   184                          		!byte $92,$E9,$5		; <OFF><diag block><WHT>
   185                          
   186                          !IF UPET=1 {
   187                          		!pet "      by andre fachat"
   188                          } ELSE {
   189                          		!pet "      (c) steve j. gray"
   190                          }
   191                          
   192                          		!byte $0D			; <CR>
   193                          
   194                          		;-- line 4
   195                          		!byte $99,$12			; <LT GRN><RVS>
   196                          		!pet "   "			; bar
   197                          		!byte $92,$E9,$5		; <OFF><diag block><WHT>
   198                          		!pet "        basic 4.0  31743 bytes free"
   199                          		!byte $0D
   200                          
   201                          		;-- line 5,6
   202                          		!byte $0D
   203                          		!pet "mod keyboard and wedge"
   204                          		!byte $0D				
   205                          }
   206                          
   207                          ;-----------------------------------------------
   208                          ; Custom 4032 - For GRAPHICS MODE startup screen
   209                          ;-----------------------------------------------
   210                          
   211                          !if BANNER=4 {	!byte $13            		; <HOME> 
   212                                   	!pet "*** CBM BASIC 4 WITH WEDGE ***"
   213                                   	!byte $0D,$0D,$0D      		; <CR><CR><CR>
   214                          }
   215                          
   216                          ;-----------------------------------------------
   217                          ; Custom 8032 - For TEXT MODE startup screen
   218                          ;-----------------------------------------------
   219                          
   220                          !if BANNER=3 {	!byte $13            		; <HOME> 
   221                                   	!pet "*** Commodore EDITROM Project - Wedge/ESC/SS40 ***"
   222                                   	!byte $0D,$0D,$0D      		; <CR><CR><CR>
   223                          }
   224                          
   225                          ;-----------------------------------------------
   226                          ; Custom ColourPET message courtesy Christian Dirks - For GRAPHICS MODE startup screen
   227                          ;-----------------------------------------------
   228                          
   229                          !if BANNER=2 {	!byte $13,$99          		; <HOME><GRN>
   230                                   	!pet "*** "
   231                                   	!byte $1c            		; <RED>
   232                                   	!pet "co"
   233                                   	!byte $99            		; <GRN>
   234                                   	!pet "lo"
   235                                   	!byte $9a            		; <BLU>
   236                                   	!pet "ur"
   237                                   	!byte $9e            		; <YEL>
   238                                   	!pet "pet"
   239                                   	!byte $99            		; <GRN>
   240                                   	!pet " basic 4.0 + wedge ***"   ; message
   241                                   	!byte $0D,$0D,$0D      		; <CR><CR><CR>
   242                          }
   243                          
   244                          ;-----------------------------------------------
   245                          ; Custom ColourPET message for TEXT MODE startup screen
   246                          ;-----------------------------------------------
   247                          
   248  e954 9305               !if BANNER=1 {	!byte $93,$5			; <CLS><WHT>
   249  e956 2a2a2a20           		!pet "*** "
   250  e95a 9f                 		!byte $9f			; <LTCYN>
   251  e95b c34f4d4d4f444f52...		!pet "Commodore "
   252  e965 1c                 		!byte $1c			; <RED>
   253  e966 c34f               		!pet "Co"
   254  e968 99                 		!byte $99			; <GRN>
   255  e969 4c4f               		!pet "lo"
   256  e96b 9a                 		!byte $9a			; <BLU>
   257  e96c 5552               		!pet "ur"
   258  e96e 9e                 		!byte $9e			; <YEL>
   259  e96f d0c5d4             		!pet "PET"
   260  e972 05                 		!byte $05			; <WHT>
   261  e973 202a2a2a           		!pet " ***"
   262  e977 0b0b               		!byte 11,11
   263  e979 0d                 		!byte $0D			; <cr>
   264                          }
   265                          
   266                          ;-----------------------------------------------
   267                          ; Unspecified values
   268                          ;-----------------------------------------------
   269                          
   270  e97a 0000               		!byte 0,0			; Zeros must end string.

; ******** Source: editbanner.asm
    27                          
    28                          
    29                          

; ******** Source: editrom_hi.asm
    61                          }

; ******** Source: editwedge.asm
     1                          ; PET/CBM EDIT ROM - Wedge
     2                          ; ================
     3                          ;
     4                          ; Based on Commodore's universal wedge taken from 8050's test/demo disk
     5                          ; but rewritten and enhanced by Nils Eilers
     6                          ;
     7                          ; Adapted for EDIT-ROM and ACME assembler by Steve Gray.
     8                          ;
     9                          ; NOTE: The reason we have to stuff the keyboard buffer to activate the wedge is because
    10                          ;       the editrom code runs before basic and zero-page are initialized.
    11                          ;
    12                          ;----------------------------------------------------------------------------------------
    13                          ; Wedge commands are only available in direct mode. 
    14                          ;
    15                          ; #<unit number> 	- sets the default drive. Without unit number shows the current default drive.
    16                          ; @$[[drive]:filename] 	- displays the disk's directory. SPACE=Pause, any other key to continue. STOP=Abort.
    17                          ;				@$ displays the entire directory.
    18                          ;				@$1: displays the directory of default's device drive 1 only. Do not confuse drive and device.
    19                          ;				@$:N* displays all files having a "N" as the first letter in their filename.
    20                          ; /filename		- Loads a program.
    21                          ; ^filename		- Loads and runs a file ("^" is up arrow, NOT "carat")
    22                          ; @			- Read disk status. Without any parameters reads and displays the disk drive error message channel.
    23                          ; @<string>		- Sends <string> to the device's command channel. 
    24                          ;				@C:newfile=existingfile	- Copy a file on the same diskette
    25                          ;				@I 			- Initialize the disk drive.
    26                          ;				@N:diskname		- New a disk that was already formatted
    27                          ;				@N:diskname,id		- Format a diskette, giving it an index at your choice
    28                          ;				@R:newname=oldname	- Rename a file
    29                          ;				@S:file1[,file2 ...]	- Scratch file(s). Wild cards allowed. Status channel returns # of files scratched.
    30                          ;				@UJ			- Reset drive. Status channel will return the DOS version string.
    31                          ;				@V			- Validate disk
    32                          ;				@D1=0			- Duplicate disk (dual drive units only). Target drive first, then source.
    33                          ;------------------------------------------------------------------------------------------------------------------------------------------
    34                          
    35                          
    36                          ;-------------- INSTALL WEDGE
    37                          ; This patches the CHRGET routine in Zero Page to point to the WEDGE interpreter
    38                          
    39                          INSTALL_WEDGE
    40  e97c a98d               		lda #<resident_wedge		; patch CHRGET JMP address
    41  e97e 8571               		sta CHRGET+1 			; to jump into wedge
    42  e980 a9e9               		lda #>resident_wedge
    43  e982 8572               		sta CHRGET+2
    44  e984 a94c               		lda #$4c			; insert JMP command in CHRGET routine
    45  e986 8570               		sta CHRGET
    46                          
    47  e988 a908               		lda #8				; init default device
    48  e98a 8573               		sta CHRGETX			; $73=unused byte in CHRGET
    49                          
    50                          !if WEDGEMSG=1 {
    51                          		lda #<WEDGESTRING		; write "wedge installed"
    52                          		ldy #>WEDGESTRING
    53                          		jsr STROUTZ
    54                          }	
    55  e98c 60                 		rts				; exit to BASIC
    56                          
    57                          ;-------------- MESSAGE
    58                          WEDGESTRING
    59                          !if WEDGEMSG=1 {
    60                          		!pet "wedge installed"		; message
    61                          		!byte 0				; extra 0 padding
    62                          }
    63                          
    64                          ;-------------- Resident part of the universal DOS wedge
    65                          ; When installed, the CHRGET routine points here.
    66                          
    67                          resident_wedge
    68                          		wedge_unit = CHRGETX		; default device, unused byte in CHRGET
    69                          		wedge_char = SAVELA		; $B3 -0 if @># else load/run char / ^
    70                          
    71  e98d e677               		inc TXTPTR			; increment text pointer 
    72  e98f d002               		bne MAIN2
    73  e991 e678               		inc TXTPTR + 1
    74                          MAIN2 
    75                          
    76                          ; if MAINS is stacked, CHRGET is called from direct mode. abort if not called from there
    77                          
    78  e993 86b3               		stx wedge_char			; save X
    79  e995 ba                 		tsx 
    80  e996 bd0101             		lda STACK+1,x
    81  e999 c90f               		cmp #<MAINS
    82  e99b d037               		bne restabort
    83  e99d bd0201             		lda STACK+2,x
    84  e9a0 c9b4               		cmp #>MAINS
    85  e9a2 d030               		bne restabort			; abort if textpointer doesn't point to $0200
    86                          
    87  e9a4 a577               		lda TXTPTR
    88  e9a6 d02e               		bne abort
    89  e9a8 a578               		lda TXTPTR + 1
    90  e9aa c902               		cmp #2
    91  e9ac d028               		bne abort
    92                          
    93  e9ae a000               		ldy #0				; NUL when @>#
    94  e9b0 84b3               		sty wedge_char			; else load/run character /^
    95                          
    96  e9b2 b177               testchar	lda (TXTPTR),y
    97  e9b4 c920               		cmp #32				; skip leading spaces
    98  e9b6 d004               		bne nospace
    99  e9b8 e677               		inc TXTPTR
   100  e9ba d0f6               		bne testchar
   101                          
   102  e9bc c93e               nospace		cmp #$3e			; '>'
   103  e9be f019               		beq command_or_status
   104  e9c0 c940               		cmp #$40			; '@'
   105  e9c2 f015               		beq command_or_status
   106  e9c4 c923               		cmp #$23			; '#'
   107  e9c6 f01c               		beq default_device
   108  e9c8 85b3               		sta wedge_char			; save load/run character
   109  e9ca c92f               		cmp #$2f			; '/'
   110  e9cc f057               		beq to_prepare_fn
   111  e9ce c95e               		cmp #$5e			; '^'
   112  e9d0 f053               		beq to_prepare_fn
   113  e9d2 d002               		bne abort
   114                          
   115  e9d4 a6b3               restabort	ldx wedge_char			; restore X
   116  e9d6 4c7600             abort		jmp CHRGOT
   117                          
   118                          ;-------------- COMMAND OR STATUS
   119                          
   120                          command_or_status
   121  e9d9 c8                 		iny 
   122  e9da b177               		lda (TXTPTR),y
   123  e9dc f049               		beq get_status
   124  e9de c924               		cmp #'$'			; '$'
   125  e9e0 f06b               		beq prepare_fn
   126  e9e2 d01d               		bne send_cmd
   127                          
   128                          ;-------------- SET DEVICE
   129                          
   130                          default_device
   131  e9e4 e677               		inc TXTPTR
   132  e9e6 b177               		lda (TXTPTR),y			; Y is still 0
   133  e9e8 d00c               		bne set_device			; parameter given -> set device number
   134                          
   135  e9ea a673               		ldx wedge_unit			; show current device number
   136  e9ec 98                 		tya
   137  e9ed 2083cf             		jsr INTOUT
   138  e9f0 2034d5             		jsr CRLF
   139  e9f3 4cffb3             		jmp READY
   140                          
   141                          set_device
   142                          		; prerequsites for RDINT: 
   143                          		; - TXTPTR $77/$78 point to first char
   144                          		; - A contains that first char
   145                          		; - Carry is cleared
   146                          
   147  e9f6 18                 		clc
   148  e9f7 20f6b8             		jsr RDINT			; convert string to unsigned int
   149  e9fa a511               		lda LINNUM			; LSB of converted number
   150  e9fc 8573               		sta wedge_unit
   151  e9fe 4cffb3             		jmp READY
   152                          	
   153                          ;-------------- SEND COMMAND
   154                          
   155  ea01 a573               send_cmd	lda wedge_unit
   156  ea03 85d4               		sta FA
   157  ea05 a96f               		lda #$6f			; DATA SA 15
   158  ea07 85d3               		sta SA
   159  ea09 20d5f0             		jsr LISTN			; LISTEN 
   160  ea0c a5d3               		lda SA
   161  ea0e 2043f1             		jsr SECND			; send secondary address
   162                          
   163  ea11 e677               SENDCMD2	inc TXTPTR
   164  ea13 a000               		ldy #0			
   165  ea15 b177               		lda (TXTPTR),y
   166  ea17 f006               		beq SENDCMDDONE	
   167  ea19 209ef1             		jsr CIOUT			; send char to IEEE
   168  ea1c b8                 		clv 
   169  ea1d 50f2               		bvc SENDCMD2			; branch always
   170                          
   171  ea1f 20b9f1             SENDCMDDONE	jsr UNLSN
   172  ea22 18                 		clc
   173  ea23 9002               		bcc get_status
   174                          
   175                          ;-------------- Relative Branch forwarder
   176                          
   177  ea25 f026               to_prepare_fn:	beq prepare_fn		
   178                          
   179                          ;-------------- GET STATUS
   180                          
   181  ea27 8477               get_status	sty TXTPTR
   182  ea29 a573               		lda wedge_unit
   183  ea2b 85d4               		sta FA
   184  ea2d 20d2f0             		jsr TALK			; TALK
   185  ea30 a96f               		lda #$6f			; DATA SA 15
   186  ea32 85d3               		sta SA
   187  ea34 2043f1             		jsr SECND			; send secondary address
   188                          
   189  ea37 20c0f1             GS_NEXTCHAR	jsr ACPTR			; read byte from IEEE bus
   190  ea3a c90d               		cmp #$0D			; last byte = CR?		
   191  ea3c f006               		beq GS_DONE
   192  ea3e 2002e2             		jsr SCROUT			; write char to screen
   193  ea41 b8                 		clv 
   194  ea42 50f3               		bvc GS_NEXTCHAR			; branch always
   195                          
   196  ea44 2002e2             GS_DONE		jsr SCROUT			; write char to screen
   197  ea47 20aef1             		jsr UNTLK			; UNTALK
   198  ea4a 4cffb3             		jmp READY
   199                          
   200                          ;------------------------------------------------------------------------------
   201                          ; identify filename to load/run, includes quote handling
   202                          
   203                          prepare_fn
   204  ea4d c8                 		iny				; count filename length
   205  ea4e b177               		lda (TXTPTR),y
   206  ea50 f01a               		beq end_name
   207  ea52 c922               		cmp #'"'			; quote character
   208  ea54 d0f7               		bne prepare_fn
   209                          
   210  ea56 a5b3               handle_quote	lda wedge_char
   211  ea58 3012               		bmi end_name
   212  ea5a 0980               		ora #$80
   213  ea5c 85b3               		sta wedge_char 
   214  ea5e 98                 		tya
   215  ea5f a000               		ldy #0
   216  ea61 18                 		clc
   217  ea62 6577               		adc TXTPTR
   218  ea64 8577               		sta TXTPTR
   219  ea66 90e5               		bcc prepare_fn
   220  ea68 e678               		inc TXTPTR+1
   221  ea6a d0e1               		bne prepare_fn
   222                          
   223  ea6c 88                 end_name	dey 
   224  ea6d 84d1               		sty FNLEN			; store length
   225  ea6f a677               		ldx TXTPTR
   226  ea71 e8                 		inx
   227  ea72 86da               		stx FNADR
   228  ea74 a578               		lda TXTPTR + 1
   229  ea76 85db               		sta FNADR + 1
   230  ea78 a573               		lda wedge_unit
   231  ea7a 85d4               		sta FA
   232  ea7c a5b3               		lda wedge_char			; load/run?
   233  ea7e 297f               		and #$7f
   234  ea80 85b3               		sta wedge_char
   235  ea82 d039               		bne to_loadrun			; yes
   236                          
   237                          ;-------------- DIRECTORY
   238                          
   239  ea84 a900               		lda #0				; Clear the status flag
   240  ea86 8596               		sta STATUS
   241  ea88 a960               		lda #$60			; DATA SA 0
   242  ea8a 85d3               		sta SA
   243  ea8c 20a5f4             		jsr OPENI			; open file
   244  ea8f 20d2f0             		jsr TALK
   245  ea92 a5d3               		lda SA
   246  ea94 2043f1             		jsr SECND
   247                          
   248  ea97 a003               		ldy #3
   249                          list_blocks
   250  ea99 84d1               		sty FNLEN
   251  ea9b 20c0f1             		jsr ACPTR			; read byte from IEEE
   252  ea9e 85fd               		sta MEMUSS			; store blocks LSB
   253  eaa0 a496               		ldy STATUS			; check the status. is it non-zero?
   254  eaa2 d01b               		bne to_stoplisting		; yes
   255  eaa4 20c0f1             		jsr ACPTR
   256  eaa7 85fe               		sta MEMUSS + 1			; store blocks MSB
   257  eaa9 a496               		ldy STATUS
   258  eaab d012               		bne to_stoplisting
   259  eaad a4d1               		ldy FNLEN
   260  eaaf 88                 		dey 
   261  eab0 d0e7               		bne list_blocks
   262  eab2 a6fd               		ldx MEMUSS
   263  eab4 a5fe               		lda MEMUSS + 1
   264  eab6 2083cf             		jsr INTOUT			; write #blocks to screen
   265  eab9 a920               		lda #' '
   266  eabb d006               		bne listing			; branch always
   267                          
   268                          ;-------------- Relative Branch forwarder
   269                          
   270  eabd d03b               to_loadrun:	bne loadrun
   271  eabf d031               to_stoplisting:	bne stoplisting
   272  eac1 d0d6               to_list_blocks:	bne list_blocks
   273                          
   274                          
   275                          ;-------------- Continuation of DIRECTORY
   276                          
   277                          listing
   278  eac3 2002e2             		jsr SCROUT
   279  eac6 20c0f1             LISTLOOP	jsr ACPTR			; read byte from IEEE
   280  eac9 a696               		ldx STATUS			; was it successful?
   281  eacb d025               		bne stoplisting			; no, so exit
   282  eacd c900               		cmp #0				; Is it end of line
   283  eacf f018               		beq newline			; yes, jump ahead
   284  ead1 2002e2             		jsr SCROUT			; write filename and type
   285  ead4 2035f3             		jsr STOPEQ			; Was STOP key pressed?
   286  ead7 f019               		beq stoplisting			; Yes, we're done. Jump out
   287  ead9 20e4ff             		jsr GETIN			; pause listing with SPACE key
   288  eadc f0e8               		beq LISTLOOP			; no key pressed -> continue
   289  eade c920               		cmp #32				; <space>?
   290  eae0 d0e4               		bne LISTLOOP			; No, go back for more
   291                          
   292  eae2 20e4ff             listwait	jsr GETIN			; get a key
   293  eae5 f0fb               		beq listwait			; 0=no key, so keep waiting
   294                          
   295  eae7 d0dd               		bne LISTLOOP			; then continue
   296                          
   297                          ;-------------- end of directory entry
   298                          
   299  eae9 a90d               newline		lda #$0D			; <CR>
   300  eaeb 2002e2             		jsr SCROUT			; print it
   301  eaee a002               		ldy #2
   302  eaf0 d0cf               		bne to_list_blocks
   303                          
   304                          ;-------------- listing is done - end or stop key pressed
   305                          
   306  eaf2 202ff7             stoplisting	jsr CLSEI			; close file with $E0, unlisten
   307                          
   308  eaf5 68                 		pla 
   309  eaf6 68                 		pla 
   310  eaf7 4cffb3             		jmp READY			; BASIC warm start
   311                          
   312                          ;-------------- LOAD / RUN
   313                          
   314                          loadrun
   315  eafa a900               		lda #0				; Clear status byte
   316  eafc 8596               		sta STATUS
   317  eafe 859d               		sta VERCK			; LOAD=0, VERIFY=1
   318  eb00 2056f3             		jsr LOADOP			; LOAD without pointer change
   319                          
   320  eb03 a596               		lda STATUS			; Did it load?
   321  eb05 2910               		and #$10
   322  eb07 d020               		bne loaderr			; No, exit out
   323                          
   324  eb09 a5ca               		lda EAL+1			; end of program MSB
   325  eb0b 852b               		sta VARTAB+1			; start of basic variables MSB
   326  eb0d a5c9               		lda EAL				; end of program LSB
   327  eb0f 852a               		sta VARTAB			; start of basic variables LSB
   328                          
   329  eb11 2034d5             		jsr CRLF
   330  eb14 20e9b5             		jsr RSTXCLR			; reset TXTPTR and perform CLR
   331  eb17 20b6b4             		jsr LINKPRG			; rebuild chaining of BASIC lines
   332                          
   333  eb1a a5b3               		lda wedge_char
   334  eb1c c92f               		cmp #$2f			; if '/' then load only, omit RUN
   335  eb1e d003               		bne startprg			; '^' --> RUN
   336  eb20 4cffb3             		jmp READY			; load only, exit with BASIC warm start
   337                          
   338  eb23 2022b6             startprg	jsr STXTPT			; reset TXTPTR
   339  eb26 4c4ab7             		jmp NEWSTT			; RUN
   340                          
   341  eb29 4c25f4             loaderr		jmp FILENOTFOUND		; FILE NOT FOUND, return to basic
   342                          

; ******** Source: editrom_hi.asm
    62                          }		
    63                          	}
    64                          
    65                          	;----- These features require ESC codes
    66                          
    67                          	!IF ESCCODES = 1 {

; ******** Source: editescape.asm
     1                          ; PET/CBM EDIT ROM - Code to check for ESC Sequence
     2                          ; ================
     3                          ; Goal is to support as many C128/CBM-II ESC codes as possible
     4                          ;
     5                          
     6                          ;-------------- Check for ESC as LAST character
     7                          ;
     8                          ; NOTE: We JMP here from EDITROMxx.ASM. Accumulator holds code of CURRENT character
     9                          ;       If we want to continue processing as normal we need to JMP ESC_DONE.
    10                          ;       If we need to modify the action we set DATAX with the new character.
    11                          ;       If we want to skip the rest of the character processing we should JMP IRQ_EPILOG .
    12                          
    13  eb2c a6f1               CheckESC	LDX LASTCHAR 		; Previous character printed
    14  eb2e e01b               		CPX #$1B		; <ESC>?
    15  eb30 f00c               		BEQ ESC_YES		; Yes, process it
    16  eb32 c91b               		CMP #$1B		; Is current Chr ESC?
    17  eb34 f003               		BEQ ESC_NOW		; Yes, 
    18  eb36 4c19e2             		JMP ESC_DONE		; No, back to normal checking
    19                          
    20                          ;-------------- ESC is current Chr
    21                          
    22  eb39 85f1               ESC_NOW		STA LASTCHAR		; Remember it
    23  eb3b 4c99e1             		JMP IRQ_EPILOG		; don't process anything
    24                          
    25                          ;-------------- Process ESC sequence
    26                          
    27  eb3e c91b               ESC_YES		CMP #$1b		; Is current char <ESC>?
    28  eb40 f002               		BEQ DoESCESC		; Yes, Do <ESC><ESC>
    29  eb42 d005               		BNE DoEscapeCode	; No,  Do <ESC>+KEY
    30                          
    31                          ;-------------- Do <ESC><ESC>
    32                          
    33  eb44 a900               DoESCESC	LDA #0			; Clear character
    34  eb46 4cbbe3             		JMP ESCAPE_O		; <ESC>+O (escape)
    35                          
    36                          ;-------------- Do <ESC>+KEY Sequence
    37                          
    38  eb49 297f               DoEscapeCode	AND #$7F		; Strip top bit
    39  eb4b 38                 		SEC
    40                          !IF (COLOURPET=1) OR (VIDSWITCH=1) {
    41                          		SBC #$30		; Subtract 30 (Start at "0")
    42                          		CMP #$2F		; Make sure it is in range!
    43                          } ELSE {
    44  eb4c e940               		SBC #$40		; Subtract 40 (Start at "@")
    45  eb4e c920               		CMP #$20		; Make sure it is in range!
    46                          }
    47  eb50 b00f               		BCS DoESCDONE		; Yes, skip
    48                          
    49  eb52 a200               		LDX #0
    50  eb54 86f1               		STX LASTCHAR		; Clear Last Char
    51                          
    52  eb56 0a                 		ASL
    53  eb57 aa                 		TAX
    54  eb58 bd65eb             		LDA ESCVECTORS+1,X	; ESC Sequence Vectors
    55  eb5b 48                 		PHA
    56  eb5c bd64eb             		LDA ESCVECTORS,X	; ESC Sequence Vectors
    57  eb5f 48                 		PHA			; Push address to stack so RTS will jump to selected routine
    58                          ;		LDA #0			; Clear Character
    59  eb60 60                 		RTS
    60                          
    61  eb61 4c19e2             DoESCDONE	JMP ESC_DONE
    62                          
    63                          ;-------------- Esc Sequence Vectors    (*=changed from C128)
    64                          
    65                          ESCVECTORS
    66                          
    67                          ;--------------- COLOURPET ESC Codes: ESC 0 to 9 plus :;<=>?
    68                          ;                Set Colour to specified value (0 to 15).
    69                          ;
    70                          !IF (COLOURPET=1) OR (VIDSWITCH=1) {
    71                            !IF (COLOURPET=1) {
    72                          		!WORD ESCAPE_NUM-1	; Esc-0 Set Colour to Black
    73                          		!WORD ESCAPE_NUM-1	; Esc-1 Set Colour to Medium Grey
    74                          		!WORD ESCAPE_NUM-1	; Esc-2 Set Colour to Blue
    75                          		!WORD ESCAPE_NUM-1	; Esc-3 Set Colour to Light Blue
    76                          		!WORD ESCAPE_NUM-1	; Esc-4 Set Colour to Green
    77                          		!WORD ESCAPE_NUM-1	; Esc-5 Set Colour to Light Green
    78                          		!WORD ESCAPE_NUM-1	; Esc-6 Set Colour to Dark Cyan
    79                          		!WORD ESCAPE_NUM-1	; Esc-7 Set Colour to Light Cyan
    80                          		!WORD ESCAPE_NUM-1	; Esc-8 Set Colour to Red
    81                          		!WORD ESCAPE_NUM-1	; Esc-9 Set Colour to Light Red
    82                          		!WORD ESCAPE_NUM-1	; Esc-: Set Colour to Dark Purple
    83                          		!WORD ESCAPE_NUM-1	; Esc-; Set Colour to Purple
    84                          		!WORD ESCAPE_NUM-1	; Esc-< Set Colour to Dark Yellow
    85                          		!WORD ESCAPE_NUM-1	; Esc-= Set Colour to Yellow
    86                          		!WORD ESCAPE_NUM-1	; Esc-> Set Colour to Light Grey
    87                          		!WORD ESCAPE_NUM-1	; Esc-? Set Colour to White
    88                          } ELSE {
    89                          
    90                          ;--------------- VIDSWITCH ESC Codes: ESC 0 to 9
    91                          ;                Sets a specific video mode immediately (and temporarily)
    92                          ;                For manually setting the video mode, when testing different
    93                          ;                monitors and/or NTSC/PAL composite adapters.
    94                          ;                COLOURPET and VIDSWITCH cannot be combined!
    95                          ;
    96                          		!WORD ESCAPE_SETVID-1	; Esc-0 Set to Video MODE 0
    97                          		!WORD ESCAPE_VID-1	; Esc-1 Set to Video MODE 1
    98                          		!WORD ESCAPE_VID-1	; Esc-2 Set to Video MODE 2
    99                          		!WORD ESCAPE_VID-1	; Esc-3 Set to Video MODE 3
   100                          		!WORD ESCAPE_VID-1	; Esc-4 Set to Video MODE 4
   101                          		!WORD ESCAPE_VID-1	; Esc-5 Set to Video MODE 5
   102                          		!WORD ESCAPE_VID-1	; Esc-6 Set to Video MODE 6
   103                          		!WORD ESCAPE_VID-1	; Esc-7 Set to Video MODE 7
   104                          		!WORD ESCAPE_VID-1	; Esc-8 Set to Video MODE 8
   105                          		!WORD ESCAPE_VID-1	; Esc-9 Set to Video MODE 9
   106                          		!WORD NOESCAPE-1	; NONE
   107                          		!WORD NOESCAPE-1	; NONE
   108                          		!WORD NOESCAPE-1	; NONE
   109                          		!WORD NOESCAPE-1	; NONE
   110                          		!WORD NOESCAPE-1	; NONE
   111                          		!WORD NOESCAPE-1	; NONE
   112                            }
   113                          }
   114                          
   115                          ;-------------- Normal ESC Codes
   116                          
   117  eb64 a3eb               		!WORD ESCAPE_AT-1	; Esc-@ Clear Remainder of Screen
   118  eb66 a3eb               		!WORD ESCAPE_A-1	; Esc-a Auto Insert
   119  eb68 e6e5               		!WORD ESCAPE_B-1	; Esc-b Bottom
   120  eb6a a3eb               		!WORD ESCAPE_C-1	; Esc-c Cancel Auto Insert
   121  eb6c e4e2               		!WORD ESCAPE_D-1	; Esc-d Delete Line
   122  eb6e a6eb               		!WORD ESCAPE_E-1	; Esc-e ?     / Fill BG    (was: Cursor Non Flash)
   123  eb70 a9eb               		!WORD ESCAPE_F-1	; Esc-f Flash / Fill FG+BG (was: Cursor Flash)
   124  eb72 f3eb               		!WORD ESCAPE_G-1	; Esc-g Bell Enable
   125  eb74 faeb               		!WORD ESCAPE_H-1	; Esc-h Bell Disable
   126  eb76 c4e5               		!WORD ESCAPE_I-1	; Esc-i Insert Line
   127  eb78 cae1               		!WORD ESCAPE_J-1	; Esc-j Start-of-Line
   128  eb7a a3eb               		!WORD ESCAPE_K-1	; Esc-k End-of-Line
   129  eb7c a3eb               		!WORD ESCAPE_L-1	; Esc-l Scroll On
   130  eb7e a3eb               		!WORD ESCAPE_M-1	; Esc-m Scroll Off
   131  eb80 d3ec               		!WORD ESCAPE_N-1	; Esc-n Screen Normal
   132  eb82 bae3               		!WORD ESCAPE_O-1	; Esc-o Escape all modes (Also: <ESC><ESC>)
   133  eb84 93e3               		!WORD ESCAPE_P-1	; Esc-p Erase Begin
   134  eb86 01ec               		!WORD ESCAPE_Q-1	; Esc-q Erase End
   135  eb88 dbec               		!WORD ESCAPE_R-1	; Esc-r Screen Reverse
   136  eb8a 07ec               		!WORD ESCAPE_S-1	; Esc-s Text/Lowercase Mode * (was: Block Cursor)
   137  eb8c a3e5               		!WORD ESCAPE_T-1	; Esc-t Top
   138  eb8e 0dec               		!WORD ESCAPE_U-1	; Esc-u Graphics/Uppercase Mode * (was: Underline Cursor)
   139  eb90 e0e3               		!WORD ESCAPE_V-1	; Esc-v Scroll Up
   140  eb92 c7e3               		!WORD ESCAPE_W-1	; Esc-w Scroll Down
   141  eb94 cdec               		!WORD ESCAPE_X-1	; Esc-x Switch 40/80 Col
   142  eb96 e3ec               		!WORD ESCAPE_Y-1	; Esc-y Normal Chr Set * (was: Set Default Tabs)
   143  eb98 ebec               		!WORD ESCAPE_Z-1	; Esc-z Alternate Chr Set * (was: Clear All Tabs)
   144  eb9a 13ec               		!WORD ESCAPE_LB-1	; Esc-[ Mark Start
   145  eb9c acec               		!WORD ESCAPE_BS-1	; Esc-\ Toggle ASCII / DIN
   146  eb9e 39ec               		!WORD ESCAPE_RB-1	; Esc-] Mark End (Copy)
   147  eba0 86ec               		!WORD ESCAPE_UA-1	; Esc-UPARROW Paste
   148  eba2 a3eb               		!WORD ESCAPE_BA-1	; Esc-BACKARROW Display Project Info
   149                          
   150                          ;=============== ESCAPE CODES not in normal PET code
   151                          ;
   152                          ; The following ESCAPE CODE entry points need to be assigned
   153                          ; and/or additional code must be written to support them.
   154                          
   155                          ESCAPE_AT	; Esc-@ Clear Remainder of Screen
   156                          ESCAPE_A	; Esc-a Auto Insert
   157                          ESCAPE_C	; Esc-c Cancel Auto Insert
   158                          ESCAPE_K	; Esc-k End-of-Line
   159                          ESCAPE_L	; Esc-l Scroll On
   160                          ESCAPE_M	; Esc-m Scroll Off
   161                          
   162                          !IF SS40=0 {
   163                          ESCAPE_X	; Esc-x Switch 40/80 Col
   164                          }
   165                          		
   166                          !IF INFO=0 {
   167                          ESCAPE_BA	; Esc-Backarrow Display Project info
   168                          }
   169                          
   170                          ;-------------- These are codes that are not in 40-COL Codebase C0
   171                          
   172                          !IF CODEBASE=0 {
   173                          ESCAPE_B	; ESC-B Set Window Bottom
   174                          ESCAPE_T	; ESC-T Set Window Top
   175                          ESCAPE_D	; ESC-D Delete Line
   176                          ESCAPE_I	; ESC-I Insert Line
   177                          ESCAPE_J	; ESC-J Start of Line
   178                          }
   179                          
   180  eba4 4c99e1             NOESCAPE	JMP IRQ_EPILOG				; Ignore sequence for now
   181                          
   182                          
   183                          ;====================================================================================
   184                          ; New ESC sequences
   185                          ;====================================================================================
   186                          
   187                          ;-------------- ColourPET Colours
   188                          
   189                          !IF COLOURPET=1 {
   190                          ESCAPE_NUM	LDA DATAX				; Character
   191                          		SEC
   192                          		SBC #$30				; Subtract 30 (Start at "0")
   193                          
   194                          ESC_NUM2	TAX					; The Colour number becomes the index
   195                          		LDA COLOURS,X				; Lookup the correct PETSCII code
   196                          		STA DATAX				; replace ESC code with colour code
   197                          		LDA #0					;
   198                          		JMP ESC_DONE2				; return and process
   199                          }
   200                          
   201                          ;-------------- Video Configuration Switching
   202                          
   203                          !IF VIDSWITCH=1 {
   204                          ESCAPE_VID	LDA DATAX				; Character
   205                          		SEC
   206                          		SBC #$30				; Subtract 30 (Start at "0")
   207                          		ASL
   208                          		ASL
   209                          		ASL
   210                          		ASL					; multiply by 16 (# of bytes per each set)
   211                          		TAY					; Y is offset into table
   212                          		LDX #0					; byte counter
   213                          
   214                          ESCVLOOP	LDA VIDMODE0,Y				; Get byte from table at offset Y
   215                          		STX CRT_Address				; Select the CRTC register 			CHIP
   216                          		STA CRT_Status				; Write to the register				CHIP
   217                          		INY					; Next table byte
   218                          		INX					; count
   219                          		CPX #14					; We copy R0 to R13. 14/15 are always zero.
   220                          		BMI ESCVLOOP				; loop for more
   221                          		LDA #0					;
   222                          		JMP IRQ_EPILOG				; Ignore sequence for now
   223                          
   224                          ;-------------- VIDEO MODES TABLE
   225                          ;
   226                          ; These are CRTC register sets. There are 16 bytes per set to make calculations simpler.
   227                          ; Use ESC+0 to ESC+9 to select a set to configure the CRTC controller.
   228                          ; NOTE: The CRTC registers can be updated using CHR codes 14 and 142 causing the video
   229                          ;       to revert to the default CRTC settings as set from the main code. This feature
   230                          ;       is handy for hardware testing or using an external composite adapter.
   231                          ;
   232                          ;         REGISTER -> R0 R1 R2 R3 R4  R5 R6 R7 R8 R9 R10 R11 R12 R13 Rxx Rxx   DESCRIPTION
   233                          ;                     -- -- -- -- -- --- -- -- -- -- --- --- --- --- --- ---   -----------
   234                          VIDMODE0 	!byte 49,40,41,15,40,  3,25,29, 0, 9,  0,  0, 16,  0,  0,  0 ; 40/80 TEXT     NA
   235                          VIDMODE1        !byte 49,40,41,15,32,  5,25,33, 0, 7,  0,  0, 16,  0,  0,  0 ; 40/80 GRAPHIC  NA
   236                          VIDMODE2	!byte 49,40,41,15,39,  0,25,32, 0, 9,  0,  0, 16,  0,  0,  0 ; 40/80 TEXT     EURO
   237                          VIDMODE3	!byte 49,40,41,15,49,  0,25,37, 0, 7,  0,  0, 16,  0,  0,  0 ; 40/80 GRAPHIC  EURO
   238                          VIDMODE4	!byte 58,40,44, 8,32,  9,25,29, 0, 9,  0,  0, 16,  0,  0,  0 ; 8296D TEXT     EURO
   239                          VIDMODE5	!byte 58,40,44, 8,41,  3,25,34, 0, 7,  0,  0, 16,  0,  0,  0 ; 8296D GRAPHIC  EURO
   240                          VIDMODE6        !byte 63,40,50,18,30,  6,25,28, 0, 7,  0,  0, 16,  0,  0,  0 ; NTSC
   241                          VIDMODE7	!byte 63,40,50,18,30,  6,25,28, 0, 7,  0,  0,  0,  0,  0,  0 ; NTSC / INVERT VIDEO
   242                          VIDMODE8	!byte 63,40,47,20,36,123,25,32, 0, 7,  0,  0, 16,  0,  0,  0 ; PAL
   243                          VIDMODE9        !byte 63,40,47,20,36,123,25,32, 0, 7,  0,  0,  0,  0,  0,  0 ; PAL  / INVERT VIDEO
   244                          ;
   245                          ; Extra Modes. You can substitute this mode for any above if you want
   246                          ;VIDMODEXXXX	!byte 49,20,31,15,40,  5,25,33, 0, 9,  0,  0, 16,  0,  0,  0 ; 20/40 TEXT     NA
   247                          
   248                          }
   249                          
   250                          ;------------------------------------------------------------------------------------------------
   251                          ; ESC-BACKARROW Display Project Info
   252                          
   253                          !IF INFO>0 {
   254                          ESCAPE_BA
   255                          
   256                          ;-------------- DISPLAY FONT ON SCREEN
   257                          !IF INFO = 2 {
   258                          		LDY #0				; Y=0
   259                          INFLOOP		TYA				; LOOP[  A=Y
   260                          		STA SCREEN_RAM,Y		; Put it on the screen
   261                          		INY				; Next position and character
   262                          		BNE INFLOOP			; ] Loop for more
   263                          }
   264                          
   265                          ;-------------- DISPLAY PROJECT INFO		
   266                          !IF INFO > 0 {
   267                          		LDA #<INFOSTRING		; point to INFO string
   268                          		LDY #>INFOSTRING
   269                          		JSR STROUTZ
   270                          		JMP IRQ_EPILOG
   271                          }
   272                          }
   273                          
   274                          ;------------------------------------------------------------------------------------------------
   275                          ; ESC-E = Fill BG Colour
   276                          ; For NormalPET ?
   277                          ; For ColourPET will fill the screen with the current BG colour (ignores window)
   278                          ;               The FG of each character is not changed.
   279                          ; Note: This might be changed in the future to work with windows!
   280                          
   281                          ESCAPE_E
   282                          
   283                          !if COLOURPET=1 {
   284                          		LDA COLOURV
   285                          		AND #$F0
   286                          		STA TMPZB7
   287                          		LDX #0
   288                          ESCELOOP
   289                          		LDA COLOUR_RAM,X
   290                          		AND #$0F
   291                          		ORA TMPZB7
   292                          		STA COLOUR_RAM,X
   293                          
   294                          		LDA COLOUR_RAM+250,X
   295                          		AND #$0F
   296                          		ORA TMPZB7
   297                          		STA COLOUR_RAM+250,X
   298                          
   299                          		LDA COLOUR_RAM+500,X
   300                          		AND #$0F
   301                          		ORA TMPZB7
   302                          		STA COLOUR_RAM+500,X
   303                          
   304                          		LDA COLOUR_RAM+750,X
   305                          		AND #$0F
   306                          		ORA TMPZB7
   307                          		STA COLOUR_RAM+750,X	; don't overwrite non-visible locations (used for storage)
   308                          
   309                          !IF COLUMNS=80 {
   310                          		LDA COLOUR_RAM+1000,X
   311                          		AND #$0F
   312                          		ORA TMPZB7
   313                          		STA COLOUR_RAM+1000,X
   314                          
   315                          		LDA COLOUR_RAM+1250,X
   316                          		AND #$0F
   317                          		ORA TMPZB7
   318                          		STA COLOUR_RAM+1250,X
   319                          
   320                          		LDA COLOUR_RAM+1500,X
   321                          		AND #$0F
   322                          		ORA TMPZB7
   323                          		STA COLOUR_RAM+1500,X
   324                          
   325                          		LDA COLOUR_RAM+1750,X
   326                          		AND #$0F
   327                          		ORA TMPZB7
   328                          		STA COLOUR_RAM+1750,X	; don't overwrite non-visible locations (used for storage)
   329                          }
   330                          		INX
   331                          		CPX #250
   332                          		BNE ESCELOOP
   333                          }
   334  eba7 4c99e1             		JMP IRQ_EPILOG
   335                          
   336                          
   337                          ;------------------------------------------------------------------------------------------------
   338                          ; ESC-F = Flash Screen / Fill FG+BG Colour (was: Cursor Flash)
   339                          ; For NormalPET this will toggle the REVERSE bit (bit 7) of each character on the screen (ignores window)
   340                          ; For ColourPET this will fill the screen with the current colour FG+BG (ignores window)
   341                          ; Note: This might be changed in the future to work with windows!
   342                          
   343                          ESCAPE_F
   344                          
   345                          !if COLOURPET=1 {
   346                          		LDX #0
   347                          		LDA COLOURV
   348                          
   349                          ESCFLOOP	STA COLOUR_RAM,X
   350                          		STA COLOUR_RAM+$100,X
   351                          		STA COLOUR_RAM+$200,X
   352                          		STA COLOUR_RAM+$300-24,X	; don't overwrite non-visible locations (used for storage)
   353                          !IF COLUMNS = 80 {
   354                          		STA COLOUR_RAM+$400-24,X
   355                          		STA COLOUR_RAM+$500-24,X
   356                          		STA COLOUR_RAM+$600-24,X
   357                          		STA COLOUR_RAM+$700-48,X	; don't overwrite non-visible locations (used for storage)
   358                          }
   359                          		INX
   360                          		BNE ESCFLOOP
   361                          }
   362                          
   363                          !if COLOURPET=0 {
   364  ebaa a200               		LDX #0
   365                          ESCFLOOP2
   366  ebac bd0080             		LDA SCREEN_RAM,X
   367  ebaf 4980               		EOR #$80
   368  ebb1 9d0080             		STA SCREEN_RAM,X
   369                          
   370  ebb4 bdfa80             		LDA SCREEN_RAM+250,X
   371  ebb7 4980               		EOR #$80
   372  ebb9 9dfa80             		STA SCREEN_RAM+250,X
   373                          
   374  ebbc bdf481             		LDA SCREEN_RAM+500,X
   375  ebbf 4980               		EOR #$80
   376  ebc1 9df481             		STA SCREEN_RAM+500,X
   377                          
   378  ebc4 bdee82             		LDA SCREEN_RAM+750,X
   379  ebc7 4980               		EOR #$80
   380  ebc9 9dee82             		STA SCREEN_RAM+750,X	; don't overwrite non-visible locations (used for storage)
   381                          
   382                          !IF COLUMNS = 80 {
   383  ebcc bde883             		LDA SCREEN_RAM+1000,X
   384  ebcf 4980               		EOR #$80
   385  ebd1 9de883             		STA SCREEN_RAM+1000,X
   386                          
   387  ebd4 bde284             		LDA SCREEN_RAM+1250,X
   388  ebd7 4980               		EOR #$80
   389  ebd9 9de284             		STA SCREEN_RAM+1250,X
   390                          
   391  ebdc bddc85             		LDA SCREEN_RAM+1500,X
   392  ebdf 4980               		EOR #$80
   393  ebe1 9ddc85             		STA SCREEN_RAM+1500,X
   394                          
   395  ebe4 bdd686             		LDA SCREEN_RAM+1750,X
   396  ebe7 4980               		EOR #$80
   397  ebe9 9dd686             		STA SCREEN_RAM+1750,X	; don't overwrite non-visible locations (used for storage)
   398                          }
   399  ebec e8                 		INX
   400  ebed e0fa               		CPX #250
   401  ebef d0bb               		BNE ESCFLOOP2
   402                          
   403                          }
   404  ebf1 4c99e1             		JMP IRQ_EPILOG
   405                          
   406                          ;------------------------------------------------------------------------------------------------
   407                          ESCAPE_G						; Esc-g Bell Enable
   408  ebf4 a901               		LDA #1
   409  ebf6 85f2               		STA BELLMODE
   410  ebf8 4c99e1             		JMP IRQ_EPILOG
   411                          
   412                          ;------------------------------------------------------------------------------------------------
   413                          ESCAPE_H						; Esc-h Bell Disable
   414  ebfb a900               		LDA #0
   415  ebfd 85f2               		STA BELLMODE
   416  ebff 4c99e1             		JMP IRQ_EPILOG
   417                          
   418                          ;------------------------------------------------------------------------------------------------
   419                          ESCAPE_Q						; Esc-q Erase End
   420  ec02 20c1e1             		JSR ERASE_TO_EOL
   421  ec05 4c99e1             		JMP IRQ_EPILOG
   422                          ;------------------------------------------------------------------------------------------------
   423                          ESCAPE_S						; Esc-s Standard Lowercase (was: Block Cursor)
   424  ec08 2076e0             		JSR CRT_SET_TEXT			; Set Lowercase/Text Mode
   425  ec0b 4c99e1             		JMP IRQ_EPILOG
   426                          ;------------------------------------------------------------------------------------------------
   427                          ESCAPE_U						; Esc-u Uppercase (was: Underline Cursor - not supported on PET)
   428  ec0e 2079e0             		JSR CRT_SET_GRAPHICS			; Set Uppercase/Graphics Mode
   429  ec11 4c99e1             		JMP IRQ_EPILOG
   430                          
   431                          ;-------------- Copy/Paste functions
   432                          ;
   433                          ; These functions use Tape Buffer#1 to store copied byte(s)
   434                          ; TAPEB1   - Set to "ESC" character to indicate valid Start Marker
   435                          ; TAPEB+1  - Length of string (Max 160 characters)
   436                          ; TAPEB+2/3- Pointer to screen marked starting position 
   437                          ; TAPEB+4..- Buffer
   438                          ;
   439                          ; TODO: Add check for buffer start > buffer end !!!!
   440                          
   441                          ;-------------- ESC-[ Mark Start
   442                          
   443                          ESCAPE_LB
   444  ec14 ad7a02             		LDA TAPEB1				; Read Buffer Identifier
   445  ec17 c91b               		CMP #27					; is it ESC?
   446  ec19 f00a               		BEQ ESCLB_SET				; Yes, Start Mark, so skip initialize
   447                          
   448  ec1b a900               		LDA #0					; Initialize buffer -
   449  ec1d 8d7b02             		STA TAPEB1+1				; Set Buffer Length to zero
   450  ec20 a91b               		LDA #27					; Buffer identifier = ESC
   451  ec22 8d7a02             		STA TAPEB1				; Set Buffer identifier
   452                          ESCLB_SET	
   453  ec25 a5c5               		LDA ScrPtr+1				; Copy HI byte of line pointer
   454  ec27 8d7d02             		STA TAPEB1+3				; to buffer
   455  ec2a a5c4               		LDA ScrPtr				; Get LO byte of line pointer
   456  ec2c 18                 		CLC
   457  ec2d 65c6               		ADC CursorCol				; Add cursor offset
   458  ec2f 8d7c02             		STA TAPEB1+2				;   to buffer
   459  ec32 9003               		BCC ESCLB_SKIP				; do we need to update HI byte?
   460  ec34 ee7d02             		INC TAPEB1+3				; yes, increment it
   461  ec37 4c99e1             ESCLB_SKIP	JMP IRQ_EPILOG				; Return
   462                          
   463                          ;--------------- ESC-] Mark End (Copy to buffer)
   464                          
   465                          ESCAPE_RB	
   466  ec3a ad7a02             		LDA TAPEB1				; Read Buffer Identifier
   467  ec3d c91b               		CMP #27					; is it ESC?
   468  ec3f d043               		BNE ESCRB_EXIT				; No Start Mark, so exit out
   469                          		
   470                          ESCRB_INIT
   471  ec41 ad7d02             		LDA TAPEB1+3				; Copy Hi byte of paste buffer pointer
   472  ec44 85c8               		STA SAL+1				;   to work pointer
   473  ec46 ad7c02             		LDA TAPEB1+2				; Copy Lo byte of paste buffer pointer
   474  ec49 85c7               		STA SAL					;   to work pointer
   475                          
   476  ec4b a5c5               		LDA ScrPtr+1				; Copy Hi byte of screen pointer
   477  ec4d 85ca               		STA EAL+1				;   to work pointer 2
   478  ec4f a5c4               		LDA ScrPtr				; Copy Lo byte of screen pointer
   479  ec51 18                 		CLC
   480  ec52 65c6               		ADC CursorCol				; Add cursor position
   481  ec54 85c9               		STA EAL					;   to work pointer 2
   482  ec56 9002               		BCC ESCRB_SKIP				; do we need to update Hi byte?
   483  ec58 e6ca               		INC EAL+1				; yes, increment it
   484                          
   485  ec5a a200               ESCRB_SKIP	LDX #0					; length counter
   486  ec5c a000               		LDY #0					; offet for pointer
   487                          ESCRB_LOOP
   488  ec5e b1c7               		LDA (SAL),Y				; read byte from screen (SAL is updated, y never changes)
   489  ec60 9d7e02             		STA TAPEB1+4,X				; Store in buffer (x is index)
   490                          
   491  ec63 a5c8               		LDA SAL+1				; Get HI byte
   492  ec65 c5ca               		CMP EAL+1				; Does it match?
   493  ec67 d006               		BNE ESCRB_CHECK				; no, keep going
   494  ec69 a5c7               		LDA SAL					; get lo byte of pointer
   495  ec6b c5c9               		CMP EAL					; does it match?
   496                          
   497  ec6d b00d               		BCS ESCRB_DONE				; yes, finish up
   498                          
   499  ec6f e8                 ESCRB_CHECK	INX
   500  ec70 e6c7               		INC SAL					; Increment pointer LO byte
   501  ec72 a5c7               		LDA SAL					; read it
   502  ec74 d002               		BNE ESCRB2				; is byte 0? No, skip hi byte
   503  ec76 e6c8               		INC SAL+1				; yes, increment hi byte
   504                          
   505  ec78 e0a0               ESCRB2		CPX #160				; Are we at maximum buffer length?
   506  ec7a d0e2               		BNE ESCRB_LOOP				; No, loop back for more
   507                          
   508  ec7c 8e7b02             ESCRB_DONE	STX TAPEB1+1				; Store string length
   509  ec7f a900               		LDA #0
   510  ec81 9d7f02             		STA TAPEB1+5,X				; Store a ZERO at end for STROUT routine
   511  ec84 4c99e1             ESCRB_EXIT	JMP IRQ_EPILOG				; Return
   512                          
   513                          ;--------------- ESC-UPARROW - Copy from buffer to screen
   514                          ESCAPE_UA	
   515  ec87 ad7a02             		LDA TAPEB1				; Read Buffer Identifier
   516  ec8a c91b               		CMP #27					; is it ESC?
   517  ec8c d01c               		BNE ESCUA_OUT				; No Start Mark, so exit out
   518                          
   519  ec8e 20b5e6             		JSR BEEP
   520  ec91 a97e               		lda #<TAPEB1+4				; setup string address
   521  ec93 85c7               		STA SAL
   522  ec95 a002               		ldy #>TAPEB1+4
   523  ec97 85c8               		STA SAL+1
   524                          
   525  ec99 a000               ESCUA_LOOP	LDY #0					; counter
   526  ec9b b1c7               		LDA (SAL),Y				; get byte from buffer
   527  ec9d f00b               		BEQ ESCUA_OUT
   528  ec9f 20d2ff             		JSR BSOUT				; print it
   529  eca2 e6c7               		INC SAL
   530  eca4 d0f3               		BNE ESCUA_LOOP
   531  eca6 e6c8               		INC SAL+1
   532  eca8 d0ef               		BNE ESCUA_LOOP
   533                          
   534  ecaa 4c99e1             ESCUA_OUT	JMP IRQ_EPILOG				; Return		
   535                          
   536                          
   537                          ;-------------- Eurokey Functions
   538                          ;
   539                          ; These functions SET or CLEAR the EUROFLAG location.
   540                          ; A '0' means use ASCII layout. A '1' means use DIN layout (swap Y and Z)
   541                          
   542  ecad a5f3               ESCAPE_BS	LDA EUROFLAG
   543  ecaf 4901               		EOR #1
   544                          
   545  ecb1 85f3               EuroSet		STA EUROFLAG
   546  ecb3 20b5e6             		JSR BEEP
   547  ecb6 4c99e1             		JMP IRQ_EPILOG
   548                          
   549                          ;-------------- Check if Euro keys need swapping
   550                          ;
   551                          ; .A contains character to add to keyboard buffer. If EUROFLAG=1 then check if Y or Z need swapping.
   552                          
   553  ecb9 a6f3               EUROSWAP	LDX EUROFLAG		; Flag to swap Z and Y keys; 1=Swap
   554  ecbb f00e               		BEQ EUROSWAP_OUT
   555                          
   556  ecbd c95a               		CMP #'Z'		; Is it "Z"?
   557  ecbf d004               		BNE EUROSWAP2
   558  ecc1 a959               		LDA #'Y'		; Yes, swap with "Y"
   559  ecc3 d006               		BNE EUROSWAP_OUT
   560  ecc5 c959               EUROSWAP2	CMP #'Y'		; Is it "Y"?
   561  ecc7 d002               		BNE EUROSWAP_OUT
   562  ecc9 a95a               		LDA #'Z'		; Yes, swap with "Z"
   563  eccb 4c60e5             EUROSWAP_OUT	JMP SCAN_NORM2		; Return to keyboard routine
   564                          
   565                          
   566                          ;-------------- Switchable 40/80 column Functions
   567                          ;
   568                          ; When SS40=1, ESC-X switches between 40/80 column mode.
   569                          ; Currently this is done with SOFT40 method where the 80 column screen is
   570                          ; reprogrammed to 40 column by increasing the left and right margins.
   571                          ; With future hardware we may be able to switch between REAL 40/80 column mode.
   572                          
   573                          !IF SS40=1 {
   574  ecce 200ced             ESCAPE_X	JSR SS40_SwapModes	; Swap 40/80 Modes
   575  ecd1 4c99e1             		JMP IRQ_EPILOG		
   576                          }
   577                          
   578                          ;-------------- CRTC Chip Functions
   579                          ;
   580                          ; CRTC controller REGISTER 12 is used for Screen RAM Address HI
   581                          ; BIT 4 controls the INVERT line     (normal=1,rvs=0)
   582                          ; BIT 5 controls the CHR OPTION line (normal=0,alternate=1)
   583                          ;
   584                          ; NOTE: Only the MOTOROLA 6845 CRTC chip can READ register 12!
   585                          ; If MOT6845=0 then Register 12 is simply set (default for compatibility with most PET machines!)
   586                          ; If MOT6845=1 then Register 12 is read and then manipulated.
   587                          
   588                          ESCAPE_N						; ESC-N = Screen Normal
   589  ecd4 20f8ec             		JSR CRTPREP
   590                          	!if MOT6845=1 {
   591                          		ORA #%00010000				; Set BIT 4
   592                          	} else {
   593  ecd7 a910               		LDA #16					; Normal screen, Normal chr set
   594                          	}
   595  ecd9 4cf1ec             		JMP CRTUPDATE
   596                          
   597                          ESCAPE_R						; ESC-R = Screen Reverse
   598  ecdc 20f8ec             		JSR CRTPREP
   599                          	!if MOT6845=1 {
   600                          		AND #%11101111				; Clear BIT 4
   601                          	} else {
   602  ecdf a900               		LDA #0					; Reverse screen, Normal chr set
   603                          	}
   604  ece1 4cf1ec             		JMP CRTUPDATE
   605                          
   606                          ESCAPE_Y						; ESC-Y = Normal Chr Set    (B-series). Was: Set Default Tabs (C128)
   607  ece4 20f8ec             		JSR CRTPREP
   608                          	!if MOT6845=1 {
   609                          		AND #%11011111				; Clear BIT 5
   610                          	} else {
   611  ece7 a910               		LDA #16					; Normal screen, Normal chr set
   612                          	}
   613  ece9 4cf1ec             		JMP CRTUPDATE
   614                          				
   615                          ESCAPE_Z						; ESC-Z = Alternate Chr Set (B-Series). Was: Clear All Tabs (C128)
   616  ecec 20f8ec             		JSR CRTPREP
   617                          	!if MOT6845=1 {
   618                          		ORA #%00100000				; Set BIT 5
   619                          	} else {
   620  ecef a930               		LDA #48					; Normal screen, Alternate chr set
   621                          	}
   622                          CRTUPDATE
   623  ecf1 8d81e8             		STA CRT_Status				; Write the Value to previously selected register
   624  ecf4 58                 		CLI					; Enable Interrupts
   625  ecf5 4c99e1             		JMP IRQ_EPILOG				; Continue
   626                          
   627  ecf8 78                 CRTPREP		SEI
   628  ecf9 a90c               		LDA #12					; CRTC Register#12 - Display Address HI
   629  ecfb 8d80e8             		STA CRT_Address				; Select the Register 
   630  ecfe ad81e8             		LDA CRT_Status				; Read the Value (if CRTC chip is NOT a Motorola6845 then this will not work)
   631  ed01 60                 		RTS

; ******** Source: editrom_hi.asm
    68                          
    69                          		!IF COLOURPET = 1 {
    70                          			!SOURCE "cpetsubs.asm"
    71                          			!IF CODEBASE=0 { !SOURCE "screen1c.asm" }
    72                           		}
    73                          
    74                          		!IF SS40 = 1 {

; ******** Source: editsoft40.asm
     1                          ; PET/CBM EDIT ROM   Switchable Soft-40
     2                          ; ================
     3                          ;
     4                          ; When 'SS40=1' module is included.
     5                          ; When 'HARD4080=1' we use hardware 40/80 switching
     6                          ; Memory location 'SCN4080BOARD' will be set to 1 in INIT routine when HARD4080 is set to 1.
     7                          ; Requires "crt-tables-ss40.asm" 
     8                          ;
     9                          ; Switchable Soft-40 allows the computer to switch from 80 column to 40 column mode.
    10                          ; This can be accomplished in two ways:
    11                          ; 
    12                          ; 1) Software Only: Re-programs the CRTC chip's registers to increase the left/right margins and therefore
    13                          ;                   reduce the number of characters per line to 40. The characters are still the same width.
    14                          ;                   Memory is mapped exactly like 40-column mode, so pokes to the screen will work correctly.
    15                          ;
    16                          ; 2) Hardware Mod:  An add-on board modifies the hardware to behave like "real" 40 or 80 columns. The width
    17                          ;                   of the characters changes so that 40 column characters are twice as wide as 80 column.
    18                          ;                   Margins remain the same, and in fact, CRTC registers do not need to be modified. 
    19                          ;
    20                          ; To implement SS40 we need to fix the following routines:
    21                          ;
    22                          ; * CRT_SET_TEXT	- Set TEXT mode
    23                          ; * CRT_SET_GRAPHICS	- Set GRAPHICS mode
    24                          ; * CRT_PROGRAM		- Programs the CRTC controller chip
    25                          ; * FULL_SCREEN_WINDOW	- Sets the screen dimensions (Usually hardcoded to 80x25 or 40x25)
    26                          ; * UPDATE_CURSOR_ROW   - Sets screen pointers
    27                          ;
    28                          ; To switch between 40/80 column we need a new method to activate the switch. The easiest is to include
    29                          ; ESC codes (ESC-X to switch). To switch without ESC codes we would need to (re)define some CHR$()
    30                          ; codes, or use a keyboard shortcut such as backarrow.
    31                          ;
    32                          ; Variable (memory) Usage:
    33                          ; SCNWIDTH...... Current Screen Width (40 or 80)
    34                          ; SCN4080BOARD.. Flag for Hardware 40/80 board. Set to "1" on powerup if board is enabled.
    35                          ;                We can manually change this to "0" if we want to use the SOFTWARE method.
    36                          ;
    37                          ;************** Init Switchable Soft-40
    38                          
    39  ed02 a950               SS40_INIT80	LDA #80					; Set 80 column mode
    40  ed04 85f0               		STA SCNWIDTH				; Store it
    41  ed06 60                 		RTS
    42                          
    43  ed07 a928               SS40_INIT40	LDA #40					; Set 40 column mode
    44  ed09 85f0               		STA SCNWIDTH				; Store it
    45  ed0b 60                 		RTS
    46                          
    47                          ;************** Switch Modes
    48                          
    49                          SS40_SwapModes
    50  ed0c a5f0               		LDA SCNWIDTH				; Check current screen width
    51  ed0e c928               		CMP #40					; Is it 40?
    52  ed10 f006               		BEQ SS40_SET80				; Yes, switch it to 80
    53                          
    54  ed12 2007ed             SS40_SET40	JSR SS40_INIT40				; No, switch it to 40
    55  ed15 4c1bed             		JMP SS40_DOIT
    56                          
    57  ed18 2002ed             SS40_SET80	JSR SS40_INIT80				; Set to 80
    58                          
    59  ed1b 2025ed             SS40_DOIT	JSR CRT_SET_TEXT_SS40			; Program CRTC for Text mode
    60  ed1e 20d2e1             		JSR FULL_SCREEN				; Clear windows
    61  ed21 2051e0             		JSR WIN_CLEAR				; Clear the screen
    62  ed24 60                 		RTS		
    63                          
    64                          
    65                          ;************* Set Screen to TEXT or GRAPHICS MODE
    66                          
    67                          CRT_SET_TEXT_SS40
    68  ed25 a00e               		LDY #$0E				; Character Set = TEXT
    69  ed27 d002               		BNE CRT_SET_SS40
    70                          CRT_SET_GRAPHICS_SS40
    71  ed29 a00c               		LDY #$0C				; Character Set = GRAPHICS
    72                          
    73                          ;************* Check 40/80 Mode 
    74                          ; SCN4080BOARD low memory location will be set to "1" on powerup if board is installed.
    75                          ; We can change this to "0" if we want to use the SOFTWARE method to do 40 columns.
    76                          
    77  ed2b a5f4               CRT_SET_SS40	LDA SCN4080BOARD			; is the 40/80 hardware board installed?
    78  ed2d d00c               		BNE CRT_SET_80				; Yes, use normal CRTC registers
    79                          
    80                          ;************** Check Screen Width
    81                          
    82  ed2f a5f0               		LDA SCNWIDTH				; What is the width?
    83  ed31 c950               		CMP #80					; Is it 80?
    84  ed33 f006               		BEQ CRT_SET_80				; Yes, jump ahead
    85                          
    86                          ;************** Set CRTC Table pointers
    87                          
    88  ed35 a9e8               CRT_SET_40	LDA #<CRT_CONFIG_TEXT2			; Point to CRTC Table2 (40 column)
    89  ed37 a2ed               		LDX #>CRT_CONFIG_TEXT2			; Point to CRTC Table2
    90  ed39 d004               		BNE CRT_PROGRAM_SS40
    91                          
    92  ed3b a93d               CRT_SET_80	LDA #<CRT_CONFIG_TEXT			; Point to CRTC Table (80 column)
    93  ed3d a2e7               		LDX #>CRT_CONFIG_TEXT			; Point to CRTC Table
    94                          
    95                          ;************** Program CRTC chip for selected screen MODE
    96                          ; Parameters: Table pointer in A/X, CHRSET in Y
    97                          
    98                          CRT_PROGRAM_SS40
    99                          ;		--------------------- Set 'Character Set'
   100                          
   101  ed3f 85f5               		STA MYZP				; Pointer LO
   102  ed41 86f6               		STX MYZP+1				; Pointer HI
   103  ed43 ad4ce8             		LDA VIA_PCR				; Get current register byte VIA Register C - CA2	CHIP 
   104  ed46 29f0               		AND #$f0				; mask out lower nibble
   105  ed48 85d1               		STA FNLEN				; save it to Temp Variable
   106  ed4a 98                 		TYA					; Move 'Character Set' byte to A
   107  ed4b 05d1               		ORA FNLEN				; update lower nibble in Temp Variable
   108  ed4d 8d4ce8             		STA VIA_PCR				; write it back to VIA Register C - CA2			CHIP
   109                          
   110                          ;		--------------------- Write to the CRTC controller
   111                          
   112  ed50 a011               		LDY #$11				; Number of bytes to copy = 17
   113                          
   114  ed52 b1f5               SS40Loop	LDA (MYZP),Y				; Pointer
   115  ed54 8c80e8             		STY CRT_Address				; Select the register to update 6545/6845 CRT		CHIP
   116  ed57 8d81e8             		STA CRT_Status				; Write to the register
   117  ed5a 88                 		DEY
   118  ed5b 10f5               		BPL SS40Loop				; loop for more
   119                          
   120                          ;************** Check if 40/80 Board is installed (and active)
   121                          ; SCN4080BOARD low memory location will be set to "1" on powerup if board is installed.
   122                          ; We can change this to "0" if we want to use the SOFTWARE method to do 40 columns.
   123                          
   124  ed5d a5f4               		LDA SCN4080BOARD			; Is hardware 40/80 board installed?
   125  ed5f f016               		BEQ SS40_DONE				; No, we are done.
   126                          
   127                          ;************** Set 40/80 Board Control Line
   128                          ;
   129                          ; We will use the CRT Controller chip's TA11 line to control the hardware 40/80 switcher.
   130                          ; Normally TA10 and TA11 are unconnected in a standard PET/CBM system.  When TA11 is 0 the board will switch
   131                          ; to 80 column, when 1 it will be 40 column. These lines can be controlled by setting the bits of the CRTC
   132                          ; register 12, which control the video memory start address. Video memory is 2K so only TA0-9 are used. The
   133                          ; upper TA10-13 lines are used for special features. TA12 is the "REVERSE" line and is normally SET on 12"
   134                          ; monitor PET/CBM's. TA13 is used for CHR OPTION, which enables the extended character sets.
   135                          
   136  ed61 a5f0               		LDA SCNWIDTH				; Check screen width
   137  ed63 c928               		CMP #40					; Is it 40?
   138  ed65 f004               		BEQ SS40_HARD40				; Yes,
   139                          
   140  ed67 a910               SS40_HARD80	LDA #16					; 40/80 Board Control line=0 (TA11, Pin 15) = 16 = RVS(16)
   141  ed69 d002               		BNE SS40_SET_4080CONTROL
   142                          
   143  ed6b a918               SS40_HARD40	LDA #24					; 40/80 Board Control line=1 (TA11, Pin 15) = 24 = RVS(16)+TA11(8)
   144                          
   145                          SS40_SET_4080CONTROL
   146  ed6d 78                 		SEI					; No interrupts allowed
   147  ed6e a20c               		LDX #$0C				; CRTC Register 12 (Start Address HI byte)
   148  ed70 8e80e8             		STX CRT_Address				; Select the Register
   149  ed73 8d81e8             		STA CRT_Status				; Write the data - 40/80 Column mode will now be set!
   150  ed76 58                 		CLI					; Allow interrupts again
   151  ed77 60                 SS40_DONE	RTS
   152                          
   153                          
   154                          
   155                          
   156                          ;************** Screen Line Pointers
   157                          ;
   158                          ; This routine looks at the current screen width then sets the
   159                          ; screen line pointer from the appropriate table (40 or 80)
   160                          
   161                          SS40_ScreenPointers
   162  ed78 a5f0               		LDA SCNWIDTH			; What is current screen width?
   163  ed7a c928               		CMP #40				; Is it 40?
   164  ed7c f00b               		BEQ SS40_Pointer40		; Yes, skip down
   165                          
   166                          SS40_Pointer80
   167  ed7e bd68e7             		LDA Line_Addr_Lo,X		; Screen Line Addresses LO (80 column table)
   168  ed81 85c4               		STA ScrPtr			; Pointer: Current Screen Line Address LO
   169  ed83 bd81e7             		LDA Line_Addr_Hi,X		; Screen Line Addresses HI (80 column table)
   170  ed86 85c5               		STA ScrPtr+1         		; Pointer: Current Screen Line Address HI
   171  ed88 60                 		RTS
   172                          
   173                          SS40_Pointer40
   174  ed89 bd0cee             		LDA Line_Addr_Lo2,X		; Screen Line Addresses LO (additional 40 column table)
   175  ed8c 85c4               		STA ScrPtr			; Pointer: Current Screen Line Address LO
   176  ed8e bd25ee             		LDA Line_Addr_Hi2,X		; Screen Line Addresses HI (additional 40 column table)
   177  ed91 85c5               		STA ScrPtr+1         		; Pointer: Current Screen Line Address HI
   178  ed93 60                 		RTS
   179                          
   180                          ;-------------- Sync Pointers - Current Line
   181                          ;
   182                          ; This takes the current line number in X and then uses the lookup tables
   183                          ; to find the screen address of the start of the line and stores them
   184                          ; in the Character pointers.
   185                          
   186                          SS40_SyncPointersX
   187  ed94 a5f0               		LDA SCNWIDTH				; What is current screen width?
   188  ed96 c928               		CMP #40					; Is it 40?
   189  ed98 f00b               		BEQ SS40_SPX40				; Yes, skip down
   190                          SS40_SPX80
   191  ed9a bd68e7             		LDA Line_Addr_Lo,X			; Screen Line Addresses LO (80 COL)
   192  ed9d 85c4               		STA ScrPtr				; Pointer: Current Screen Line Address LO
   193  ed9f bd81e7             		LDA Line_Addr_Hi,X			; Screen Line Addresses HI (80 COL)
   194  eda2 85c5               		STA ScrPtr+1         			; Pointer: Current Screen Line Address HI
   195  eda4 60                 		RTS
   196                          
   197                          SS40_SPX40
   198  eda5 bd0cee             		LDA Line_Addr_Lo2,X			; Screen Line Addresses LO (40 COL)
   199  eda8 85c4               		STA ScrPtr				; Pointer: Current Screen Line Address LO
   200  edaa bd25ee             		LDA Line_Addr_Hi2,X			; Screen Line Addresses HI (40 COL)
   201  edad 85c5               		STA ScrPtr+1         			; Pointer: Current Screen Line Address HI
   202  edaf 60                 		RTS
   203                          
   204                          
   205                          ;-------------- Sync Pointers - Next Line
   206                          ;
   207                          ; This takes the current line number in X and then uses the lookup tables
   208                          ; to find the screen address of the start of the NEXT line and stores them
   209                          ; in the Character pointers.
   210                          
   211                          SS40_SyncPointers
   212  edb0 a5f0               		LDA SCNWIDTH				; What is current screen width?
   213  edb2 c928               		CMP #40					; Is it 40?
   214  edb4 f00b               		BEQ SS40_SP40				; Yes, skip down
   215                          SS40_SP80
   216  edb6 bd69e7             		LDA Line_Addr_Lo+1,X			; Screen line address table LO + 1 (80 COL)
   217  edb9 85c7               		STA SAL					; Pointer: Tape Buffer/ Screen Scrolling
   218  edbb bd82e7             		LDA Line_Addr_Hi+1,X			; Screen line address table HI + 1 (80 COL)
   219  edbe 85c8               		STA SAL+1				; Pointer: Tape Buffer/ Screen Scrolling
   220  edc0 60                 		RTS
   221                          
   222                          SS40_SP40
   223  edc1 bd0dee             		LDA Line_Addr_Lo2+1,X			; Screen line address table LO + 1 (40 COL)
   224  edc4 85c7               		STA SAL					; Pointer: Tape Buffer/ Screen Scrolling
   225  edc6 bd26ee             		LDA Line_Addr_Hi2+1,X			; Screen line address table HI + 1 (40 COL)
   226  edc9 85c8               		STA SAL+1				; Pointer: Tape Buffer/ Screen Scrolling
   227  edcb 60                 		RTS
   228                          
   229                          ;-------------- Sync Pointers2 - Previous Line
   230                          
   231                          SS40_SyncPointers2
   232  edcc a5f0               		LDA SCNWIDTH				; What is current screen width?
   233  edce c928               		CMP #40					; Is it 40?
   234  edd0 f00b               		BEQ SS40_SP240				; Yes, skip down
   235                          SS40_SP280
   236  edd2 bd67e7             		LDA Line_Addr_Lo-1,X			; Screen line address table LO + 1 (80 COL)
   237  edd5 85c7               		STA SAL					; Pointer: Tape Buffer/ Screen Scrolling
   238  edd7 bd80e7             		LDA Line_Addr_Hi-1,X			; Screen line address table HI + 1 (80 COL)
   239  edda 85c8               		STA SAL+1				; Pointer: Tape Buffer/ Screen Scrolling
   240  eddc 60                 		RTS
   241                          
   242                          SS40_SP240
   243  eddd bd0bee             		LDA Line_Addr_Lo2-1,X			; Screen line address table LO + 1 (40 COL)
   244  ede0 85c7               		STA SAL					; Pointer: Tape Buffer/ Screen Scrolling
   245  ede2 bd24ee             		LDA Line_Addr_Hi2-1,X			; Screen line address table HI + 1 (40 COL)
   246  ede5 85c8               		STA SAL+1				; Pointer: Tape Buffer/ Screen Scrolling
   247  ede7 60                 		RTS
   248                          
   249                          
   250                          ;************** Additional CRTC Setup Table
   251                          

; ******** Source: crtc-reg-ss40.asm
     1                          ; PET/CBM EDIT ROM - CRTC Register Tables
     2                          ; ================
     3                          ; For "Software Switchable Soft40" configurations. Only for 80-column machines.
     4                          ; Sets the CRTC Table depending on options:
     5                          ; Uses REFRESH setting to select proper config
     6                          ;
     7                          ;======================================
     8                          ; NORMAL 4000/8000/8296/SuperPET MODELS
     9                          ;======================================
    10                          ; Common settings for "normal" machines (4000,8000,8296,SuperPET) with 12" monitor
    11                          
    12                          ;---------------------- Soft 40x25, 50 Hz, 20 kHz for 12" Internal Monitor (inverted video)
    13                          !IF REFRESH=0 {
    14                          CRT_CONFIG_TEXT2:	!byte $31,$14,$1F,$0F,$31,$00,$19,$25,$00,$09,$00,$00,$10,$00,$00,$00,$00,$00 
    15                          CRT_CONFIG_GRAPHICS2: 	!byte $31,$14,$1F,$0F,$31,$00,$19,$25,$00,$07,$00,$00,$10,$00,$00,$00,$00,$00
    16                          }
    17                          
    18                          ;---------------------- Soft 40x25, 60 Hz, 20 kHz for 12" Internal Monitor (inverted video)
    19                          !IF REFRESH=1 {
    20  ede8 31141f0f28051921...CRT_CONFIG_TEXT2:	!byte $31,$14,$1f,$0f,$28,$05,$19,$21,$00,$09,$00,$00,$10,$00,$00,$00,$00,$00 
    21  edfa 31141f0f28051921...CRT_CONFIG_GRAPHICS2:	!byte $31,$14,$1f,$0f,$28,$05,$19,$21,$00,$07,$00,$00,$10,$00,$00,$00,$00,$00
    22                          }
    23                          
    24                          ;---------------------- Soft 40x25, 50 Hz, 15.625 kHz (PAL)  for External Monitor (inverted video)
    25                          !IF REFRESH=2 {
    26                          CRT_CONFIG_TEXT2:	!byte $3f,$14,$28,$14,$24,$7b,$19,$20,$00,$09,$00,$00,$10,$00,$00,$00,$00,$00 
    27                          CRT_CONFIG_GRAPHICS2:	!byte $3f,$14,$28,$14,$24,$7b,$19,$20,$00,$07,$00,$00,$10,$00,$00,$00,$00,$00
    28                          }
    29                          
    30                          ;---------------------- Soft 40x25, 60 Hz, 15.748 kHz (NTSC) for External Monitor (inverted video)
    31                          !IF REFRESH=3 {
    32                          CRT_CONFIG_TEXT2:	!byte $31,$14,$1f,$0f,$28,$05,$19,$21,$00,$09,$00,$00,$10,$00,$00,$00,$00,$00 
    33                          CRT_CONFIG_GRAPHICS2:	!byte $31,$14,$1f,$0f,$28,$05,$19,$21,$00,$07,$00,$00,$10,$00,$00,$00,$00,$00
    34                          }
    35                          
    36                          ;---------------------- Soft 40x25, 50 Hz, 15 kHz for 9" Internal Monitor (non-inverted video)
    37                          ; **** NEEDS FIXED ****
    38                          !IF REFRESH=4 {
    39                          
    40                          }
    41                          
    42                          ;---------------------- Soft 40x25, 60 Hz, 15 kHz for 9" Internal Monitor (non-inverted video)
    43                          ; **** NEEDS FIXED ****
    44                          !IF REFRESH=5 {
    45                          
    46                          }
    47                          
    48                          ;===============
    49                          ; 8296D MACHINES
    50                          ;===============
    51                          ; The 8296D has a different monitor than standard machines and requires slightly modified timing
    52                          
    53                          ;---------------------- 40x25, 50 Hz, 16.949 kHz for 12" Internal 8296D Monitor (V1)
    54                          !IF REFRESH=82 {
    55                          ; **** NEEDS FIXED ****
    56                          }
    57                          
    58                          ;---------------------- 40x25, 50 Hz, 16.949 kHz for 12" Internal 8296D Monitor (V2)
    59                          !IF REFRESH=83 {
    60                          ; **** NEEDS FIXED ****
    61                          }
    62                          
    63                          
    64                          ;======================
    65                          ; Extended/Experimental
    66                          ;======================
    67                          ; NOTE: Screens larger than 25 lines are for 8296 ONLY!!! The 8296 has additional screen RAM.
    68                          ;       These settings push the monitor to it's maximum possible resolution. Because of this you loose
    69                          ;       the ability to expand the line height in 'text' mode.
    70                          
    71                          ;---------------------- 40x32, 60 Hz, ?? kHz for 12" Internal Monitor (8296 ONLY!!!!)
    72                          ; **** NEEDS FIXED ****
    73                          !IF REFRESH=90 {
    74                          
    75                          }
    76                          
    77                          ;---------------------- 40x35, 60 Hz, ?? kHz for 12" Internal Monitor (8296 ONLY!!!!)
    78                          ; **** NEEDS FIXED ****
    79                          !IF REFRESH=91 {
    80                          
    81                          }
    82                          
    83                          ;---------------------- 45x35, 60 Hz, ?? kHz for 12" Internal Monitor (8296 ONLY!!!!)
    84                          ; **** NEEDS FIXED ****
    85                          !IF REFRESH=92 {
    86                          
    87                          }
    88                          
    89                          ;=======================
    90                          ; CUSTOM - You Define It
    91                          ;=======================
    92                          
    93                          ;---------------------- CUSTOM - Your parameters here!
    94                          ; **** NEEDS FIXED ****
    95                          !IF REFRESH=99 {
    96                          
    97                          }
    98                          

; ******** Source: editsoft40.asm
   252                          	; Now in separate include file
   253                          
   254                          ;************** Additional Screen Line Address Tables
   255                          ;
   256                          ; The primary screen line table will be set to 80 column, so the additional
   257                          ; table is for the 40 column screen
   258                          

; ******** Source: screen2v.asm
     1                          ; PET/CBM EDIT ROM - Screen line address table - Screen 2 @ $8000 Video (characters)
     2                          ; ================
     3                          ; Variables: ROWS, COLUMNS
     4                          ; These tables are used to calculate the starting address of each line on the screen.
     5                          ; The standard screens are 40x25 and 80x25. Experimental screens can be up to 90x35.
     6                          ; 32 and 64 are included for future support of non-cbm type screens.
     7                          ; When ROWS>25 it assumes maximum 35 rows although less are supported as well.
     8                          
     9                          ;---------- 32 characters wide (32x32 = 1K RAM)
    10                          !IF COLUMNS=32 {
    11                          Line_Addr_Lo2	!byte $00,$20,$40,$60,$80,$A0,$C0,$E0,$00,$20,$40,$60,$80,$A0,$C0,$E0
    12                          		!byte $00,$20,$40,$60,$80,$A0,$C0,$E0,$00,$20,$40,$60,$80,$A0,$C0,$E0
    13                          Line_Addr_Hi2	!byte $80,$80,$80,$80,$80,$80,$80,$80,$81,$81,$81,$81,$81,$81,$81,$81
    14                          		!byte $82,$82,$82,$82,$82,$82,$82,$82,$83,$83,$83,$83,$83,$83,$83,$83
    15                          }
    16                          
    17                          ;---------- 40 characters wide 
    18                          !IF COLUMNS=40 {
    19                          Line_Addr_Lo2	!byte $00,$28,$50,$78,$a0,$c8,$f0,$18,$40,$68,$90,$b8,$e0,$08,$30,$58
    20                          		!byte $80,$a8,$d0,$f8,$20,$48,$70,$98,$c0
    21                          !if ROWS>25 {	!byte $e8,$10,$38,$60,$88,$b0,$d8,$00,$28,$50 }
    22                          
    23                          Line_Addr_Hi2	!byte $80,$80,$80,$80,$80,$80,$80,$81,$81,$81
    24                          		!byte $81,$81,$81,$82,$82,$82,$82,$82,$82,$82
    25                          		!byte $83,$83,$83,$83,$83
    26                          !if ROWS>25 {	!byte $83,$84,$84,$84,$84,$84,$84,$85,$85,$85 }
    27                          }
    28                          
    29                          ;---------- 64 characters wide (64x32 = 2K RAM)
    30                          !IF COLUMNS=64 {
    31                          Line_Addr_Lo2	!byte $00,$40,$80,$C0,$00,$40,$80,$C0,$00,$40,$80,$C0,$00,$40,$80,$C0
    32                          		!byte $00,$40,$80,$C0,$00,$40,$80,$C0,$00,$40,$80,$C0,$00,$40,$80,$C0
    33                          Line_Addr_Hi2	!byte $80,$80,$80,$80,$81,$81,$81,$81,$82,$82,$82,$82,$83,$83,$83,$83
    34                          		!byte $84,$84,$84,$84,$85,$85,$85,$85,$86,$86,$86,$86,$87,$87,$87,$87
    35                          }
    36                          
    37                          ;---------- 80 characters wide 
    38                          !IF COLUMNS=80 {
    39  ee0c 0050a0f04090e030...Line_Addr_Lo2	!byte $00,$50,$a0,$f0,$40,$90,$e0,$30,$80,$d0
    40  ee16 2070c01060b00050...		!byte $20,$70,$c0,$10,$60,$b0,$00,$50,$a0,$f0
    41  ee20 4090e03080         		!byte $40,$90,$e0,$30,$80
    42                          !if ROWS>25 {	!byte $d0,$20,$70,$c0,$10,$60,$b0,$00,$50,$a0,$f0 }
    43                          
    44  ee25 8080808081818182...Line_Addr_Hi2	!byte $80,$80,$80,$80,$81,$81,$81,$82,$82,$82
    45  ee2f 8383838484848585...		!byte $83,$83,$83,$84,$84,$84,$85,$85,$85,$85
    46  ee39 8686868787         		!byte $86,$86,$86,$87,$87
    47                          !if ROWS>25 {	!byte $87,$88,$88,$88,$89,$89,$89,$8a,$8a,$8a,$8a }
    48                          }
    49                          
    50                          ;---------- 90 characters wide
    51                          !IF COLUMNS=90 {
    52                          Line_Addr_Lo2	!byte $00,$5a,$b4,$0e,$68,$c2,$1c,$76,$d0,$2a,$84,$de,$38,$92,$ec,$46
    53                          		!byte $a0,$fa,$54,$ea,$08,$62,$bc,$16,$70,$ca,$24,$7e,$d8,$32,$8c,$e6
    54                          		!byte $40,$9a,$f4
    55                          Line_Addr_Hi2	!byte $80,$80,$80,$81,$81,$81,$82,$82,$82,$83,$83,$83,$84,$84,$84,$85
    56                          		!byte $85,$85,$86,$86,$87,$87,$87,$88,$88,$88,$89,$89,$89,$8a,$8a,$8a
    57                          		!byte $8b,$8b,$8b
    58                          }

; ******** Source: editsoft40.asm
   259                          			; Add the Character RAM table
   260                          		!IF COLOURPET=1 { !SOURCE "screen2c.asm" }	; Add the Colour RAM table
   261                          
   262                          ; ------------- For CODEBASE 0 we need to supply a "Line_Addr_Hi" table
   263                          ;
   264                          
   265                          ;***************************************************************************
   266                          ;** Need to investigate the Line Address HI for Software switchable 40/80 **
   267                          ;** and how it integrates into the line linking routines                  ** 
   268                          ;***************************************************************************
   269                          
   270                          !IF CODEBASE=0 {
   271                          
   272                          Line_Addr_Hi2	!byte $80,$80,$80,$80,$80,$80,$80,$81,$81,$81
   273                          		!byte $81,$81,$81,$82,$82,$82,$82,$82,$82,$82
   274                          		!byte $83,$83,$83,$83,$83
   275                          !if ROWS>25 {	!byte $83,$84,$84,$84,$84,$84,$84,$85,$85,$85 }
   276                          

; ******** Source: editrom_hi.asm
    75                          
    76                          			!IF CODEBASE=0 {
    77                          				!SOURCE "editrom40link.asm"	; Relocate linking code here to make space in main.
    78                          				!SOURCE "editrom40scrollup.asm"	; Relocate scroll up code here to make space in main.
    79                          				JMP CHECK_SCROLL_CONTROL	; Jump back to main.
    80                          			}
    81                          		}
    82                          	}
    83                          
    84                          	;----- These features can stand alone
    85                          
    86                          	!IF (CODEBASE=0 & KEYSCAN=3)	  { !SOURCE "keyboard-tables3.asm" }	; C64 Keyboard Scanning Tables
    87                          	!IF KEYRESET = 1  { !SOURCE "editreboot.asm" }		; Keyboard Reset Code
    88                          	!IF BACKARROW = 2 { !SOURCE "editbarrow.asm" }		; Back Arrow "hack" Code
    89                          	!IF EXECUDESK > 0 { !SOURCE "execudesk.asm" }		; Execudesk Code
    90                          	!IF UPET = 1      { !SOURCE "upet.asm" }		; UltraPET Code (Andre Fachat)
    91                          
    92                          ;=========================================================================================================
    93                          ; INFOSTRING
    94                          ;=========================================================================================================
    95                          ; Used to include project INFO into the code area so it can be used with ESC-BackArrow
    96                          ; This string can be included twice:
    97                          ;   1. In hidden I/O area from $E800-E8FF.
    98                          ;   2. Here at end of EXT binary (which needs a label so it can be printed).
    99                          
   100                          INFOSTRING
   101                          	!IF INFO > 0      { !SOURCE "info.asm" }
   102                          
   103                          ;=========================================================================================================
   104                          ; END OF CODE
   105                          ;=========================================================================================================
   106                          ; We finish off by padding the binary to exactly 4K bytes.
   107                          ;#########################################################################################################
   108                          
   109                          	!IF OPTROM=0 {
   110  ee3e ffffffffffffffff...		!IF NOFILL=0 { !FILL $F000-*,$FF }		; PAD to 4K ######################
   111                          	}				
   112                          
   113                          ; This is the end of the EXT code.
   114                          ; Do not place code below this point!

; ******** Source: editrom.asm
    51                          
    52                          	}
    53                          
    54                          ; Do not place code below this point!
